\section{The Process Hitting framework}

\towrite{Transition.}

\subsection{Definition of the Process Hitting with $k$ priorities}
\label{ssec:PH}
\towrite{Reformuler (actuellement trop proche de CMSB)}
A PH (\pref{def:ph}) gathers a finite number of concurrent \emph{processes} grouped into a finite set of \emph{sorts}.
A process belongs to a unique sort and is noted $a_i$ where $a$ is the sort and $i$ the identifier of the process within the sort $a$.
At any time, one and only one process of each sort is present; a state of the PH thus corresponds to the set of such processes.

The concurrent interactions between processes are defined by a set of \emph{actions} divided into classes of priorities.
Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process and by the fact that no other action of higher priority is playable in the current state of the PH.
An action is denoted by $\PHhit{a_i}{b_j}{b_k}$ where $a_i,b_j,b_k$ are processes of sorts $a$ and $b$.
It is required that $b_j \neq b_k$ and that $a=b\Rightarrow a_i=b_j$.
An action $h=\PHfrappe{a_i}{b_j}{b_k}$ is read as ``$a_i$ \emph{hits} $b_j$ to make it bounce to $b_k$'', and $a_i,b_j,b_k$ are called respectively \emph{hitter}, \emph{target} and \emph{bounce} of the action, and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

% Process Hitting sans priorités
\begin{comment}
\begin{definition}[Process Hitting]\label{def:PH}
A \emph{Process Hitting} is a triple $(\PHs,\PHl,\PHa)$:
\begin{itemize}
\item $\PHs \DEF \{a,b,\dots\}$ is the finite set of \emph{sorts};
\item $\PHl \DEF \prod_{a\in\PHs} \PHl_a$ is the set of states with $\PHl_a = \{a_0,\dots,a_{l_a}\}$
the finite set of \emph{processes} of sort $a\in\Sigma$ and $l_a$ a positive integer with
	$a\neq b\Rightarrow \forall(a_i,b_j)\in\PHl_a\times\PHl_b,a_i\neq b_j$;
\item $\PHa \DEF \{ \PHfrappe{a_i}{b_j}{b_k}, \dots \mid
					(a,b)\in\PHs^2 \wedge (a_i,b_j,b_k)\in \PHl_a\times\PHl_b\times\PHl_b$ \\
	\hspace*{2cm} $\wedge b_j\neq b_k \wedge a=b\Rightarrow a_i=b_j\}$
			is the finite set of \emph{actions}.
\end{itemize}
$\PHproc$ denotes the set of all processes ($\PHproc \DEF \{ a_i\mid a\in\PHs \wedge a_i\in\PHl_a\}$).
\end{definition}
\end{comment}

\begin{definition}[Process Hitting with $k$ priorities] \towrite{Revoir terminologie}
\label{def:ph}
  A \emph{Process Hitting with $k$ priorities}, where $k \in \sN^*$, is a triplet $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$, with $\PHa^{\langle k \rangle} = (\PHa^{(1)}; \dots; \PHa^{(k)})$ a $k$-uplet, where:
  \begin{itemize}
    \item $\PHs \DEF \{a,b,\dots\}$ is the finite set of \emph{sorts}.
    \item $\PHl \DEF \prod_{a \in \PHs} \PHl_a$ is the finite set of states, where $\PHl_a = \{a_0 ; \ldots ; a_{l_a}\}$ is the finite set of \emph{processes} of sort $a \in \PHs$ and $l_a \in \sN^*$. Each process belongs to a unique sort: $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$.
    \item $\forall n \in \llbracket 1; k \rrbracket, \PHa^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_k} \mid (a; b) \in \PHs^2 \wedge (a_i; b_j; b_k) \in \PHl_a \times \PHl_b \times \PHl_b \wedge b_j \neq b_k \wedge a = b \Rightarrow a_i = b_j \}$ is the finite set of \emph{actions of priority $n$}.
  \end{itemize}
  We call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all processes, and $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ the set of all actions.
\end{definition}

\noindent
The sort of a process $a_i$ is referred to as $\PHsort(a_i)=a$ and the set of sorts present in an action $h\in\PHa$ as $\PHsort(h) = \{\PHsort(\PHhitter(h)),\PHsort(\PHtarget(h))\}$.
Given a state $s\in \PHl$, the process of sort $a\in\PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is the $a$-coordinate of the state $s$.
If $a_i\in \PHl_a$, we define the notation $a_i\in s \EQDEF \PHget{s}{a}=a_i$.
We define the semantics of actions in a Process Hitting model in \pref{def:play}.

\begin{definition}
\label{def:play}
  An action $h = \PHhit{a_i}{b_j}{b_k} \in \PHa^{(n)}$ of priority $n$ is \emph{playable} in $s \in \PHl$ iff $\PHget{s}{a} = a_i$, $\PHget{s}{b} = b_j$ and $\forall m < n, \forall g \in \PHa^{(m)}, \PHhitter(g) \notin s \vee \PHtarget(g) \notin s$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$, defined by: $\PHget{(s \PHplay h)}{b} = b_k$ and $\forall c\in\PHs, c\neq b, \PHget{(s\PHplay h)}{c} = \PHget{s}{c}$.
  For the sake of clarity, for all $h, h'\in\PHa$, $((s\PHplay h)\PHplay h')$ is abbreviated as $(s\PHplay h\PHplay h')$.
\end{definition}

\begin{definition}[Scenario ($\Sce$)]
\label{def:scenario}
  For a given Process Hitting model $(\PHs,\PHl,\PHh)$,
  a \emph{scenario} $\delta$ is a sequence of actions of $\PHh$ so that for all $n \in \indexes{\delta}$,
  $a_i = \PHhitter(\delta_n)$ (resp. $\PHtarget(\delta_n)$) $\Rightarrow \last_a(\delta_{1..n-1}) \in \{ \varnothing, a_i \}$.
  The set of all scenarios is noted $\Sce$.
\end{definition}

\begin{definition}[Process Hitting $n$-reduction] \towrite{Revoir terminologie : “reduction” ? “restriction” ?}
  If $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$ is a Process Hitting with $k$ priorities and $n \in \segm{1}{k}$, we denote $\restriction{\PH}{n}$ \towrite{$\PH_{|n}$ $\PH'$} the $n$-reduction of $\PH$ the following Process Hitting with $n$ priorities:
  $\restriction{\PH}{n} = (\PHs; \PHl; \restriction{\PHa}{n})$,
  with:
  $$\restriction{\PHa}{n} = (\PHa^{(1)}; \dots; \PHa^{(n)})$$
  Furthermore, we denote: $\restriction{\Sce}{n}$ the set of scenarios of actions of $\restriction{\PHa}{n}$.
%  
%  Furthermore, we define: $\restriction{\PH}{0} = (\PHs; \PHl; \restriction{\PHa}{0})$, where $\restriction{\PHa}{0} = ()$ is a $0$-uplet.
\end{definition}

\begin{comment} %example*
\pref{fig:runningPH-1} represents a PH $(\PHs,\PHl,\PHa)$ with
$\PHs = \{a,b,c\}$,
$\PHl_a = \{a_0,a_1,a_2\}$,
$\PHl_b = \{b_0, b_1\}$,
$\PHl_c = \{c_0, c_1\}$, and
\begin{align*}
\PHa & = \{
	\PHfrappe{a_2}{b_1}{b_0},
&&  \PHfrappe{b_0}{a_2}{a_1},
&&	\PHfrappe{c_0}{a_2}{a_1},\\
&&& \PHfrappe{b_0}{a_1}{a_0},
&&	\PHfrappe{c_0}{a_1}{a_0},\\
&&& \PHfrappe{b_1}{a_0}{a_1},
&&	\PHfrappe{c_1}{a_0}{a_1},\\
&&& \PHfrappe{b_1}{a_1}{a_2},
&&	\PHfrappe{c_1}{a_1}{a_2} \}\enspace.
\end{align*}
The action $h=\PHfrappe{b_1}{a_1}{a_2}$ is playable in the state
$s = \PHstate{b_1,a_1,c_0}$; and $s\PHplay h=\PHstate{b_1,a_2,c_0}$.
%
\begin{figure}[t]
\centering
\scalebox{1.3}{
\begin{tikzpicture}
\TSort{(0,0)}{a}{3}{r}
\TSort{(-3,0.5)}{b}{2}{l}
\TSort{(3,0.5)}{c}{2}{r}
%
\THit{b_1}{very thick}{a_0}{.west}{a_1}
\THit{b_1}{very thick}{a_1}{.north west}{a_2}
\THit{b_0}{}{a_2}{.west}{a_1}
\THit{b_0}{}{a_1}{.west}{a_0}
%
\path[bounce, bend left=60]
\TBounce{a_1}{very thick}{a_2}{.south}
\TBounce{a_0}{very thick}{a_1}{.south}
;
\path[bounce, bend right=60]
\TBounce{a_2}{}{a_1}{.north}
\TBounce{a_1}{}{a_0}{.north}
;
%
\THit{c_1}{very thick}{a_0}{.east}{a_1}
\THit{c_1}{very thick}{a_1}{.north east}{a_2}
\THit{c_0}{}{a_2}{.east}{a_1}
\THit{c_0}{}{a_1}{.east}{a_0}
%
\path[bounce, bend right=60]
\TBounce{a_1}{very thick}{a_2}{.south east}
\TBounce{a_0}{very thick}{a_1}{.south east}
;
\path[bounce, bend left=60]
\TBounce{a_2}{}{a_1}{.north}
\TBounce{a_1}{}{a_0}{.north east}
;
%
\THit{a_2}{bend right}{b_1}{.north east}{b_0}
\path[bounce, bend left=80]
\TBounce{b_1}{out=100,in=140}{b_0}{.north}
;
\end{tikzpicture}
}
\caption{\label{fig:runningPH-1}
A Process Hitting (PH) example.
Sorts are represented by labeled boxes, and processes by circles (ticks are
the identifiers of the processes within the sort, for instance, $a_0$ is the
process ticked $0$ in the box $a$).
An action (for instance $\PHfrappe{b_1}{a_1}{a_2}$) is represented by a pair of
directed arcs, having the hit part ($b_1$ to $a_1$) in plain line and the bounce
part ($a_1$ to $a_2$) in dotted line.
Actions involving $b_1$ or $c_1$ are in thick lines.
%The current state is represented by the grayed processes:
%$\PHstate{a_0,b_1,c_0,d_0}$.
}
\end{figure}

This PH example actually models a BRN where the component $a$ has three qualitative
levels and components $b$ and $c$ are boolean.
In this BRN, $b$ and $c$ activate $a$, while $a$ inhibits $b$.
The inhibition of $b$ by $a$ is only effective when $a$ is at level $2$;
in the other cases, $b$ cannot evolve in any direction.
The activation of $a$ by $b$ ($c$) is encoded by the actions making the level of $a$ increase (resp.
decrease) when $b$ ($c$) is present (resp. absent).
It is worth noticing that the activation of $a$ by $b$ ($c$) is independent from $c$ ($b$).
This may express a lack of knowledge on the cooperation between these two regulators:
we thus model an over-approximation of the possible actions.
\end{example*}
\end{comment}

\subsection{Modeling cooperation}
\towrite{Sortes coopératives avec mise à jour prioritaire (pas de décalage temporel)}
As described in \cite{PMR10-TCSB}, the cooperation between processes to make another bounce can be
expressed in PH by building a \emph{cooperative sort}.
\pref{fig:PH-cooperativity} shows an example of cooperation between processes $b_1$ and $c_1$ to
make $a_1$ bounce to $a_2$:
a cooperative sort $bc$ is defined with 4 processes (one for each sub-state of the presence of
processes $b_1$ and $c_1$).
For the sake of clarity, the $bc$ processes are indexed using the sub-state they represent.
Hence, $bc_{01}$ represents the sub-state $\PHstate{b_0,c_1}$, and so on.
Each process of sort $b$ and $c$ hit $bc$ to make it bounce to the process reflecting the status of the sorts $b$
and $c$ (e.g., $\PHfrappe{b_1}{bc_{00}}{bc_{10}}$ and $\PHfrappe{b_1}{bc_{01}}{bc_{11}}$).
Then, it is the process $bc_{11}$ which hits $a_1$ to make it bounce to $a_2$ instead of the
independent hits from $b_1$ and $c_1$.



\begin{figure}
  \centering
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(0,4)}{b}{2}{l}
    \TSort{(6,2)}{c}{2}{r}

    \TSetTick{ab}{0}{00}
    \TSetTick{ab}{1}{01}
    \TSetTick{ab}{2}{10}
    \TSetTick{ab}{3}{11}
    \TSort{(3,1)}{ab}{4}{l}

    \THit{a_0}{prio}{ab_3}{.west}{ab_1}
    \THit{a_0}{prio}{ab_2}{.west}{ab_0}
    \THit{a_1}{prio}{ab_1}{.west}{ab_3}
    \THit{a_1}{prio}{ab_0}{.west}{ab_2}

    \THit{b_0}{prio}{ab_3}{.west}{ab_2}
    \THit{b_0}{prio}{ab_1}{.west}{ab_0}
    \THit{b_1}{prio}{ab_2}{.west}{ab_3}
    \THit{b_1}{prio}{ab_0}{.west}{ab_1}
    
    \THit{a_1}{selfhit}{a_1}{.west}{a_0}
    \THit{b_1}{selfhit}{b_1}{.west}{b_0}
    \THit{a_0}{bend left}{b_0}{.south west}{b_1}
    \THit{b_0}{bend right=60}{a_0}{.west}{a_1}

    \THit{ab_3}{}{c_0}{.west}{c_1}

    \path[bounce, bend right]
      \TBounce{ab_3}{}{ab_1}{.north west}
      \TBounce{ab_2}{}{ab_0}{.north west}
      \TBounce{ab_3}{}{ab_2}{.north west}
      \TBounce{ab_1}{}{ab_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{ab_1}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_2}{.south west}
      \TBounce{ab_2}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_1}{.south west}
    ;
    \path[bounce, bend right]
      \TBounce{a_1}{}{a_0}{.north west}
      \TBounce{b_1}{}{b_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{a_0}{}{a_1}{.south west}
      \TBounce{b_0}{}{b_1}{.south west}
    ;
    \path[bounce, bend left]
      \TBounce{c_0}{}{c_1}{.south west}
    ;
  \end{tikzpicture}
  \label{fig:ph-livelock}
  \caption{An example of PH model with three well-formed components ($a$, $b$ and $c$) and a well-formed cooperative sort ($ab$).}
\end{figure}



\begin{comment}
\begin{figure}[p]
\centering
\scalebox{1.3}{
\begin{tikzpicture}
\TSort{(0,0)}{b}{2}{t}
\TSort{(0,-3.8)}{c}{2}{b}
\TSort{(4.5,-3)}{a}{3}{r}

\TSetTick{bc}{0}{00}
\TSetTick{bc}{1}{01}
\TSetTick{bc}{2}{10}
\TSetTick{bc}{3}{11}
% \TSetSortLbcel{bc}{$\neg a\wedge b$}
\TSort{(-0.5,-2)}{bc}{4}{b}

\THit{b_1}{very thick,bend right}{bc_0}{.north}{bc_2}
\THit{b_1}{very thick,bend right}{bc_1}{.north}{bc_3}
\THit{b_0}{}{bc_2}{.north west}{bc_0}
\THit{b_0}{}{bc_3}{.north west}{bc_1}

\THit{c_0}{}{bc_1}{.south}{bc_0}
\THit{c_0}{}{bc_3}{.south}{bc_2}
\THit{c_1}{very thick}{bc_0}{.south}{bc_1}
\THit{c_1}{very thick}{bc_2}{.south}{bc_3}

\path[bounce, bend right=25]
\TBounce{bc_2}{}{bc_0}{.north east}
\TBounce{bc_3}{}{bc_1}{.north east}
;
\path[bounce, bend left=80, distance=30]
\TBounce{bc_0}{very thick}{bc_2}{.north}
\TBounce{bc_1}{very thick}{bc_3}{.north}
;
\path[bounce, bend right]
\TBounce{bc_0}{very thick}{bc_1}{.west}
\TBounce{bc_2}{very thick}{bc_3}{.west}
;
\path[bounce, bend left]
\TBounce{bc_3}{}{bc_2}{.east}
\TBounce{bc_1}{}{bc_0}{.east}
;

\THit{bc_3}{}{a_1}{.west}{a_2}
\path[bounce, bend left=40]
\TBounce{a_1}{}{a_2}{.south west}
;

\end{tikzpicture}
}

\caption{\label{fig:PH-cooperativity}
\towrite{Ajouter priorités}
A PH modeling a cooperativity between $b_1$ and $c_1$ to make
$a_1$ bounce to $a_2$.
Actions involving $b_1$ or $c_1$ are in thick lines.
}
\end{figure}
\end{comment}



\begin{comment}
\begin{figure}
  \centering
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(2,0)}{b}{2}{r}
    \TSort{(4,0)}{c}{2}{r}

    \THit{a_1}{prio}{b_1}{.west}{b_0}
    \THit{b_1}{}{c_0}{.north west}{c_1}

    \path[bounce, bend right]
    \TBounce{b_1}{}{b_0}{.north west}
    ;
    \path[bounce, bend left]
    \TBounce{c_0}{}{c_1}{.south west}
    ;
  \end{tikzpicture}
  \label{fig:ph-conca}
  \caption{A simple PH example depicting “backward concurrency” between two actions belonging to different classes of priorities.}
\end{figure}



\begin{figure}
  \centering
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(2,0)}{b}{2}{r}
    \TSort{(4,0)}{c}{3}{r}

    \THit{a_1}{}{b_0}{.west}{b_1}
    \THit{b_0}{prio}{c_1}{.south west}{c_0}
    \THit{b_1}{prio}{c_1}{.west}{c_2}

    \path[bounce, bend left]
    \TBounce{b_0}{}{b_1}{.south west}
    \TBounce{c_1}{}{c_2}{.south west}
    ;
    \path[bounce, bend right]
    \TBounce{c_1}{}{c_0}{.north west}
    ;
  \end{tikzpicture}
  \label{fig:ph-concb}
  \caption{A simple PH example depicting “forward concurrency” between two actions belonging to different classes of priorities.}
\end{figure}
\end{comment}



\begin{comment}
\begin{figure}[p]
\centering
\scalebox{1.3}{
\begin{tikzpicture}
\path[use as bounding box] (-4,-1.9) rectangle (4.5,3.9);
%
\TSort{(0,0)}{a}{3}{l}
\TSort{(3, 3)}{b}{2}{t}
\TSort{(3,-1)}{c}{2}{b}
%
\TSetTick{bc}{0}{00}
\TSetTick{bc}{1}{01}
\TSetTick{bc}{2}{10}
\TSetTick{bc}{3}{11}
% \TSetSortLbcel{bc}{$\neg a\wedge b$}
\TSort{(-3,-0.5)}{bc}{4}{l}
%
\THit{bc_3}{}{a_1}{.north west}{a_2}
\THit{bc_0}{}{a_1}{.south west}{a_0}
\path[bounce]
\TBounce{a_1}{bend left}{a_2}{.south west}
\TBounce{a_1}{bend right}{a_0}{.north west}
;
%
\THit{b_0}{}{a_2}{.east}{a_1}
\THit{b_1}{}{a_0}{.north east}{a_1}
\path[bounce]
\TBounce{a_2}{bend left}{a_1}{.north east}
\TBounce{a_0}{bend right=20}{a_1}{.south}
;
%
\THit{c_0}{bend right}{a_2}{.south east}{a_1}
\THit{c_1}{bend right}{a_0}{.east}{a_1}
\path[bounce]
\TBounce{a_2}{bend left=20}{a_1}{.north}
\TBounce{a_0}{bend right=30}{a_1}{.south east}
;
%
\path[dashed,hit]
	(2,-1.3) edge[bend left=10] (-2.3,-0.7)
	(2.2, 3.3) edge[bend right=10] (-2.3,3)
;
%
\THit{a_2}{bend left,out=40,in=80}{b_1}{.north west}{b_0}
\path[bounce, bend right]
\TBounce{b_1}{}{b_0}{.east}
;
%
\end{tikzpicture}
}
%
\caption{\label{fig:runningPH-2}
PH resulting from the refinement of the one in \pref{fig:runningPH-1} by the
specification of several cooperations.
The actions from $b$ and $c$ to the cooperative sort $bc$ are identical to those defined in
\pref{fig:PH-cooperativity} and are represented here by a single dashed arc.
}
\end{figure}
\end{comment}

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.

When the number of cooperating processes is large, it is possible to chain several cooperative sorts
to prevent the combinatoric explosion of the number of processes created within cooperative sorts.
For instance, if $b_1$, $c_1$, and $d_1$ cooperate, one can create a cooperative sort $bc$ with 4
processes reflecting the presence of $b_1$ and $c_1$, and a cooperative sort $bcd$ with 4 processes
reflecting the presence of $bc_{11}$ and $d_1$.  Such constructions are helpful in PH
as the static analysis of dynamics developed in \cite{PMR12-MSCS} does not suffer from the number of
sorts, but on the number of processes within a single sort.

The construction of cooperation in PH allows to encode any boolean functions between cooperating processes \cite{PMR10-TCSB}.
Due to the presence of priorities, it is possible to build cooperations with no temporal shift by defining the actions on the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in boolean networks.
\towrite{Traduction BN depuis thèse.}

\begin{example}
The PH in \pref{fig:runningPH-2} results from the refinement of the PH in \pref{fig:runningPH-1}
where several cooperations have been specified.
In particular, the bounce to $a_2$ is the result of a cooperation between $b_1$ and $c_1$; and the
bounce to $a_0$ of a cooperation between $b_0$ and $c_0$.
Hence, this PH expresses a BRN where $a$ requires both $b$ and $c$ active to reach its
highest level, and $a$ does not become inactive unless both $b$ and $c$ are inactive.
\end{example}

\subsection{Hypothesis} \towrite{Reformuler}
\label{ssec:hypothesis}

%In this section, we describe several restrictions.
%Although the definition of a Process Hitting with $k$ priorities allows a wide range of models, the method given in the next section only applies to Process Hitting models that regard these restrictions.

\begin{comment}
We define the set of chains of actions $\PHh^n(b, a)$ between two sorts $b$ and $a$, with $n \in \segm{1}{k}$, as below:
\begin{align*}
\PHh^n(b, a) = \{ (h_i)_{i \in \segm{0}{s}} \in (\restriction{\PHh}{n})^{s+1} &\mid s \in \sN, \PHsort(\PHhitter(h_0)) = b \wedge \PHsort(\PHtarget(h_s)) = a \\
  & \wedge \forall i \in \segm{1}{s}, \PHsort(\PHtarget(h_{i-1})) = \PHsort(\PHhitter(h_{i})) \}
\end{align*}

We define the neighbor \towrite{Revoir terminologie : “neighborhood” ? “vicinity” ?} sorts of any sort $a$ and $n \in \segm{1}{k}$ as :
$$
\Vs^n(a) = \{ b \in \PHs \mid \PHh^m(b, a) \neq \emptyset \wedge m = \min(n, \prio(a)) \} \cup \{ a \}
$$

And, as a shortcut:
$$
\Vs(a) = \Vs^{\prio(a)}(a)
$$

We define the neighbor actions of any sort $a$ as :
$$
\Vh(a) = \{ h \in \restriction{\PHh}{\prio(a)} \mid \{ \PHsort(\PHhitter(h)), \PHsort(\PHtarget(h)) \} \subset \Vs(a) \wedge \prio(h) \leq \prio(a) \}
$$
\end{comment}

%\paragraph{Cycle-freeness of $\restriction{\PH}{k-1}$}
%\towrite{Définition formelle ? + justification}
%The model $\restriction{\PH}{k-1}$ contains no cycles. Cycles are still allowed in $\PH$ however.

In the scope of this paper, we focus on a specific class of Process Hitting models.
We define here the restrictions that lead to this class of models \todo{and show that they are equivalent to discrete networks}.
%Let $\PH$ be a PH model on which we want to apply the static analysis.
%In this paper, we focus on a specific class of models that are equivalent to boolean networks.

\paragraph{2 priorities}
In this paper, we only consider Process Hitting models with 2 priorities.

This restriction allows to models two kinds of actions: controllable actions that model the non-determinacy of biological evolutions,
and uncontrollable actions that are used to model non-biological behaviours in the model.

In \pref{def:component} we define the notion of well-formed component.
A sort $a$ is a well-formed component iff
it is hit only by actions of priority $2$.
\begin{definition}
\label{def:component}
  A sort $a \in \PHs$ is said to be a well-formed component iff:
  \begin{itemize}
    \item $\forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) = 2$
  \end{itemize}
\end{definition}
We call $\components$ the set of well-formed components.

\begin{definition}
\label{def:chainsactions}
  We define the set of chains of actions $\PHh(b, a)$ between two sorts $b$ and $a$ as below:
  \begin{align*}
  \PHh(b, a) = \{ (h_i)_{i \in \segm{0}{s}} \in (\PHh^{(1)})^{s+1} &\mid s \in \sN, \PHsort(\PHhitter(h_0)) = b \wedge \PHsort(\PHtarget(h_s)) = a \\
    & \wedge \forall i \in \segm{1}{s}, \PHsort(\PHtarget(h_{i-1})) = \PHsort(\PHhitter(h_{i})) \}
  \end{align*}
\end{definition}

\paragraph{Cycle-freeness between actions of priority $1$}
There is no cycle in chains of actions: $\forall a \in \PHs, \PHh(a, a) = \emptyset$.

Given this first hypothesis, we define the neighbor \towrite{revoir terminologie : neighbors ? vicinity ?} sorts and actions (\pref{def:neighbors}).
\begin{definition}
\label{def:neighbors}
  The set of neighbour sorts $\Vs(a)$ of a given sort $a$ is the set of components that can interact with it through actions of priority $1$.
  The set of neighbour actions $\Vh(a)$ of $a$ is the set of actions of priority $1$ influencing $a$.
  $$\Vs(a) = \{ b \in \components \mid \PHh(b, a) \neq \emptyset \}$$
  $$\Vh(a) = \{ h \in \PHh^{(1)} \mid \PHsort(\PHhitter(h)) \in \Vs(a) \wedge \PHsort(\PHtarget(h)) \in \Vs(a) \cup \{ a \} \}$$
\end{definition}

We denote $\pfp_s(a)$ the set of possible local steady-states of a sort $a$ from a state $s$.
\todo{À corriger : état global ?}
\begin{align*}
  \pfp_s(a) = \{ a_i \in \PHl_a &\mid \exists \delta \in \restriction{\Sce}{1}, \PHget{(s \PHplay \delta)}{a} = a_i \\
  & \quad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \Vh(a), \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
\end{align*}
Of course, if $a \in \components$, then $\pfp_s(a) = \PHget{s}{a}$.

In \pref{def:cs} we define the notion of well-formed cooperative sort.
A cooperative sort $a$ is well-formed iff
it is hit only by actions of priority $1$,
any sub-state of its neighbourhood is represented by exactly one local steady state in this sort,
and all of its processes represents at least one sub-state of its neighbourhood.
\begin{definition}
\label{def:cs}
  A sort $a \in \PHs$ is said to be a well-formed cooperative sort iff:
  \begin{itemize}
    \item $\forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) = 1$
    \item $\forall s \in \underset{b \in \Vs(a)}{\times} \PHl_b, |\pfp_s(a)| = 1$
    \item $\forall a_i \in \PHl_a, \exists s \in \underset{b \in \Vs(a)}{\times} \PHl_b, \pfp_s(a) = \{ a_i \}$
  \end{itemize}
\end{definition}
We call $\cs$ the set of well-formed cooperative sorts.
%We note that: $\forall a \in \components, \Vs(a) = \emptyset \wedge \Vh(a) = \emptyset$
As any local state of neighbour sorts of a cooperative sort leads to a local steady-state, we denote $\csState(a_i)$ the set of sub-states represented by the process $a_i$ of the cooperative sort $a$.
\begin{definition}[$\csState$]
\label{def:csState}
  \towrite{À reformuler}
  $$\csState(a_i) = \{ s \in \underset{b \in \Vs(a)}{\times} \PHl_b \mid \pfp_{s}(a) = a_i \}$$
\end{definition}

\paragraph{Components \& cooperative sorts}
The studied PH is a PH with 2 priorities, and it is only composed of well-formed components and cooperative sorts:
$\components \cup \cs = \PHs \wedge \components \cap \cs = \emptyset$

\paragraph{Bounded termination}
The dynamics of model $\restriction{\PH}{1}$ contains no cycles. Cycles are still allowed in $\PH$ however.
Formally : $\exists N \in \sN, \forall \delta \in \restriction{\Sce}{1}, |\indexes{\delta}| \leq N$.



\begin{comment}
\paragraph{Bounded termination}
The dynamics of model $\restriction{\PH}{k-1}$ contains no cycles. Cycles are still allowed in $\PH$ however.
Formally : $\exists N \in \sN, \forall \delta \in \restriction{\Sce}{k-1}, |\indexes{\delta}| \leq N$.

\paragraph{Local priorities}
\towrite{Justification}
All actions hitting the same sort belong to the same class of priority:
$$\forall h_1, h_2 \in \PHh, \PHtarget(h_1) = \PHtarget(h_2) \Rightarrow \prio(h_1) = \prio(h_2)$$
Furthermore, for all sort $a$, we denote $\prio(a)$ the priority of the actions hitting $a$, if any:
$$\forall a \in \PHs, \exists h \in \PHh, \PHtarget(h) = a \Rightarrow \prio(a) = \prio(h)$$
\towrite{Ou : $\nexists h \Rightarrow \prio(a) = 0$}

\paragraph{Local stable states}
\towrite{Justification}
We define $\pfp$ as the set of possible stable states of a sort from a given state:
\begin{align*}
  \pfp_\ctx = \{ s \PHplay \delta \in \PHl &\mid s \in \ctx \wedge \delta \in \restriction{\Sce}{k-1} \\
  & \qquad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \restriction{\PHh}{k-1}, \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
  %\text{$h$ n'est pas jouable dans $s \PHplay \delta$} \}
\end{align*}

All processes are a stable state of a sub-state of the predecessors:
$\forall a_i \in \PHproc, \prio(a) < k \Rightarrow \exists s \in \restriction{\PHl}{\Vs(a)}, a_i \in \pfp_s$.
We note: $\stable_{a_i} = \{ s \in \restriction{\PHl}{\Vs(a)} \mid a_i \in \pfp_s \}$.
\end{comment}

\begin{comment}
These restrictions bring new interesting properties to the PH models regarding them.

\pref{th:vplay} tells that for any action $h = \PHhit{a_i}{b_j}{b_k}$, if no action can be played in the neighborhood of $a$ in a given state, then $h$ can be played after a series of hits that do not prevent it to be fired. Furthermore, if the requisites of \pref{th:vplay} are true, then no action of this series of hits belongs to $V(a)$, as stated in \pref{co:vplay}.
\begin{theorem}
\label{th:vplay}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, (\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge $\\
  $\forall h' \in \Vh^{\prio(b)-1}(a), \PHhitter(h') \notin s \wedge \PHtarget(h') \notin s) \Rightarrow$\\
  $(\exists \delta \in \Sce, \text{$h$ can be played in $s \PHplay \delta$})$
\end{theorem}

\begin{proof}
  Because of the cycle-freeness of $\restriction{\PH}{k-1}$, $\restriction{\PH}{\prio(a)}$ is also cycle-free and there is a $\delta \in \Sce$ so that $\forall h' \in \PHh$, $h'$ cannot be played in $s \PHplay \delta$. Furthermore, $\forall h' \in \delta, \PHsort(\PHtarget(h')) \neq a$ by construction of $\Vs(a)$.
\end{proof}

\begin{corollary}
  \label{co:vplay}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, (\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge $\\
  $\forall h' \in \Vh^{\prio(b)-1}(a), \PHhitter(h') \notin s \wedge \PHtarget(h') \notin s) \Rightarrow$\\
  $\exists \delta \in \Sce, (\forall n \in \indexes{\delta}, \delta_n \notin \Vh(a)) \wedge (\text{$h$ can be played in $s \PHplay \delta$})$
\end{corollary}



\pref{th:totalss} states that from any state, a steady state is eventually reached. A local variant of this theorem, given in \pref{co:totalss}, can be derived,
where, for all $\Omega \subset \PHs$, $$\restriction{\PHl}{\Omega} = \underset{a \in \Omega}{\times} \PHl_a$$ and
for all $H \subset \PHh$, $$\restriction{\Sce}{H} = \{ \delta \in \Sce \mid \forall n \in \indexes{\delta}, \delta_n \in H \} \enspace .$$
\begin{theorem}
\label{th:totalss}
  $\forall n \in \segm{1}{k-1}, \forall s \in \PHl, \exists \delta \in \restriction{\Sce}{n}$, no action of model $\restriction{\PH}{n}$ can be played in $s \PHplay \delta$.
\end{theorem}

\begin{corollary}
\label{co:totalss}
  $\forall a \in \PHs, \forall s \in \restriction{\PHl}{\Vs(a)}, \exists \delta \in \restriction{\Sce}{\Vh(a)}$, no action of $\Vh(a)$ can be played in $s \PHplay \delta$.
\end{corollary}



\pref{th:autohits} states that any sequence $\zeta$ of self-actions can be played eventually.
\begin{theorem}
\label{th:autohits}
  Let $a \in \PHs$, $s \in \PHl$ and $\zeta \in \BS(a)$, with $n = |\indexes{\zeta}|$ so that $\forall i \in \segm{1}{n}, \PHsort(\PHhitter(\zeta_i)) = a$.
  %If no action can be played in $V(a)$ in state $s$, then
  $\exists (\delta_i)_{i \in \segm{1}{n}} \in \Sce$ so that $\forall i \in \segm{1}{n}$, $\zeta_i$ can be played in $s \PHplay \delta_1 \PHplay \zeta_1 \PHplay \dots \PHplay \delta_i$. 
\end{theorem}

\begin{proof}
  With \pref{co:vplay} applied iteratively.
\end{proof}

\towrite{Théorème nécessaire pour la suite: une séquence d'actions dans $\BS(a)$ peut être jouée si précédée ou entrelacée par des $\zeta$ (?)}
\end{comment}

\subsection{Consequences of the restrictions}
Given these hypotheses, we can denote: $\pfp_s(a) = a_i$ the local steady-state of $a$ in state $s$.
Furthermore, we denote by $\update(s)$ the state in which all cooperative sorts are updated.
\begin{align*}
  \update(s) = s \underset{a \in CS}{\Cap } \pfp_{s}(a)
\end{align*}
where for all process $a_i$, $s \Cap a_i$ is the state defined by:
$\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.

\pref{th:update} states that from any state, there exists a scenario updating the cooperative sorts of this state.
\begin{theorem}
\label{th:update}
  $\forall s \in \PHl, \exists \delta \in \restriction{\Sce}{1}, s \PHplay \delta = \update(s)$
\end{theorem}
\begin{proof}
  Let $a$ be a cooperative sort so that $\PHget{s}{a} \neq \pfp_s(a)$.
  Given the definition of $\pfp_s(a)$, there exists a scenario updating $a$ in $s$.
  As there is no cycle in between the cooperative sorts and an updated cooperative sort cannot evolve, at most $|\cs|$ updates can be done.
\end{proof}
\pref{th:hcompcomp} states that for a given state $s$ and for any action $h = \PHhit{a_i}{b_j}{b_k}$ between well-formed components, $h$ can be played after a series of hits that do not prevent it to be fired.
\pref{th:hcscomp} states the same if $a$ is a well-formed cooperative sort, under the condition that $a_i$ reflects the state of the neighborhood of $a$.
\begin{theorem}
\label{th:hcompcomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a,b \in \components,$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}, \text{$h$ can be played in $s \PHplay \delta$})$
\end{theorem}
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ so that: $(s \PHplay \delta) = \update(s)$.
  As $a,b \in \components$, $a_i \in s \PHplay \delta$ and $b_j \in s \PHplay \delta$.
  Finally, by definition of $\update(s)$, no action of priority $1$ can be played in $s \PHplay \delta$, thus $h$ can be played in $s \PHplay \delta$.
\end{proof}
\begin{theorem}
\label{th:hcscomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a \in \cs, b \in \components$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge \pfp_s(a) = a_i) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}, \text{$h$ can be played in $s \PHplay \delta$})$
\end{theorem}
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ so that: $(s \PHplay \delta) = \update(s)$.
  As $a_i \in \pfp_s(a)$, $a_i \in s \PHplay \delta$.
  Furthermore, $b \in \components$, thus $b_j \in s \PHplay \delta$.
  Finally, by definition of $\update(s)$, no action of priority $1$ can be played in $s \PHplay \delta$, thus $h$ can be played in $s \PHplay \delta$.
\end{proof}

\pref{th:autohits} states that any sequence $\zeta$ of self-actions on a well-formed component can be played eventually.
\begin{theorem}
\label{th:autohits}
  Let $a \in \PHs$, $s \in \PHl$ and $\zeta \in \BS$ so that $\forall i \in \indexes{\zeta}, \PHsort(\PHhitter(\zeta_i)) = \PHsort(\PHtarget(\zeta_i)) = a$.
  $\exists (\delta_i)_{i \in \indexes{\zeta}} \in \restriction{\Sce}{1}$ so that $\forall i \in \indexes{\zeta}$, $\zeta_i$ can be played in $s \PHplay \delta_1 \PHplay \zeta_1 \PHplay \dots \PHplay \delta_i$. 
\end{theorem}
\begin{proof}
  With \pref{th:hcompcomp} applied iteratively.
\end{proof}

