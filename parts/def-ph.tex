\section{Asynchronous Automata Networks}
\label{sec:ph}

We give in this section the definition and the semantics of the Asynchronous Automata Networks (AANs).
It is a restriction of the classical (synchronous) Automata Networks
where each set of transitions sharing the same label
can only change one local state at a time.
We also discuss how it is related to the Process Hitting framework
(with or without classes of priorities).
Another definition of AANs introducing classes of priorities
is proposed in \pref{sec:flattening},
where we also show that they have the same expressivity as AANs.

\medskip



\modn{
We consider an AAN (\pref{def:ph})
which gathers a finite number of \emph{automata},
each one containing a finite number of \emph{local states}.
A local state is noted $a_i$ where $a$ is the name of the automaton it belongs to,
and $i$ is the identifier of this local state within automaton $a$.
A \emph{global state} of the system is the gathering
of exactly one local state from each automata.
}

\modn{
The concurrent interactions between local states are defined by a set of \emph{actions}.
An action stands for a set of transitions sharing the same label,
so that playing them changes exactly one local state.
Therefore, an action is denoted by $\PHhit{A}{b_j}{b_k}$
where $A$ is a set of local states
and $b_j$ and $b_k$ are local states of a same automaton $b$,
and it is required that $b_j \neq b_k$ and that
$A$ does not contain a local state of $b$ or two local states of the same automaton.
An action $h=\PHfrappe{A}{b_j}{b_k}$ is read as
``$A$ \emph{hit} $b_j$ to make it bounce to $b_k$'',
and $A$, $b_j$, $b_k$ are called respectively the set of
\emph{hitters}, the \emph{target} and the \emph{bounce} of the action,
and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.
}

\begin{definition}[Asynchronous Automata Networks]
\label{def:ph}
  An \emph{Asynchronous Automata Network} (AAN) is a triplet $\PH = (\PHs; \PHl; \PHa)$,
  where:
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots, z\}$ is the finite set of \emph{automata};
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ is the finite set of
      (global) \emph{states},
      where $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ is the finite set of \emph{local states}
      of automaton $a \in \PHs$, with $l_a \in \sN^*$,
      and so that:
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$;
    \item $\PHa \DEF \{\PHfrappe{A}{b_j}{b_k} \mid
      b \in \PHs \wedge (b_j; b_k) \in \PHl_b \times \PHl_b \wedge
      b_j \neq b_k \wedge
      \forall a \in \PHs, \card{A \cap \PHl_a} \leq 1 \wedge
      A \cap \PHl_b = \emptyset \}$ is the finite set of \emph{actions}.
  \end{itemize}
  Furthermore,
  we call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all local states in the model.
\end{definition}
%
\noindent
The automaton that a local state $a_i$ belongs to is referred to as $\PHsort(a_i) = a$.
Given a state $s\in \PHl$, the local state of automaton $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is, the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
\pref{def:substate} defines the notion of sub-state on a set of automata, that is used to focus on the interesting part of a complete state.
We note that a state is \textit{a fortiori} a sub-state.
The override of a state $s$ by a local state $a_i$ (or by a set of local states)
is defined in \pref{def:statecap} as the same state in which the local state of automaton $a$ has been replaced by $a_i$;
this is used to define the semantics of an AAN in \pref{def:play}.
%
\begin{definition}[Sub-states ($\PHsublize{\PHl}$)]
\label{def:substate}
  If $S \subseteq \PHs$ is a set of automata, a sub-state on $S$ is an element of:
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  The set of all sub-states is:
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  Furthermore, if $\mysigma \in \PHsubl[\PHl]$ and $s \in \PHl$, we note:
    \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \toset{\mysigma} \Rightarrow a_i \in s\]
  where the notation $\toset{\mysigma}$ represents
  the set of components of the Cartesian product $\mysigma$,
  as defined on page~\pageref{notations}.
\end{definition}

In the following, we will also use the notation:
$\PHsublset[\PHl] = \{ \toset{ps} \subseteq \Proc \mid ps \in \PHsubl[\PHl] \}$
and, by extension:
$\forall s \in \PHl, \forall ps \in \PHsublset[\PHl],
  ps \subseteq s \EQDEF \forall a_i \in ps, a_i \in s$.
We note also that for all action $h \in \PHh$, by definition of an AAN, we have:
$\hitter{h} \in \PHsublset[\PHl]$.

\begin{definition}[$\Cap : \PHl \times \PHproc \rightarrow \PHl$]
\label{def:statecap}
  Given a state $s \in \PHl$ and a local state $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We can also extend this definition to a set $ps$ of local states,
  under the condition that all local states of $ps$ are from different automata,
  by the override of each local state independently:
  $\forall ps \in \PHsublset[\PHl], s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
% The notation $\toset{ps}$ represents the set of all elements in $ps$
% (which is not a set but a tuple)
% as defined on page~\pageref{notations}.

\begin{definition}[Semantics of an AAN ($\PHPtrans$)]
\label{def:play}
  An action $h = \PHhit{A}{b_j}{b_k} \in \PHa$ is \emph{playable} in $s \in \PHl$
  if and only if $A \subseteq s$ and $\PHget{s}{b} = b_j$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$, which is defined by: $(s \PHplay h) = s \Cap b_k$.
  Moreover, we denote: $s \PHPtrans (s \PHplay h)$.

  If $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a (possibly empty) sequence of actions of $\PHh$
  that can be played successively in $s$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
\end{definition}



\begin{example}
  \pref{fig:ph-livelock} gives an example of AAN where:
  \begin{align*}
    \PHs &= \{ a, b, c \} \enspace,
      & \PHl_a &= \{ a_0, a_1 \} \enspace, \\
    \PHl_b &= \{ b_0, b_1 \} \enspace,
      & \PHl_c &= \{ c_0, c_1 \} \enspace, \\
    \PHh = \{ \quad
      & \PHfrappem{a_1}{a_0} \enspace , \quad
        \PHfrappem{a_0}{a_1} \enspace , \\
      & \PHfrappem{b_1}{b_0} \enspace , \quad
        \PHfrappem{b_0}{b_1} \enspace , \\
      & \PHfrappes{a_1, b_1}{c_0}{c_1} \enspace \quad \qquad \qquad
      \quad \}
  \end{align*}

\begin{figure}[tb]
  \centering
  \scalebox{1.3}{
  \begin{tikzpicture}[aan]
%    \path[use as bounding box] (-.2,-.5) rectangle (7.2,5.7);
    \TSort{(0,3)}{a}{2}{b}
    \TSort{(0,0)}{b}{2}{t}
    \TSort{(4,1)}{c}{2}{r}
    
    \TAction{a_0.south west}{b_0.north west}{b_1.north west}{bend right=20}{left}
    \TAction{b_0.north east}{a_0.south east}{a_1.south west}{bend right=20}{right}
    \TActionPlur{}{a_1.north}{a_0.north east}{}{1.5,4}{right}
    \TActionPlur{}{b_1.south}{b_0.south east}{}{1.5,-1}{left}
    \TActionPlur{a_1, b_1}{c_0.west}{c_1.south west}{}{2.5,1.5}{left}
    
    \TState{a_1, b_0, c_0}
  \end{tikzpicture}
  }
  \caption{%
  \label{fig:ph-livelock}%
    An example of AAN.
    This model represents the interaction of two exclusive components $a$ and $b$,
    that cannot be active simultaneously, and that degrade over time.
    Moreover, these two components can cooperate to activate $c$
    if their “active” states ($a_1$ and $b_1$)
    are present in the same state.
    Automata are represented by labelled boxes
    and local states by circles with their identifier on the side.
    Actions are represented by a dot connected by an edge to every hitter
    and by an arrows to the target, followed by another dotted arrow towards the bounce.
    Greyed local states stand for the following possible global state:
    $\PHstate{a_1, b_0, c_0, ab_{10}}$.
  }
\end{figure}

\end{example}



\modn{
\begin{remark}[Comparison with the Process Hitting]
  The Process Hitting framework
  previously introduced in~\cite{PMR10-TCSB}
  is a restriction of the AAN formalism;
  indeed, a Process Hitting model is an AAN so that
  $\forall h \in \PHh, 0 \leq \card{\hitter{h}} \leq 1$.
  However, the AANs defined in this paper have the same expressivity than
  the Process Hitting with classes of priorities, as previously
  introduced in~\cite{FPMR13-CS2Bio}.
  Indeed, in the Process Hitting with at least classes of priorities
  it is possible to use additional sorts, called “cooperative sorts”,
  in order to model the actions of any AAN that have more than one hitter.
\end{remark}
}
