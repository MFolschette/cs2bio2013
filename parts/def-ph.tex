\section{Asynchronous Automata Networks}
\label{sec:ph}

We give in this section the definition and the semantics of the Asynchronous Automata Networks (AAN).
It is a restriction of the classical Synchronous Automata Networks
where each set of transitions sharing the same label
can only change one local state at a time.
\todo{We also discuss how it is related to the local state Hitting framework (with priorities)
\cite{PMR10-TCSB,FPMR13-CS2Bio}.}
As shown in \pref{sec:encodings},
this class of models is equivalent to Asynchronous Discrete Networks,
and extending it with classes of priorities does not increase its expressivity.

\subsection{Definition of Asynchronous Automata Networks}
\label{ssec:PH}

An AAN (\pref{def:ph}) gathers a finite number of concurrent \emph{local states} divided into a finite set of \emph{automata}, also called \emph{components}.
A local state belongs to a unique automaton and is noted $a_i$ where $a$ is the name of the automaton and $i$ the identifier of the local state within automaton $a$.
Each local state stands for a kind of “activity level” of its automaton; a \emph{global state} of the AAN thus corresponds to a set of local states containing exactly one local state of each automaton.

The concurrent interactions between local states are defined by a set of \emph{actions}.
Actions describe the replacement of the active local state of an automaton by another of the same automaton, conditioned by the presence of as many other local states in the model.
An action is denoted by $\PHhit{A}{b_j}{b_k}$ where $b_j$ and $b_k$ are local states of an automata $b$, and $A$ is a set of local states.
It is required that $b_j \neq b_k$ and that
$A$ does not contain a local state of $b$ or two local states of the same automaton.
An action $h=\PHfrappe{A}{b_j}{b_k}$ is read as ``$A$ \emph{hit} $b_j$ to make it bounce to $b_k$'', and $A$, $b_j$, $b_k$ are called respectively the set of \emph{hitters}, the \emph{target} and the \emph{bounce} of the action, and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

\begin{definition}[Asynchronous Automata Networks]
\label{def:ph}
  An \emph{Asynchronous Automata Networks} is a triplet $\PH = (\PHs; \PHl; \PHa)$,
  where:
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots, z\}$ is the finite set of \emph{automata};
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ is the finite set of
      (global) \emph{states},
      where $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ is the finite set of \emph{local states}
      of automaton $a \in \PHs$, with $l_a \in \sN^*$,
      and so that:
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$;
    \item $\PHa \DEF \{\PHfrappe{A}{b_j}{b_k} \mid
      b \in \PHs \wedge (b_j; b_k) \in \PHl_b \times \PHl_b \wedge
      b_j \neq b_k \wedge
      \forall a \in \PHs, \card{A \cap \PHl_a} \leq 1 \wedge
      A \cap \PHl_b = \emptyset \}$ is the finite set of \emph{actions}.
  \end{itemize}
  Furthermore,
  we call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all local states in the model.
\end{definition}
%
\noindent
The automaton that a local state $a_i$ belongs to is referred to as $\PHsort(a_i) = a$.
Given a state $s\in \PHl$, the local state of automaton $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is, the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
\pref{def:substate} defines the notion of sub-state on a set of automata, that is used to focus on the interesting part of a complete state.
We note that a state is \textit{a fortiori} a sub-state.
The override of a state $s$ by a local state $a_i$ (or by a set of local states)
is defined in \pref{def:statecap} as the same state in which the local state of automaton $a$ has been replaced by $a_i$;
this is used to define the dynamics of an AAN in \pref{def:play}.
%
\begin{definition}[Sub-states ($\PHsublize{\PHl}$)]
\label{def:substate}
  If $S \subseteq \PHs$ is a set of automata, a sub-state on $S$ is an element of:
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  The set of all sub-states is:
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  Furthermore, if $\mysigma \in \PHsubl[\PHl]$ and $s \in \PHl$, we note:
    \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \toset{\mysigma} \Rightarrow a_i \in s\]
  where the notation $\toset{\mysigma}$ represents
  the set of components of the Cartesian product $\mysigma$,
  as defined on page~\pageref{notations}.
\end{definition}

In the following, we will also use the notation:
$\PHsublset[\PHl] = \{ \toset{ps} \subseteq \Proc \mid ps \in \PHsubl[\PHl] \}$
and, by extension:
$\forall s \in \PHl, \forall ps \in \PHsublset[\PHl],
  ps \subseteq s \EQDEF \forall a_i \in ps, a_i \in s$.
We note also that for all action $h \in \PHh$, by definition of an AAN, we have:
$\hitter{h} \in \PHsublset[\PHl]$.

\begin{definition}[$\Cap : \PHl \times \PHproc \rightarrow \PHl$]
\label{def:statecap}
  Given a state $s \in \PHl$ and a local state $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We can also extend this definition to a set $ps$ of local states,
  under the condition that all local states of $ps$ are from different automata,
  by the override of each local state independently:
  $\forall ps \in \PHsublset[\PHl], s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
% The notation $\toset{ps}$ represents the set of all elements in $ps$
% (which is not a set but a tuple)
% as defined on page~\pageref{notations}.

\begin{definition}[Dynamics of an AAN ($\PHPtrans$)]
\label{def:play}
  An action $h = \PHhit{A}{b_j}{b_k} \in \PHa$ is \emph{playable} in $s \in \PHl$
  if and only if $A \subseteq s$ and $\PHget{s}{b} = b_j$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$, which is defined by: $(s \PHplay h) = s \Cap b_k$.
  Moreover, we denote: $s \PHPtrans (s \PHplay h)$.

  If $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a (possibly empty) sequence of actions of $\PHh$
  that can be played successively in $s$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
\end{definition}



\begin{example}
  \pref{fig:ph-livelock} gives an example of AAN where:
  \begin{align*}
    \PHs &= \{ a, b, c \} \enspace,
      & \PHl_a &= \{ a_0, a_1 \} \enspace, \\
    \PHl_b &= \{ b_0, b_1 \} \enspace,
      & \PHl_c &= \{ c_0, c_1 \} \enspace, \\
    \PHh = \{ \quad
      & \PHfrappem{a_1}{a_0} \enspace , \quad
        \PHfrappem{a_0}{a_1} \enspace , \\
      & \PHfrappem{b_1}{b_0} \enspace , \quad
        \PHfrappem{b_0}{b_1} \enspace , \\
      & \PHfrappes{a_1, b_1}{c_0}{c_1} \enspace \quad \qquad \qquad
      \quad \}
  \end{align*}

\begin{figure}[tb]
  \centering
  \scalebox{1.3}{
  \begin{tikzpicture}[aan]
%    \path[use as bounding box] (-.2,-.5) rectangle (7.2,5.7);
    \TSort{(0,3)}{a}{2}{b}
    \TSort{(0,0)}{b}{2}{t}
    \TSort{(4,1)}{c}{2}{r}
    
    \TAction{a_0.south west}{b_0.north west}{b_1.north west}{bend right=20}{left}
    \TAction{b_0.north east}{a_0.south east}{a_1.south west}{bend right=20}{right}
    \TActionPlur{}{a_1.north}{a_0.north east}{}{1.5,4}{right}
    \TActionPlur{}{b_1.south}{b_0.south east}{}{1.5,-1}{left}
    \TActionPlur{a_1, b_1}{c_0.west}{c_1.south west}{}{2.5,1.5}{left}
    
    \TState{a_1, b_0, c_0}
  \end{tikzpicture}
  }
  \caption{%
  \label{fig:ph-livelock}%
    An example of AAN.
    This model represents the interaction of two exclusive components $a$ and $b$,
    that cannot be active simultaneously, and that degrade over time.
    Furthermore, these two components can cooperate to activate $c$
    if their “active” states ($a_1$ and $b_1$)
    are present in the same state.
    Automata are represented by labelled boxes
    and local states by circles with their identifier on the side.
    Actions are represented by a dot connected by an edge to every hitter
    and by an arrows to the target, followed by another dotted arrow towards the bounce.
    Greyed local states stand for the following possible global state:
    $\PHstate{a_1, b_0, c_0, ab_{10}}$.
  }
\end{figure}

\end{example}



\subsection{Modelling cooperation}
\label{ssec:cooperation}

Cooperations between components are a very common in biological systems.
They represent the fact that a given regulation is not conditioned by only one condition,
such as the presence of a given concentration of one substance,
represented in the model by the activity of the one related local state.
Instead, in the case of a cooperation, two conditions or have to be bet.
For example, in the example of \pref{fig:ph-livelock},
the activation of component $c$ requires the cooperation of $a$ and $b$;
in practice, this is expressed by a set of two hitters for action
$\PHfrappes{a_1, b_1}{c_0}{c_1}$.

Such a cooperation can be represented in Process Hitting by using a \emph{cooperative sort},
whose aim is to represent a Boolean formula~\cite{PMR10-TCSB}.
The different local states of a cooperative sort represent the possible configurations
of a set of automata,
and actions allow to update the active local state of the cooperative sort
in order to have it match the configuration of these automata.
Then, one or several actions can be added from the desired local states of the cooperative sort
in order to abstract multiple requirements.
Cooperative sorts have the advantage to not require any supplementary semantics
than those of standard Process Hitting,
but at the cost of slightly over-approximating the expected dynamics of a true Boolean gate.
Indeed, nothing forces these actions to be played as soon as possible,
thus resulting in a possible temporal shift between the evolution
of the active process of the cooperative sorts and those of the automata it represents.
In other words, a cooperative sorts does not necessarily represent the configuration
of a given set of automata, but only a combination of past states.

In~\cite{FPMR13-CS2Bio}, the formalization of classes of priorities into the Process Hitting
was proposed in order to add some missing features,
such as the possibility to abstract time properties of regulation or reaction rates.
Another consequence of the addition of priorities was the possibility to fix
the aforementioned temporal shift, and thus be able to model accurate Boolean gates,
by prioritizing the actions used to update the cooperative sorts.
The AAN formalism proposed in this paper have in fact the same expressivity than
Process Hitting with classes of priorities.
Indeed, the actions with multiple hitters play the role of cooperative sorts,
and the classes of priorities can be encoded into AAN without priorities,
as detailed in \pref{ssec:flattening}.
