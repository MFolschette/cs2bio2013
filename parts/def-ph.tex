\section{The Process Hitting framework}

\towrite{Transition.}

\subsection{Definition of the Process Hitting with $k$ priorities}
\label{ssec:PH}
\towrite{Reformuler (actuellement trop proche de CMSB)}
A PH (\pref{def:ph}) gathers a finite number of concurrent \emph{processes} grouped into a finite set of \emph{sorts}.
A process belongs to a unique sort and is noted $a_i$ where $a$ is the sort and $i$ the identifier of the process within the sort $a$.
At any time, one and only one process of each sort is present; a state of the PH thus corresponds to the set of such processes.

The concurrent interactions between processes are defined by a set of \emph{actions} divided into classes of priorities.
Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process and by the fact that no other action of higher priority is playable in the current state of the PH.
An action is denoted by $\PHhit{a_i}{b_j}{b_k}$ where $a_i,b_j,b_k$ are processes of sorts $a$ and $b$.
It is required that $b_j \neq b_k$ and that $a=b\Rightarrow a_i=b_j$.
An action $h=\PHfrappe{a_i}{b_j}{b_k}$ is read as ``$a_i$ \emph{hits} $b_j$ to make it bounce to $b_k$'', and $a_i,b_j,b_k$ are called respectively \emph{hitter}, \emph{target} and \emph{bounce} of the action, and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

\begin{definition}[Process Hitting with $k$ priorities] \towrite{Revoir terminologie}
\label{def:ph}
  A \emph{Process Hitting with $k$ priorities}, where $k \in \sN^*$, is a triplet $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$, with $\PHa^{\langle k \rangle} = (\PHa^{(1)}; \dots; \PHa^{(k)})$ a $k$-uplet, where:
  \begin{itemize}
    \item $\PHs \DEF \{a,b,\dots\}$ is the finite set of \emph{sorts}.
    \item $\PHl \DEF \prod_{a \in \PHs} \PHl_a$ is the finite set of states, where $\PHl_a = \{a_0 ; \ldots ; a_{l_a}\}$ is the finite set of \emph{processes} of sort $a \in \PHs$ and $l_a \in \sN^*$. Each process belongs to a unique sort: $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$.
    \item $\forall n \in \llbracket 1; k \rrbracket, \PHa^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_k} \mid (a; b) \in \PHs^2 \wedge (a_i; b_j; b_k) \in \PHl_a \times \PHl_b \times \PHl_b \wedge b_j \neq b_k \wedge a = b \Rightarrow a_i = b_j \}$ is the finite set of \emph{actions of priority $n$}.
  \end{itemize}
  We call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all processes, and $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ the set of all actions.
\end{definition}

\noindent
The sort of a process $a_i$ is referred to as $\PHsort(a_i) = a$.
%and the set of sorts present in an action $h \in \PHa$ as $\PHsort(h) = \{\PHsort(\PHhitter(h)),\PHsort(\PHtarget(h))\}$.
Given a state $s\in \PHl$, the process of sort $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
We define the override of a state by a process in \pref{def:statecap}, which allows to define the dynamics in a Process Hitting model (\pref{def:play}).
\begin{definition}
\label{def:statecap}
  Given a state $s \in \PHl$ and a process $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We also extend this definition to a set of processes $ps$ given that all processes are from different sorts by the override of each process:
  $\forall as \subset \PHs, \forall ps \in \underset{a \in as}{\times} \PHl_a, s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
\begin{definition}
\label{def:play}
  An action $h = \PHhit{a_i}{b_j}{b_k} \in \PHa^{(n)}$ of priority $n$ is \emph{playable} in $s \in \PHl$
  if and only if $\PHget{s}{a} = a_i$, $\PHget{s}{b} = b_j$ and $\forall m < n, \forall g \in \PHa^{(m)}, \PHhitter(g) \notin s \vee \PHtarget(g) \notin s$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$, defined by: $(s \PHplay h) = s \Cap \PHbounce(h)$.
%  For the sake of clarity, for all $h, h'\in\PHa$, $((s\PHplay h)\PHplay h')$ is abbreviated as $(s\PHplay h\PHplay h')$.
\end{definition}
%\begin{definition}[Scenario ($\Sce$)]
%\label{def:scenario}
  For a given state $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a sequence of actions of $\PHh$ that can be played successively in $s$.
%  so that for all $n \in \indexes{\delta}$,
%  $a_i = \PHhitter(\delta_n)$ (resp. $\PHtarget(\delta_n)$) $\Rightarrow \last_a(\delta_{1..n-1}) \in \{ \varnothing, a_i \}$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
%\end{definition}

\begin{definition}[Process Hitting $n$-reduction] \towrite{Revoir terminologie : “reduction” ? “restriction” ?}
  If $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$ is a Process Hitting with $k$ priorities and $n \in \segm{1}{k}$, we denote $\restriction{\PH}{n}$ \towrite{$\PH_{|n}$ $\PH'$} the $n$-reduction of $\PH$ the following Process Hitting with $n$ priorities:
  $\restriction{\PH}{n} = (\PHs; \PHl; \restriction{\PHa}{n})$,
  with:
  $$\restriction{\PHa}{n} = (\PHa^{(1)}; \dots; \PHa^{(n)})$$
  Furthermore, we denote: $\restriction{\Sce}{n}(s)$ the set of scenarios from $s$ made of actions of $\restriction{\PHa}{n}$.
\end{definition}



\subsection{Modeling cooperation}
\towrite{Sortes coopératives avec mise à jour prioritaire (pas de décalage temporel)}
As described in \cite{PMR10-TCSB}, the cooperation between processes to make another bounce can be
expressed in PH by building a \emph{cooperative sort}.
\pref{fig:PH-cooperativity} shows an example of cooperation between processes $b_1$ and $c_1$ to
make $a_1$ bounce to $a_2$:
a cooperative sort $bc$ is defined with 4 processes (one for each sub-state of the presence of
processes $b_1$ and $c_1$).
For the sake of clarity, the $bc$ processes are indexed using the sub-state they represent.
Hence, $bc_{01}$ represents the sub-state $\PHstate{b_0,c_1}$, and so on.
Each process of sort $b$ and $c$ hit $bc$ to make it bounce to the process reflecting the status of the sorts $b$
and $c$ (e.g., $\PHfrappe{b_1}{bc_{00}}{bc_{10}}$ and $\PHfrappe{b_1}{bc_{01}}{bc_{11}}$).
Then, it is the process $bc_{11}$ which hits $a_1$ to make it bounce to $a_2$ instead of the
independent hits from $b_1$ and $c_1$.



\begin{figure}
  \centering
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(0,4)}{b}{2}{l}
    \TSort{(6,2)}{c}{2}{r}

    \TSetTick{ab}{0}{00}
    \TSetTick{ab}{1}{01}
    \TSetTick{ab}{2}{10}
    \TSetTick{ab}{3}{11}
    \TSort{(3,1)}{ab}{4}{l}

    \THit{a_0}{prio}{ab_3}{.west}{ab_1}
    \THit{a_0}{prio}{ab_2}{.west}{ab_0}
    \THit{a_1}{prio}{ab_1}{.west}{ab_3}
    \THit{a_1}{prio}{ab_0}{.west}{ab_2}

    \THit{b_0}{prio}{ab_3}{.west}{ab_2}
    \THit{b_0}{prio}{ab_1}{.west}{ab_0}
    \THit{b_1}{prio}{ab_2}{.west}{ab_3}
    \THit{b_1}{prio}{ab_0}{.west}{ab_1}
    
    \THit{a_1}{selfhit}{a_1}{.west}{a_0}
    \THit{b_1}{selfhit}{b_1}{.west}{b_0}
    \THit{a_0}{bend left}{b_0}{.south west}{b_1}
    \THit{b_0}{bend right=60}{a_0}{.west}{a_1}

    \THit{ab_3}{}{c_0}{.west}{c_1}

    \path[bounce, bend right]
      \TBounce{ab_3}{}{ab_1}{.north west}
      \TBounce{ab_2}{}{ab_0}{.north west}
      \TBounce{ab_3}{}{ab_2}{.north west}
      \TBounce{ab_1}{}{ab_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{ab_1}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_2}{.south west}
      \TBounce{ab_2}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_1}{.south west}
    ;
    \path[bounce, bend right]
      \TBounce{a_1}{}{a_0}{.north west}
      \TBounce{b_1}{}{b_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{a_0}{}{a_1}{.south west}
      \TBounce{b_0}{}{b_1}{.south west}
    ;
    \path[bounce, bend left]
      \TBounce{c_0}{}{c_1}{.south west}
    ;
  \end{tikzpicture}
  \caption{
  \label{fig:ph-livelock}
    An example of PH model with three well-formed components ($a$, $b$ and $c$) and a well-formed cooperative sort ($ab$).
  }
\end{figure}

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.

When the number of cooperating processes is large, it is possible to chain several cooperative sorts
to prevent the combinatoric explosion of the number of processes created within cooperative sorts.
For instance, if $b_1$, $c_1$, and $d_1$ cooperate, one can create a cooperative sort $bc$ with 4
processes reflecting the presence of $b_1$ and $c_1$, and a cooperative sort $bcd$ with 4 processes
reflecting the presence of $bc_{11}$ and $d_1$.  Such constructions are helpful in PH
as the static analysis of dynamics developed in \cite{PMR12-MSCS} does not suffer from the number of
sorts, but on the number of processes within a single sort.

The construction of cooperation in PH allows to encode any boolean functions between cooperating processes \cite{PMR10-TCSB}.
Due to the presence of priorities, it is possible to build cooperations with no temporal shift by defining the actions on the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in boolean networks.
\towrite{Traduction BN depuis thèse.}

\begin{example}
The PH in \pref{fig:runningPH-2} results from the refinement of the PH in \pref{fig:runningPH-1}
where several cooperations have been specified.
In particular, the bounce to $a_2$ is the result of a cooperation between $b_1$ and $c_1$; and the
bounce to $a_0$ of a cooperation between $b_0$ and $c_0$.
Hence, this PH expresses a BRN where $a$ requires both $b$ and $c$ active to reach its
highest level, and $a$ does not become inactive unless both $b$ and $c$ are inactive.
\end{example}

\subsection{Hypothesis} \towrite{Reformuler}
\label{ssec:hypothesis}

In the scope of this paper, we focus on a specific class of Process Hitting models.
We define here the restrictions that lead to this class of models \todo{and show that they are equivalent to discrete networks}.

\begin{criterion}[2 priorities]
\label{cr:2prio}
%\paragraph{2 priorities}
  In this paper, we only consider Process Hitting models with 2 priorities.
\end{criterion}

\pref{cr:2prio} allows to models two kinds of actions: controllable actions that model the non-determinacy of biological evolutions,
and uncontrollable actions that are used to model non-biological behaviours in the model.

In \pref{def:component} we define a well-formed component as a sort that is hit only by actions of priority $2$.
\begin{definition}
\label{def:component}
  A sort $a \in \PHs$ is said to be a well-formed component if and only if:
  $$\forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) = 2 \enspace.$$
  We call $\components$ the set of well-formed components.
\end{definition}

\begin{definition}
\label{def:chainsactions}
  The set of chains of actions $\PHh(b, a)$ between two sorts $b$ and $a$ is defined as below:
  \begin{align*}
  \PHh(b, a) = \{ (h_i)_{i \in \segm{0}{s}} \in (\PHh^{(1)})^{s+1} &\mid s \in \sN, \PHsort(\PHhitter(h_0)) = b \wedge \PHsort(\PHtarget(h_s)) = a \\
    & \wedge \forall i \in \segm{1}{s}, \PHsort(\PHtarget(h_{i-1})) = \PHsort(\PHhitter(h_{i})) \}
  \end{align*}
\end{definition}

\begin{criterion}[Cycle-freeness between actions of priority $1$]
\label{cr:cyclefreeness}
%\paragraph{Cycle-freeness between actions of priority $1$}
  There is no cycle in chains of actions:
  $$\forall a \in \PHs, \PHh(a, a) = \emptyset \enspace.$$
\end{criterion}

Given \pref{cr:cyclefreeness}, we define the neighbour \towrite{revoir terminologie : neighbors ? vicinity ?} sorts and actions (\pref{def:neighbors}).
\begin{definition}[Neighbour sorts ($\Vs$) and Neighbour actions ($\Vh$)]
\label{def:neighbors}
  The set of neighbour sorts $\Vs(a)$ of a given sort $a$ is the set of components that can interact with it through actions of priority $1$.
  The set of neighbour actions $\Vh(a)$ of $a$ is the set of actions of priority $1$ influencing $a$.
  $$\Vs(a) = \{ b \in \components \mid \PHh(b, a) \neq \emptyset \}$$
%  $$\Vh(a) = \{ h \in \PHh^{(1)} \mid \PHsort(\PHhitter(h)) \in \Vs(a) \wedge \PHsort(\PHtarget(h)) \in \Vs(a) \cup \{ a \} \}$$
  $$\Vh(a) = \{ h \in \PHh^{(1)} \mid \exists b \in \Vs(a), \exists hs \in \PHh(b,a), h \in hs \}$$
\end{definition}

We denote $\pfp_s(a)$ the set of processes of sort $a$ that can be reached from state $s$ and that are local steady-states.
%the set of possible local steady-states of a sort $a$ from a state $s$.
%\todo{À corriger : état global ?}
\begin{definition}[Local steady-state ($\pfp$)]
\label{def:pfp}
  For all $a \in \PHa$ and $s \in \PHl$,
  \begin{align*}
    \pfp_s(a) = \{ a_i \in \PHl_a &\mid \exists \delta \in \restriction{\Sce}{1}(s), \PHget{(s \PHplay \delta)}{a} = a_i \\
    & \quad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \Vh(a), \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
  \end{align*}
  Of course, if $a \in \components$, then $\pfp_s(a) = \{ \PHget{s}{a} \}$.
\end{definition}

In \pref{def:cs} we define a well-formed cooperative sort as a sort that is only by actions of priority $1$ and so that
any sub-state of its neighbourhood is represented by exactly one local steady state in this sort,
and all of its processes represents at least one sub-state of its neighbourhood. \towrite{reformuler ou supprimer}
\begin{definition}
\label{def:cs}
  A sort $a \in \PHs$ is said to be a well-formed cooperative sort iff:
  \begin{enumerate}
    \item $\forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) = 1$
%    \item $\forall s \in \underset{b \in \Vs(a)}{\times} \PHl_b, |\pfp_s(a)| = 1$
%    \item $\forall a_i \in \PHl_a, \exists s \in \underset{b \in \Vs(a)}{\times} \PHl_b, \pfp_s(a) = \{ a_i \}$
    \item \label{csai} $\forall s \in \PHl, |\pfp_s(a)| = 1$
    \item \label{css} $\forall a_i \in \PHl_a, \exists s \in \PHl, \pfp_s(a) = \{ a_i \}$
  \end{enumerate}
\end{definition}
We call $\cs$ the set of well-formed cooperative sorts.
%We note that: $\forall a \in \components, \Vs(a) = \emptyset \wedge \Vh(a) = \emptyset$
Because of (\ref{csai}), we denote in the following: $\pfp_s(a) = a_i$.
Furthermore, because of (\ref{css}), we denote $\csState(a_i)$ the set of sub-states represented by the process $a_i$ of the cooperative sort $a$ (\pref{def:csState}).
\begin{definition}[Represented sub-states ($\csState$)]
\label{def:csState}
  $$\csState(a_i) = \{ ps \in \underset{b \in \Vs(a)}{\times} \PHl_b \mid \forall s \in \PHl, \pfp_{s \Cap ps}(a) = a_i \}$$
\end{definition}

\begin{criterion}[Components \& cooperative sorts]
\label{cr:compcs}
%\paragraph{Components \& cooperative sorts}
  The studied PH is a PH with 2 priorities, and it is only composed of well-formed components and cooperative sorts:
  $$\components \cup \cs = \PHs \wedge \components \cap \cs = \emptyset \enspace.$$
\end{criterion}

\begin{criterion}[Bounded termination]
\label{cr:bounded}
%\paragraph{Bounded termination}
  The dynamics of model $\restriction{\PH}{1}$ contains no cycles:
  %Cycles are still allowed in $\PH$ however.
  %Formally :
  $$\exists N \in \sN, \forall \delta \in \restriction{\Sce}{1}, |\indexes{\delta}| \leq N \enspace.$$
\end{criterion}



\subsection{Consequences of the restrictions}
%Given these hypotheses, we can denote: $\pfp_s(a) = a_i$ the local steady-state of $a$ in state $s$.
We denote by $\update(s)$ the state in which all cooperative sorts are updated.
\begin{align*}
  \update(s) = s \Cap \{ \pfp_{s}(a) \mid a \in CS \} \enspace.
\end{align*}

\pref{th:update} states that from any state, there exists a scenario updating the cooperative sorts of this state.
\begin{theorem}
\label{th:update}
  $\forall s \in \PHl, \exists \delta \in \restriction{\Sce}{1}(s), s \PHplay \delta = \update(s)$
\end{theorem}
\begin{proof}
  Let $a$ be a cooperative sort so that $\PHget{s}{a} \neq \pfp_s(a)$.
  Given the definition of $\pfp_s(a)$, there exists a scenario updating $a$ in $s$.
  As there is no cycle in between the cooperative sorts and an updated cooperative sort cannot evolve, at most $|\cs|$ updates can be done.
\end{proof}
\pref{th:hcompcomp} states that for a given state $s$ and for any action $h = \PHhit{a_i}{b_j}{b_k}$ between well-formed components, $h$ can be played after a series of hits that do not prevent it to be fired.
\pref{th:hcscomp} states the same if $a$ is a well-formed cooperative sort, under the condition that $a_i$ reflects the state of the neighborhood of $a$.
\begin{theorem}
\label{th:hcompcomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a,b \in \components,$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s), \text{$h$ can be played in $s \PHplay \delta$})$
\end{theorem}
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ so that: $(s \PHplay \delta) = \update(s)$.
  As $a,b \in \components$, $a_i \in s \PHplay \delta$ and $b_j \in s \PHplay \delta$.
  Finally, by definition of $\update(s)$, no action of priority $1$ can be played in $s \PHplay \delta$, thus $h$ can be played in $s \PHplay \delta$.
\end{proof}
\begin{theorem}
\label{th:hcscomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a \in \cs, b \in \components$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge \pfp_s(a) = a_i) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s), \text{$h$ can be played in $s \PHplay \delta$})$
\end{theorem}
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ so that: $(s \PHplay \delta) = \update(s)$.
  As $a_i \in \pfp_s(a)$, $a_i \in s \PHplay \delta$.
  Furthermore, $b \in \components$, thus $b_j \in s \PHplay \delta$.
  Finally, by definition of $\update(s)$, no action of priority $1$ can be played in $s \PHplay \delta$, thus $h$ can be played in $s \PHplay \delta$.
\end{proof}

\begin{comment}
\pref{th:autohits} states that any sequence $\zeta$ of self-actions on a well-formed component can be played eventually.
\begin{theorem}
\label{th:autohits}
  Let $a \in \PHs$, $s \in \PHl$ and $\zeta \in \BS$ so that $\forall i \in \indexes{\zeta}, \PHsort(\PHhitter(\zeta_i)) = \PHsort(\PHtarget(\zeta_i)) = a$.
  $\exists (\delta_i)_{i \in \indexes{\zeta}} \in \restriction{\Sce}{1}$ so that $\forall i \in \indexes{\zeta}$, $\zeta_i$ can be played in $s \PHplay \delta_1 \PHplay \zeta_1 \PHplay \dots \PHplay \delta_i$. 
\end{theorem}
\begin{proof}
  With \pref{th:hcompcomp} applied iteratively.
\end{proof}
\end{comment}

