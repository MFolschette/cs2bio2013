\section{The Process Hitting Framework}

We give in this section the definition and the semantics of the Process Hitting (PH) with priorities, which is an extension of the basic semantics given in~\cite{PMR10-TCSB}.
Then we describe the modelling of cooperation between components and discuss how the new aforementioned semantics makes this modelling more accurate.
Finally, in order to perform a static analysis adapted to this new semantics, we give several criteria to restrict the class of models that we can study,
and give several theorems that follow.
This class of models is equivalent to Asynchronous Discrete Networks.

\subsection{Definition of the Process Hitting with $k$ classes of priorities}
\label{ssec:PH}
A PH with $k$ classes of priorities (\pref{def:ph}), also simply called “PH” in the following when it is not ambiguous, gathers a finite number of concurrent \emph{processes} divided into a finite set of \emph{sorts}.
A process belongs to a unique sort and is noted $a_i$ where $a$ is the sort and $i$ the identifier of the process within the sort $a$.
Each process stands for a kind of “activity level” of its sort; a state of the PH thus corresponds to a set of processes containing exactly one process of each sort.

The concurrent interactions between processes are defined by a set of \emph{actions} divided into classes of priorities.
Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process and by the fact that no other action of higher priority can be played in the considered state of the PH.
An action is denoted by $\PHhit{a_i}{b_j}{b_k}$ where $a_i,b_j,b_k$ are processes of sorts $a$ and $b$.
It is required that $b_j \neq b_k$ and that $a=b\Rightarrow a_i=b_j$.
An action $h=\PHfrappe{a_i}{b_j}{b_k}$ is read as ``$a_i$ \emph{hits} $b_j$ to make it bounce to $b_k$'', and $a_i,b_j,b_k$ are called respectively \emph{hitter}, \emph{target} and \emph{bounce} of the action, and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

\begin{definition}[Process Hitting with $k$ classes of priorities]
\label{def:ph}
  If $k \in \sN^*$, a \emph{Process Hitting with $k$ classes of priorities} is a triplet $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$,
  where $\PHa^{\langle k \rangle} = (\PHa^{(1)}; \dots; \PHa^{(k)})$ is a $k$-tuple and:
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ is the finite set of \emph{sorts},
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ is the finite set of \emph{states}, where $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ is the finite set of \emph{processes} of sort $a \in \PHs$ and $l_a \in \sN^*$. Each process belongs to a unique sort: $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$,
    \item $\forall n \in \llbracket 1; k \rrbracket, \PHa^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_l} \mid (a; b) \in \PHs^2 \wedge (a_i; b_j; b_l) \in \PHl_a \times \PHl_b \times \PHl_b \wedge b_j \neq b_l \wedge a = b \Rightarrow a_i = b_j \}$ is the finite set of \emph{actions of priority $n$}.
  \end{itemize}
  We call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all processes, and $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ the set of all actions.
\end{definition}
\noindent
The sort of a process $a_i$ is referred to as $\PHsort(a_i) = a$.
Given a state $s\in \PHl$, the process of sort $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
The override of a state $s$ by a process $a_i$ is defined in \pref{def:statecap} as the same state in which the process of sort $a$ has been replace by $a_i$,
which then allows to define the dynamics of a PH in \pref{def:play}.
\begin{definition}[$\Cap : \PHl \times \PHproc \rightarrow \PHl$]
\label{def:statecap}
  Given a state $s \in \PHl$ and a process $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We also extend this definition to a set of processes $ps$ given that all processes are from different sorts by the override of each process:
  $\forall as \subseteq \PHs, \forall ps \in \underset{a \in as}{\times} \PHl_a, s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
\begin{definition}[Dynamics of a PH ($\PHPtrans$)]
\label{def:play}
  An action $h = \PHhit{a_i}{b_j}{b_k} \in \PHa^{(n)}$ of priority $n$ is \emph{playable} in $s \in \PHl$
  if and only if $\PHget{s}{a} = a_i$, $\PHget{s}{b} = b_j$ and $\forall m < n, \forall g \in \PHa^{(m)}, \PHhitter(g) \notin s \vee \PHtarget(g) \notin s$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$ and is defined by: $(s \PHplay h) = s \Cap \PHbounce(h)$.
  Moreover, we denote: $s \PHPtrans (s \PHplay h)$.

  If $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a sequence of actions of $\PHh$ that can be played successively in $s$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
\end{definition}

In \pref{def:restriction}, we define the $n$-reduction of a given PH as the PH with $n$ classes of priorities in which only actions of priority lower or equal to $n$ are considered.
\begin{definition}[PH $n$-reduction]
\label{def:restriction}
  If $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$ is a Process Hitting with $k$ classes of priorities and $n \in \segm{1}{k}$, we denote $\restriction{\PH}{n}$
  the $n$-reduction of $\PH$.
  $\restriction{\PH}{n} = (\PHs; \PHl; \PHa'^{\langle n \rangle})$ is a PH with $n$ classes of priorities with:
  $$\PHa'^{\langle n \rangle} = (\PHa^{(1)}; \dots; \PHa^{(n)})$$
  Furthermore, we denote: $\restriction{\Sce}{n}(s)$ the set of scenarios from $s$ in $\restriction{\PH}{n}$.
\end{definition}

%\todo{Mieux replacer le PH dans un contexte biologique (catalytic networks, metabolic networks)}



\begin{example}
  \pref{fig:ph-livelock} gives an example of PH with $2$ classes of priorities where:
  \begin{align*}
    \PHs &= \{ a, b, c, ab \} \enspace, \\
    \PHl_a &= \{ a_0, a_1 \} \enspace, & \PHl_b &= \{ b_0, b_1 \} \enspace, \\
    \PHl_c &= \{ c_0, c_1 \} \enspace, & \PHl_{ab} &= \{ ab_{00}, ab_{01}, ab_{10}, ab_{11} \} \enspace.
  \end{align*}
  There also is especially: $\{ \PHhit{ab_{11}}{c_0}{c_1}, \PHhit{a_1}{a_1}{a_0}, \PHhit{a_0}{b_0}{b_1} \} \subseteq \PHh^{(2)}$.

\begin{figure}[ht]
  \centering
  \scalebox{1.5}{
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(0,4)}{b}{2}{l}
    \TSort{(6,2)}{c}{2}{r}

    \TSetTick{ab}{0}{00}
    \TSetTick{ab}{1}{01}
    \TSetTick{ab}{2}{10}
    \TSetTick{ab}{3}{11}
    \TSort{(3,1)}{ab}{4}{r}

    \THit{a_0}{prio}{ab_3}{.west}{ab_1}
    \THit{a_0}{prio}{ab_2}{.west}{ab_0}
    \THit{a_1}{prio}{ab_1}{.west}{ab_3}
    \THit{a_1}{prio}{ab_0}{.west}{ab_2}

    \THit{b_0}{prio}{ab_3}{.west}{ab_2}
    \THit{b_0}{prio}{ab_1}{.west}{ab_0}
    \THit{b_1}{prio}{ab_2}{.west}{ab_3}
    \THit{b_1}{prio}{ab_0}{.west}{ab_1}
    
    \THit{a_1}{selfhit}{a_1}{.west}{a_0}
    \THit{b_1}{selfhit}{b_1}{.west}{b_0}
    \THit{a_0}{bend left}{b_0}{.south west}{b_1}
    \THit{b_0}{bend right=60}{a_0}{.west}{a_1}

    \THit{ab_3}{}{c_0}{.west}{c_1}

    \path[bounce, bend right]
      \TBounce{ab_3}{}{ab_1}{.north west}
      \TBounce{ab_2}{}{ab_0}{.north west}
      \TBounce{ab_3}{}{ab_2}{.north west}
      \TBounce{ab_1}{}{ab_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{ab_1}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_2}{.south west}
      \TBounce{ab_2}{}{ab_3}{.south west}
      \TBounce{ab_0}{}{ab_1}{.south west}
    ;
    \path[bounce, bend right]
      \TBounce{a_1}{}{a_0}{.north west}
      \TBounce{b_1}{}{b_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{a_0}{}{a_1}{.south west}
      \TBounce{b_0}{}{b_1}{.south west}
    ;
    \path[bounce, bend left]
      \TBounce{c_0}{}{c_1}{.south west}
    ;
    \TState{a_1, b_0, ab_2, c_0}
  \end{tikzpicture}
  }
  \caption{
  \label{fig:ph-livelock}
    An example of PH with $2$ classes of priorities.
    Sorts are represented as labelled boxes and processes as circles with their identifier on the side.
    Actions of $\PHh^{(1)}$ are represented by thick arrows and actions of $\PHh^{(2)}$ are represented by single arrows;
    the hit part of each action in drawn in plain line and the bounce part is in dotted line.
    Greyed processes stand for a possible state $s = \PHstate{a_1, b_0, c_0, ab_{10}}$.
  }
\end{figure}

\end{example}



\subsection{Modelling cooperation}
\label{ssec:cooperation}

Cooperation between processes to make another process bounce can be expressed in PH by building a \emph{cooperative sort}, as described in \cite{PMR10-TCSB}.
\pref{fig:ph-livelock} shows an example of cooperation between processes $a_1$ and $b_1$ to make $c_0$ bounce to $c_1$:
a cooperative sort $ab$ is defined with 4 processes (one for each sub-state of the presence of processes $a_1$ and $b_1$).
For the sake of clarity, the processes of $ab$ are indexed using the sub-state they represent.
Hence, $ab_{10}$ represents the sub-state $\PHstate{a_1,b_0}$, and so on.
Each process of sort $a$ and $b$ hit $ab$ to make it bounce to the process reflecting the status of the sorts $a$ and $b$
(e.g., $\PHfrappe{a_1}{ab_{00}}{ab_{10}}$ and $\PHfrappe{a_1}{ab_{01}}{ab_{11}}$).
Then, to represent the cooperation between $a_1$ and $b_1$, the process $ab_{11}$ hits $c_0$ to make it bounce to $c_1$ instead of independent hits from $a_1$ and $b_1$.

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.
Furthermore, it is possible to “factorise” cooperative sorts in order to decrease the number of processes created within each cooperative sort.
For example, if three processes $x_1$, $y_1$ and $z_1$ cooperate,
it is preferable to create a cooperative sort $xy$ with 4 processes to state the presence of $x_1$ and $y_1$
and a second cooperative sort $xyz$ with 4 processes to state the presence of $xy_{11}$ and $z_1$,
rather than a unique cooperative sort with 8 processes stating the presence of $x_1$, $y_1$ and $z_1$.
This “factorisation” allows to prevent the combinatorial explosion of the number of processes in cooperative sorts,
especially for cooperations between more than three processes.
It may have computational consequences as the static analysis method developed in~\pref{sec:sa} does not suffer from the number of sorts but from the number of processes in each sort.

The construction of cooperation in PH allows to encode any Boolean function between cooperating processes \cite{PMR10-TCSB}.
Due to the introduction of priorities into the PH framework,
it is possible to build cooperations with no temporal shift by defining actions updating the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in Boolean networks, as stated in \pref{ssec:hypothesis}.
The aim of this paper is to allow the static analysis of the dynamics to be handled on PH models comprising such higher priority actions updating cooperative sorts.



%\todo{Nouvelle section pour les hypothèses + conséquences ?}
\label{ssec:hypothesis}
\subsection{Restrictions}

In the scope of this paper, we focus on a specific class of PH models.
We define here the restrictions that lead to this class of models and show that they are equivalent to discrete networks.

\pref{cr:2prio} allows to distinguish two kinds of actions:
\emph{unprioritised actions} modelling the non-determinacy of biological evolutions
and \emph{prioritised actions} used to model non-biological behaviours in the model, namely the update of cooperative sorts.
\pref{cr:bounded} states that the dynamics of the studied model $\PH$ contains no infinite sequence of prioritised actions.
As these actions can be considered as non-biological and therefore instantaneous, we thus prevent the existence of any Zeno-like behaviour
which would allow the play of an infinite sequence of prioritised actions in “zero time”.
\begin{criterion}[2 classes of priorities]
\label{cr:2prio}
  In this paper, we only consider Process Hitting with $2$ classes of priorities:
  $\PH = (\PHs; \PHl; \PHa^{\langle 2 \rangle})$.
\end{criterion}
%
\begin{criterion}[Bounded termination]
\label{cr:bounded}
  The dynamics of $\restriction{\PH}{1}$ contains no cycles:
  $\exists N \in \sN, \forall s \in \PHl, \forall \delta \in \restriction{\Sce}{1}(s), |\delta| \leq N$.
\end{criterion}

In \pref{def:component} we define a well-formed component as a sort that is hit only by unprioritised actions, or that no action hits.
\begin{definition}[Well-formed component ($\components$)]
\label{def:component}
  A sort $a \in \PHs$ is a \emph{well-formed component} if and only if:
  \begin{align*}
    \forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) = 2 \enspace.
  \end{align*}
  We call $\components$ the set of well-formed components.
\end{definition}

\pref{def:chainsactions} defines chains of prioritised actions,
and \pref{cr:cyclefreeness} prevents the presence of cycles in these chains.
\begin{definition}
\label{def:chainsactions}
  The set of chains of actions $\PHh(a, b)$ between two sorts $a, b \in \PHs$ is defined as below:
  \begin{align*}
  \PHh(a, b) = \{ (h_i)_{i \in \segm{1}{s+1}} &\in (\PHh^{(1)})^{s+1} \mid s \in \sN \\
    & \wedge \PHsort(\PHhitter(h_1)) = a \wedge \PHsort(\PHtarget(h_{s+1})) = b \\
    & \wedge \forall i \in \segm{1}{s}, \PHsort(\PHtarget(h_{i})) = \PHsort(\PHhitter(h_{i+1})) \}
  \end{align*}
  where $(\PHh^{(1)})^{s+1}$ is the Cartesian product of $s+1$ times the set $\PHh^{(1)}$.
\end{definition}
%
\begin{criterion}[Cycle-freeness in prioritised actions]
\label{cr:cyclefreeness}
  There is no cycles in chains of actions:
  $\forall a \in \PHs, \PHh(a, a) = \emptyset$.
\end{criterion}

In \pref{def:neighbours} we define the notion of neighbouring sorts and actions of a given sort.
The set of neighbouring sorts $\Vs(a)$ of a sort $a$ is the set of components that can interact with it through prioritised actions.
The set of neighbouring actions $\Vh(a)$ of $a$ is the set of prioritised actions influencing $a$.
These definitions are permitted by the previous restrictions (\pref{cr:2prio} and~\ref{cr:cyclefreeness}).
\begin{definition}[$\Vs : \PHs \rightarrow \powerset(\PHsort)$; $\Vh : \PHs \rightarrow \powerset(\PHh)$]
\label{def:neighbours}
  For all sort $a \in \PHs$,
  \begin{align*}
    \Vs(a) &= \{ b \in \components \mid \PHh(b, a) \neq \emptyset \}\\
    \Vh(a) &= \{ h \in \PHh^{(1)} \mid \exists b \in \Vs(a), \exists hs \in \PHh(b,a), h \in hs \}
  \end{align*}
\end{definition}

Finally, we introduce the notion of local steady-state of a sort from a given state.
This local steady-state is the set of processes towards which the sort tends to evolve to, and stay in, when playing only prioritised actions.
We denote $\pfp_s(a)$ this set of processes for a sort $a$ in state $s$ (\pref{def:pfp}),
and we derive from this the notion of well-formed cooperative sort (\pref{def:cs}).
A well-formed cooperative sort models a cooperation between sorts as presented in \pref{ssec:cooperation};
therefore, it must be only hit by prioritised actions,
in a way that its local steady-states efficiently represent all configurations of its neighbouring sorts.
\begin{definition}[$\pfp : \PHs \rightarrow \powerset(\PHproc)$]
\label{def:pfp}
  For all $a \in \PHs$,
  \begin{align*}
    \pfp_s(a) = \{ a_i \in \PHl_a &\mid \exists \delta \in \restriction{\Sce}{1}(s), \PHget{(s \PHplay \delta)}{a} = a_i \\
    & \quad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \Vh(a), \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
  \end{align*}
  Of course, if $a \in \components$, then $\pfp_s(a) = \{ \PHget{s}{a} \}$.
\end{definition}
%
\begin{definition}[Well-formed cooperative sorts ($\cs$)]
\label{def:cs}
  A sort $a \in \PHs$ is a \emph{well-formed cooperative} sort if and only if:
  \begin{enumerate}
    \item $\exists b \in \PHs, \PHh(b, a) \neq \emptyset$
    \item \label{csai} $\forall s \in \PHl, \exists a_i \in \PHl_a, \pfp_s(a) = \{ a_i \}$
    \item \label{css} $\forall a_i \in \PHl_a, \exists s \in \PHl, \pfp_s(a) = \{ a_i \}$
  \end{enumerate}
  We call $\cs$ the set of well-formed cooperative sorts.
\end{definition}

Because of \pref{def:cs}(\ref{csai}), we denote in the following: $\pfp_s(a) = a_i$.
Furthermore, because of \pref{def:cs}(\ref{css}), we denote $\csState(a_i)$ the set of sub-states represented by the process $a_i$ of any cooperative sort $a$ (\pref{def:csState}).
\begin{definition}[$\csState : \PHproc \rightarrow \powerset(\PHproc)$]
\label{def:csState}
  If $a \in \cs$ and $a_i \in \PHl_a$, we define:
  $$\csState(a_i) = \{ ps \in \underset{b \in \Vs(a)}{\times} \PHl_b \mid \forall s \in \PHl, \pfp_{s \Cap ps}(a) = a_i \}$$
\end{definition}

In the following we simply write “component” (resp.~“cooperative sort”) instead of “well-formed component” (resp.~“well-formed cooperative sort”).
Finally, \pref{cr:compcs} states that the set of sorts of the considered PH must be divided between components and cooperative sorts.
\begin{criterion}[Components \& cooperative sorts partition]
\label{cr:compcs}
  $$\PHs = \components \cup \cs \wedge \components \cap \cs = \emptyset$$
\end{criterion}

\begin{example}
  The PH in \pref{fig:ph-livelock} contains three components $a$, $b$ and $c$ and a cooperative sort $ab$ that models cooperation between sorts $a$ and $b$.
\end{example}

The criteria given in this subsection allow to define a class of PH models that is (weakly) bisimilar to Asynchronous Boolean Networks
or, more generally, to the multivalued version of this framework, called Asynchronous Discrete Networks (ADN).
A translation of ADN into PH is given in \pref{suppl:demotrad}, alongside with a demonstration of the weak bisimulation.



\subsection{Consequences of the restrictions}

In this subsection, we give several general theorems that can be derived from the restrictions of \pref{ssec:hypothesis},
and which will help building the static analysis of \pref{sec:sa}.

We first denote by $\update(s)$ the state equivalent to $s$ but in which all cooperative sorts are updated (\pref{def:update}).
This state is unique due to the properties of $\pfp$ given in the previous subsection.
Then, \pref{th:update} states that from any state, there exists a scenario updating the cooperative sorts of this state.
%
\begin{definition}[$\update : \PHl \rightarrow \PHl$]
\label{def:update}
  For all $s \in \PHl$, we define:
  \begin{align*}
    \update(s) = s \Cap \{ \pfp_{s}(a) \mid a \in \cs \} \enspace.
  \end{align*}
\end{definition}
%
\begin{theorem}
\label{th:update}
  $\forall s \in \PHl, \exists \delta \in \restriction{\Sce}{1}(s), s \PHplay \delta = \update(s)$
\end{theorem}
\begin{proof}
  Let $a$ be a cooperative sort so that $\PHget{s}{a} \neq \pfp_s(a)$.
  Given the definition of $\pfp_s(a)$, there exists a scenario $\delta$ updating $a$ in $s$ so that
  $\forall \delta' \in \restriction{\Sce}{1}(s \PHplay \delta)$, $\PHget{(s \PHplay \delta \PHplay \delta')}{a} = \pfp_s(a)$.
  As there is no cycle of actions between the cooperative sorts (\pref{cr:cyclefreeness}) and given that an updated cooperative sort cannot evolve, at most $|\cs|$ updates have to be performed.
\end{proof}

\pref{th:hcompcomp} states that for a given state $s$, and for any action $h = \PHhit{a_i}{b_j}{b_k}$ where $a$ and $b$ are components,
if $\PHget{s}{a} = a_i$ and $\PHget{s}{b} = b_j$, then
$h$ can always be played after a series of hits (and these hits do not prevent it to be fired).
\pref{th:hcscomp} states the same if $a$ is a cooperative sort, under the condition that $a$ is updated in $s$.
\begin{theorem}
\label{th:hcompcomp}
  $\forall s \in \PHl, \forall a,b \in \components, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh,$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s),
  (s \PHplay \delta) \PHPtrans (s \PHplay \delta \PHplay h))$
\end{theorem}
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ with: $(s \PHplay \delta) = \update(s)$.
  As $a,b \in \components$, $a_i \in (s \PHplay \delta)$ and $b_j \in (s \PHplay \delta)$.
  Finally, by definition of $\update(s)$, no prioritised action can be played in $(s \PHplay \delta)$, thus $h$ can be played in $(s \PHplay \delta)$.
\end{proof}
\begin{theorem}
\label{th:hcscomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a \in \cs, b \in \components$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge \pfp_s(a) = a_i) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s),
  (s \PHplay \delta) \PHPtrans (s \PHplay \delta \PHplay h))$
\end{theorem}
\begin{proof}
  Similar to the proof of \pref{th:hcompcomp};
  as $a_i \in \pfp_s(a)$, $a_i \in (s \PHplay \delta)$.
\end{proof}
