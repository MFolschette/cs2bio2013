\section{Asynchronous Automata Networks}
\label{sec:ph}

We give in this section the definition and the semantics of the Asynchronous Automata Networks (AANs).
It is a restriction of the classical (synchronous) Automata Networks
where each set of transitions sharing the same label
can only change one local state at a time.
We also discuss how it is related to the Process Hitting framework
(with or without classes of priorities).
Another definition of AANs introducing classes of priorities
is proposed in \pref{sec:flattening},
where we also show that they have the same expressivity as AANs.

\medskip



We consider an AAN (\pref{def:ph})
which gathers a finite number of \emph{automata},
each one containing a finite number of \emph{local states}.
A local state is noted $a_i$ where $a$ is the name of the automaton it belongs to,
and $i$ is the identifier of this local state within automaton $a$.
A \emph{global state} of the system is the gathering
of exactly one local state from each automata.

The concurrent interactions between local states are defined by a set of \emph{actions}.
An action stands for a set of transitions sharing the same label,
so that playing them changes exactly one local state.
Therefore, an action is denoted by $\PHhit{A}{b_j}{b_k}$
where $A$ is a set of local states
and $b_j$ and $b_k$ are local states of a same automaton $b$,
and it is required that $b_j \neq b_k$ and that
$A$ does not contain a local state of $b$ or two local states of the same automaton.
An action $h=\PHfrappe{A}{b_j}{b_k}$ is read as
``$A$ \emph{hit} $b_j$ to make it bounce to $b_k$'',
and $A$, $b_j$, $b_k$ are called respectively the set of
\emph{hitters}, the \emph{target} and the \emph{bounce} of the action,
and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

\begin{definition}[Asynchronous Automata Networks]
\label{def:ph}
  An \emph{Asynchronous Automata Network} (AAN) is a triplet $\PH = (\PHs; \PHl; \PHa)$,
  where:
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots, z\}$ is the finite set of \emph{automata};
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ is the finite set of
      (global) \emph{states},
      where $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ is the finite set of \emph{local states}
      of automaton $a \in \PHs$, with $l_a \in \sN^*$,
      and so that:
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$;
    \item $\PHa \DEF \{\PHfrappe{A}{b_j}{b_k} \mid
      b \in \PHs \wedge (b_j; b_k) \in \PHl_b \times \PHl_b \wedge
      b_j \neq b_k \wedge
      \forall a \in \PHs, \card{A \cap \PHl_a} \leq 1 \wedge
      A \cap \PHl_b = \emptyset \}$ is the finite set of \emph{actions}.
  \end{itemize}
  Furthermore,
  we call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all local states in the model.
\end{definition}
%
\noindent
The automaton that a local state $a_i$ belongs to is referred to as $\PHsort(a_i) = a$.
Given a state $s\in \PHl$, the local state of automaton $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is, the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
\pref{def:substate} defines the notion of sub-state on a set of automata, that is used to focus on the interesting part of a complete state.
We note that a state is \textit{a fortiori} a sub-state.
The override of a state $s$ by a local state $a_i$ (or by a set of local states)
is defined in \pref{def:statecap} as the same state in which the local state of automaton $a$ has been replaced by $a_i$;
this is used to define the semantics of an AAN in \pref{def:play}.
%
\begin{definition}[Sub-states ($\PHsublize{\PHl}$)]
\label{def:substate}
  If $S \subseteq \PHs$ is a set of automata, a sub-state on $S$ is an element of:
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  The set of all sub-states is:
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  Furthermore, if $\mysigma \in \PHsubl[\PHl]$ and $s \in \PHl$, we note:
    \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \toset{\mysigma} \Rightarrow a_i \in s\]
  where the notation $\toset{\mysigma}$ represents
  the set of components of the Cartesian product $\mysigma$,
  as defined on page~\pageref{notations}.
\end{definition}

In the following, we will also use the notation:
$\PHsublset[\PHl] = \{ \toset{ps} \subseteq \Proc \mid ps \in \PHsubl[\PHl] \}$
and, by extension:
$\forall s \in \PHl, \forall ps \in \PHsublset[\PHl],
  ps \subseteq s \EQDEF \forall a_i \in ps, a_i \in s$.
We note also that for all action $h \in \PHh$, by definition of an AAN, we have:
$\hitter{h} \in \PHsublset[\PHl]$.

\begin{definition}[$\Cap : \PHl \times \PHproc \rightarrow \PHl$]
\label{def:statecap}
  Given a state $s \in \PHl$ and a local state $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We can also extend this definition to a set $ps$ of local states,
  under the condition that all local states of $ps$ are from different automata,
  by the override of each local state independently:
  $\forall ps \in \PHsublset[\PHl], s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
% The notation $\toset{ps}$ represents the set of all elements in $ps$
% (which is not a set but a tuple)
% as defined on page~\pageref{notations}.

\begin{definition}[Semantics of an AAN ($\PHPtrans$)]
\label{def:play}
  An action $h = \PHhit{A}{b_j}{b_k} \in \PHa$ is \emph{playable} in $s \in \PHl$
  if and only if $A \subseteq s$ and $\PHget{s}{b} = b_j$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$, which is defined by: $(s \PHplay h) = s \Cap b_k$.
  Moreover, we denote: $s \PHPtrans (s \PHplay h)$.

  If $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a (possibly empty) sequence of actions of $\PHh$
  that can be played successively in $s$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
\end{definition}



\begin{example}
  \pref{fig:ph-livelock} gives an example of AAN where:
  \begin{align*}
    \PHs &= \{ a, b, c \} \enspace,
      & \PHl_a &= \{ a_0, a_1 \} \enspace, \\
    \PHl_b &= \{ b_0, b_1 \} \enspace,
      & \PHl_c &= \{ c_0, c_1 \} \enspace, \\
    \PHh = \{ \quad
      & \PHfrappem{a_1}{a_0} \enspace , \quad
        \PHfrappem{a_0}{a_1} \enspace , \\
      & \PHfrappem{b_1}{b_0} \enspace , \quad
        \PHfrappem{b_0}{b_1} \enspace , \\
      & \PHfrappes{a_1, b_1}{c_0}{c_1} \enspace \quad \qquad \qquad
      \quad \}
  \end{align*}

\begin{figure}[tb]
  \centering
  \scalebox{1.3}{
  \begin{tikzpicture}[aan]
%    \path[use as bounding box] (-.2,-.5) rectangle (7.2,5.7);
    \TSort{(0,3)}{a}{2}{b}
    \TSort{(0,0)}{b}{2}{t}
    \TSort{(4,1)}{c}{2}{r}
    
    \TAction{a_0.south west}{b_0.north west}{b_1.north west}{bend right=20}{left}
    \TAction{b_0.north east}{a_0.south east}{a_1.south west}{bend right=20}{right}
    \TActionPlur{}{a_1.north}{a_0.north east}{}{1.5,4}{right}
    \TActionPlur{}{b_1.south}{b_0.south east}{}{1.5,-1}{left}
    \TActionPlur{a_1, b_1}{c_0.west}{c_1.south west}{}{2.5,1.5}{left}
    
    \TState{a_1, b_0, c_0}
  \end{tikzpicture}
  }
  \caption{%
  \label{fig:ph-livelock}%
    An example of AAN.
    This model represents the interaction of two exclusive components $a$ and $b$,
    that cannot be active simultaneously, and that degrade over time.
    Moreover, these two components can cooperate to activate $c$
    if their “active” states ($a_1$ and $b_1$)
    are present in the same state.
    Automata are represented by labelled boxes
    and local states by circles with their identifier on the side.
    Actions are represented by a dot connected by an edge to every hitter
    and by an arrows to the target, followed by another dotted arrow towards the bounce.
    Greyed local states stand for the following possible global state:
    $\PHstate{a_1, b_0, c_0, ab_{10}}$.
  }
\end{figure}

\end{example}

A context (\pref{def:context}) extends the notion of state to a set of possible initial states:
to each automaton in the model, a context maps a set of local states in this automaton.
\begin{definition}[Context ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each automaton in $\PHs$ a non-empty subset of its local states:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}
\noindent
For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc)$ or $ps \in \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
\begin{comment}
A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last local state in the sequence $\delta$ (hitter or bounce) of every automaton mentioned in $\delta$.

\end{comment}

We also extend the override operator to contexts (\pref{def:ctxcap}).
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \rightarrow \Ctx$]
\label{def:ctxcap}
  For any $\ctx\in\Ctx$ and set of local states $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by:
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} \DEF
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}

Finally, we define the support (\pref{def:supp}) of a sequence of actions $\zeta$
as the set containing the first local state of each automata appearing in $\zeta$,
that is, as a hitter or as a target.
For this, we first define the \emph{first appearance} of an automata
in this sequence.

\begin{definition}[$\supp$ \& $\first$]
\label{def:supp}
  For all sequences of actions $\zeta$, we define:
  \[
    \suppf{\zeta} = \bigcup_{a \in \PHs} \firstf{a}{\zeta}
  \]
  where:
  \begin{align*}
  \forall a \in \PHs, \firstf{a}{\zeta} &=
    \begin{cases}
      \emptyset &
        \text{if } \forall n \in \indexes{\zeta},
        B^\zeta_n \cap \PHl_a \neq \emptyset \\
      B^\zeta_m \cap \PHl_a &
        \text{else, if } m =
        \min\{ n \in \indexes{\zeta} \mid B^\zeta_n \cap \PHl_a \neq \emptyset \}
    \end{cases} \\
  \forall n \in \indexes{\zeta}, B^\zeta_n &= \hitter{\zeta_n} \cup \{ \target{\zeta_n} \}.
  \end{align*}
\end{definition}

We note that for all sequence of actions $\zeta$,
$\forall a \in \PHs, 0 \leq \card{\firstf{a}{\zeta}} \leq 1$,
because given the particular for of the actions of an AAN (see \pref{def:ph}),
$\forall n \in \indexes{\zeta}, B_n \in \PHsublset[\PHl]$.
This also means that: $\suppf{\zeta} \in \PHsublset[\PHl]$.



\begin{remark}[Comparison with the Process Hitting]
  The Process Hitting framework
  previously introduced in~\cite{PMR10-TCSB}
  is a restriction of the AAN formalism;
  indeed, a Process Hitting model is an AAN so that
  $\forall h \in \PHh, 0 \leq \card{\hitter{h}} \leq 1$.
  However, the AANs defined in this paper have the same expressivity than
  the Process Hitting with classes of priorities, as previously
  introduced in~\cite{FPMR13-CS2Bio}.
  Indeed, in the Process Hitting with at least 2 classes of priorities
  it is possible to use additional automata, called “cooperative sorts”,
  in order to model the actions of any AAN that have more than one hitter.
\end{remark}
