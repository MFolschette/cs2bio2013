\section{The Process Hitting Framework}

We give in this section the definition and the semantics of the Process Hitting (PH) with priorities, which is an extension of the basic semantics given in~\cite{PMR10-TCSB}.
Then we describe the modelling of cooperation between components and discuss how the new aforementioned semantics makes this modelling more accurate.
Finally, in order to perform a static analysis adapted to this new semantics, we give several criteria to restrict the class of models that we can study,
and give several theorems that follow.
This class of models is equivalent to Asynchronous Discrete Networks.

\subsection{Definition of the Process Hitting with $k$ classes of priorities}
\label{ssec:PH}
A PH with $k$ classes of priorities (\pref{def:ph}), also simply called “PH” in the following when it is not ambiguous, gathers a finite number of concurrent \emph{processes} divided into a finite set of \emph{sorts}.
A process belongs to a unique sort and is noted $a_i$ where $a$ is the sort and $i$ the identifier of the process within the sort $a$.
Each process stands for a kind of “activity level” of its sort; a state of the PH thus corresponds to a set of processes containing exactly one process of each sort.

The concurrent interactions between processes are defined by a set of \emph{actions} divided into classes of priorities.
Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process and by the fact that no other action of higher priority can be played in the considered state of the PH.
An action is denoted by $\PHhit{a_i}{b_j}{b_k}$ where $a_i,b_j,b_k$ are processes of sorts $a$ and $b$.
It is required that $b_j \neq b_k$ and that $a=b\Rightarrow a_i=b_j$.
An action $h=\PHfrappe{a_i}{b_j}{b_k}$ is read as ``$a_i$ \emph{hits} $b_j$ to make it bounce to $b_k$'', and $a_i,b_j,b_k$ are called respectively \emph{hitter}, \emph{target} and \emph{bounce} of the action, and can be referred to as $\PHhitter(h), \PHtarget(h), \PHbounce(h)$, respectively.

\begin{definition}[Process Hitting with $k$ classes of priorities]
\label{def:ph}
  If $k \in \sNN$, a \emph{Process Hitting with $k$ classes of priorities} is a triplet $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$,
  where $\PHa^{\langle k \rangle} = (\PHa^{(1)}; \dots; \PHa^{(k)})$ is a $k$-tuple and:
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ is the finite set of \emph{sorts},
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ is the finite set of \emph{states}, where $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ is the finite set of \emph{processes} of sort $a \in \PHs$ and $l_a \in \sN^*$. Each process belongs to a unique sort: $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$,
    \item $\forall n \in \llbracket 1; k \rrbracket, \PHa^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_l} \mid (a; b) \in \PHs^2 \wedge (a_i; b_j; b_l) \in \PHl_a \times \PHl_b \times \PHl_b \wedge b_j \neq b_l \wedge a = b \Rightarrow a_i = b_j \}$ is the finite set of \emph{actions of priority $n$}.
  \end{itemize}
  We call $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ the set of all processes, and $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ the set of all actions.
\end{definition}
\noindent
The sort of a process $a_i$ is referred to as $\PHsort(a_i) = a$.
Given a state $s\in \PHl$, the process of sort $a \in \PHs$ present in $s$ is denoted by $\PHget{s}{a}$, that is the $a$-coordinate of the state $s$.
If $a_i \in \PHl_a$, we define the notation $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
The override of a state $s$ by a process $a_i$ is defined in \pref{def:statecap} as the same state in which the process of sort $a$ has been replace by $a_i$,
which then allows to define the dynamics of a PH in \pref{def:play}.
\begin{definition}[$\Cap : \PHl \times \PHproc \rightarrow \PHl$]
\label{def:statecap}
  Given a state $s \in \PHl$ and a process $a_i \in \PHproc$, $(s \Cap a_i)$ is the state defined by:
  $\PHget{(s \Cap a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \Cap a_i)}{b} = \PHget{s}{b}$.
  We also extend this definition to a set of processes $ps$ given that all processes are from different sorts by the override of each process:
  $\forall as \subseteq \PHs, \forall ps \in \underset{a \in as}{\times} \PHl_a, s \Cap ps = s \underset{a_i \in ps}{\Cap} a_i$.
\end{definition}
\begin{definition}[Dynamics of a PH ($\PHPtrans$)]
\label{def:play}
  An action $h = \PHhit{a_i}{b_j}{b_k} \in \PHa^{(n)}$ of priority $n$ is \emph{playable} in $s \in \PHl$
  if and only if $\PHget{s}{a} = a_i$, $\PHget{s}{b} = b_j$ and $\forall m < n, \forall g \in \PHa^{(m)}, \PHhitter(g) \notin s \vee \PHtarget(g) \notin s$.
  In such a case, $(s \PHplay h)$ stands for the state resulting from the play of the action $h$ in $s$ and is defined by: $(s \PHplay h) = s \Cap \PHbounce(h)$.
  Moreover, we denote: $s \PHPtrans (s \PHplay h)$.

  If $s \in \PHl$,
  a \emph{scenario} $\delta$ from $s$ is a sequence of actions of $\PHh$ that can be played successively in $s$.
  The set of all scenarios from $s$ is noted $\Sce(s)$.
\end{definition}

\pref{def:substate} defines the notion of sub-state on a set of sorts,
that is used to consider the interesting part of a complete state.
\begin{definition}[Sub-states ($\PHsublize{\PHl}$)]
\label{def:substate}
  If $S \subset \PHs$ is a set of sorts, a sub-set on $S$ is an element of:
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  The set of all sub-sets is:
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  Furthermore, if $\mysigma \in \PHsubl[\PHl]$ and $s \in \PHl$, we note:
    \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \mysigma \Rightarrow a_i \in s \enspace.\]
\end{definition}
We note that a state is \textit{a fortiori} a sub-state: $\PHl \subset \PHsubl[\PHl]$.

In \pref{def:restriction}, we define the $n$-reduction of a given PH as the PH with $n$ classes of priorities in which only actions of priority lower or equal to $n$ are considered.
\begin{definition}[PH $n$-reduction]
\label{def:restriction}
  If $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$ is a Process Hitting with $k$ classes of priorities and $n \in \segm{1}{k}$, we denote $\restriction{\PH}{n}$
  the $n$-reduction of $\PH$.
  $\restriction{\PH}{n} = (\PHs; \PHl; \PHa'^{\langle n \rangle})$ is a PH with $n$ classes of priorities with:
  $$\PHa'^{\langle n \rangle} = (\PHa^{(1)}; \dots; \PHa^{(n)})$$
  Furthermore, we denote: $\restriction{\Sce}{n}(s)$ the set of scenarios from $s$ in $\restriction{\PH}{n}$.
\end{definition}



\begin{example}
  \pref{fig:ph-livelock} gives an example of PH with $2$ classes of priorities where:
  \begin{align*}
    \PHs &= \{ a, b, c, ab \} \enspace, \\
    \PHl_a &= \{ a_0, a_1 \} \enspace, & \PHl_b &= \{ b_0, b_1 \} \enspace, \\
    \PHl_c &= \{ c_0, c_1 \} \enspace, & \PHl_{ab} &= \{ ab_{00}, ab_{01}, ab_{10}, ab_{11} \} \enspace.
  \end{align*}
  There also is especially: $\{ \PHhit{ab_{11}}{c_0}{c_1}, \PHhit{a_1}{a_1}{a_0}, \PHhit{a_0}{b_0}{b_1} \} \subseteq \PHh^{(2)}$.

\begin{figure}[tb]
  \centering
  \scalebox{1.2}{
  \begin{tikzpicture}
    \TSort{(0,0)}{a}{2}{l}
    \TSort{(0,4)}{b}{2}{l}
    \TSort{(7,2.5)}{c}{2}{r}

    \TSetTick{ab}{0}{00}
    \TSetTick{ab}{1}{01}
    \TSetTick{ab}{2}{10}
    \TSetTick{ab}{3}{11}
    \TSort{(2,2.5)}{ab}{4}{t}

    \THit{a_0}{prio}{ab_3}{.south}{ab_1}
    \THit{a_0}{prio}{ab_2}{.south}{ab_0}
    \THit{a_1}{prio}{ab_1}{.south}{ab_3}
    \THit{a_1}{prio}{ab_0}{.south}{ab_2}

    \THit{b_0}{prio}{ab_3}{.north}{ab_2}
    \THit{b_0}{prio}{ab_1}{.north}{ab_0}
    \THit{b_1}{prio}{ab_2}{.north}{ab_3}
    \THit{b_1}{prio}{ab_0}{.north}{ab_1}
    
    \THit{a_1}{selfhit}{a_1}{.west}{a_0}
    \THit{b_1}{selfhit}{b_1}{.west}{b_0}
    \THit{a_0.north}{bend left}{b_0}{.west}{b_1}
    \THit{b_0.south}{bend right=60}{a_0}{.west}{a_1}

    \THit{ab_3}{}{c_0}{.west}{c_1}

	\path[bounce, bend right=55]
      \TBounce{ab_0}{}{ab_2}{.west}
      \TBounce{ab_1}{}{ab_3}{.west}
	;
	\path[bounce, bend left=20]
      \TBounce{ab_3}{}{ab_1}{.south east}
      \TBounce{ab_2}{}{ab_0}{.south east}
	;
    \path[bounce, bend right=20]
      \TBounce{ab_3}{}{ab_2}{.north east}
      \TBounce{ab_1}{}{ab_0}{.north east}
    ;
    \path[bounce, bend left=30]
      \TBounce{ab_2}{}{ab_3}{.west}
      \TBounce{ab_0}{}{ab_1}{.west}
    ;
    \path[bounce, bend right]
      \TBounce{a_1}{}{a_0}{.north west}
      \TBounce{b_1}{}{b_0}{.north west}
    ;
    \path[bounce, bend left]
      \TBounce{a_0}{}{a_1}{.south west}
      \TBounce{b_0}{}{b_1}{.south west}
    ;
    \path[bounce, bend left]
      \TBounce{c_0}{}{c_1}{.south west}
    ;
    \TState{a_1, b_0, ab_2, c_0}
  \end{tikzpicture}
  }
  \caption{
  \label{fig:ph-livelock}
    An example of PH with $2$ classes of priorities.
    Sorts are represented as labelled boxes and processes as circles with their identifier on the side.
    Actions of $\PHh^{(1)}$ are represented by thick arrows and actions of $\PHh^{(2)}$ are represented by single arrows;
    the hit part of each action in drawn in plain line and the bounce part is in dotted line.
    Greyed processes stand for a possible state $s = \PHstate{a_1, b_0, c_0, ab_{10}}$.
  }
\end{figure}

\end{example}



\subsection{Modelling cooperation}
\label{ssec:cooperation}

Cooperation between processes to make another process bounce can be expressed in PH by building a \emph{cooperative sort}, as described in \cite{PMR10-TCSB}.
\pref{fig:ph-livelock} shows an example of cooperation between processes $a_1$ and $b_1$ to make $c_0$ bounce to $c_1$:
a cooperative sort $ab$ is defined with 4 processes (one for each sub-state of the presence of processes $a_1$ and $b_1$).
For the sake of clarity, the processes of $ab$ are indexed using the sub-state they represent.
Hence, $ab_{10}$ represents the sub-state $\PHstate{a_1,b_0}$, and so on.
Each process of sort $a$ and $b$ hit $ab$ to make it bounce to the process reflecting the status of the sorts $a$ and $b$
(\eg $\PHfrappe{a_1}{ab_{00}}{ab_{10}}$ and $\PHfrappe{a_1}{ab_{01}}{ab_{11}}$).
Then, to represent the cooperation between $a_1$ and $b_1$, the process $ab_{11}$ hits $c_0$ to make it bounce to $c_1$ instead of independent hits from $a_1$ and $b_1$.

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.
Furthermore, it is possible to “factorise” cooperative sorts in order to decrease the number of processes created within each cooperative sort.
For example, if three processes $x_1$, $y_1$ and $z_1$ cooperate,
it is preferable to create a cooperative sort $xy$ with 4 processes to state the presence of $x_1$ and $y_1$
and a second cooperative sort $xyz$ with 4 processes to state the presence of $xy_{11}$ and $z_1$,
rather than a unique cooperative sort with 8 processes stating the presence of $x_1$, $y_1$ and $z_1$.
This “factorisation” allows to prevent the combinatorial explosion of the number of processes in cooperative sorts,
especially for cooperations between more than three processes.
It may have computational consequences as the static analysis method developed in~\pref{sec:sa} does not suffer from the number of sorts but from the number of processes in each sort.

The construction of cooperation in PH allows to encode any Boolean function between cooperating processes \cite{PMR10-TCSB}.
Due to the introduction of priorities into the PH framework,
it is possible to build cooperations with no temporal shift by defining actions updating the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in Boolean networks, as stated in \pref{ssec:hypothesis}.
The aim of this paper is to allow the static analysis of the dynamics to be handled on PH models comprising such higher priority actions updating cooperative sorts.



\subsection{Restrictions}
\label{ssec:hypothesis}

In the scope of this paper, we focus on a specific class of PH models
in which actions of $\PHh^{(1)}$ are called \emph{prioritized actions} and allow to model non-biological actions.
%and show that they are equivalent to discrete networks.
We consider in this section a PH model with $k$ classes of priorities: $\PH = (\PHs; \PHl; \PHa^{\langle k \rangle})$, with $k \in \sNN$
and we define here the restrictions that lead to this class of models.

%\pref{cr:2prio} allows to distinguish two kinds of actions:
%\emph{unprioritised actions} modelling the non-determinacy of biological evolutions
%and \emph{prioritised actions} used to model non-biological behaviours in the model, namely the update of cooperative sorts.
\pref{cr:bounded} states that the dynamics of the studied model $\PH$ contains no infinite sequence of prioritised actions.
As these actions can be considered as non-biological and therefore instantaneous, we thus prevent the existence of any Zeno-like behaviour
which would allow the play of an infinite sequence of prioritised actions in “zero time”.
As a consequence, the set $\restriction{\Sce}{1}$ is finite.
%\begin{condition}[2 classes of priorities]
%\label{cr:2prio}
%  In this paper, we only consider Process Hitting with $2$ classes of priorities:
%  $\PH = (\PHs; \PHl; \PHa^{\langle 2 \rangle})$.
%\end{condition}
%
\begin{condition}[Bounded termination]
\label{cr:bounded}
  The dynamics of $\restriction{\PH}{1}$ contains no cycles:
  $\exists N \in \sN, \forall s \in \PHl, \forall \delta \in \restriction{\Sce}{1}(s), |\delta| \leq N$.
\end{condition}

Given a sort $a\in\Sigma$ and a state $s\in L$, 
we denote $\pfp_s(a)$ (\pref{def:pfp}) the processes of sort $a$ that can be present after
playing all actions of priority $1$,
which is always defined because of \pref{cr:bounded}.

\begin{definition}[$\pfp : \PHl \times \PHs \rightarrow \powerset(\PHproc)$]
\label{def:pfp}
  For all $s \in \PHl$ and $a \in \PHs$,
  \begin{align*}
    \pfp_s(a) = \{ \get{(s\play\delta)}{a} \in \PHl_a &\mid \delta \in \restriction{\Sce}{1}(s)
					\wedge\nexists h\in\PHh^{(1)}, (\delta; h) \in\restriction{\Sce}{1}(s) \}
  \end{align*}
\end{definition}

Our second condition (\pref{cr:compcs}) imposes that any sort in the Process
Hitting is either a well-formed component (\pref{def:component}) or a well-formed cooperative sort
(\pref{def:cs}).
The former is a sort that is hit only by actions with priority greater than $2$.
The latter is a sort that is hit only by actions with priority $1$ and which
always converge to the same process with respect to the state of the components
that have an influence on it (\pref{def:conn}).
We note $\components\subset\Sigma$ the set of well-formed components,
and $\cs\subset\Sigma$ the set of well-formed cooperative sorts.

\begin{definition}[Well-formed component ($\components$)]
\label{def:component}
A sort $a \in \PHs$ is a \emph{well-formed component} if and only if:
    $\forall h \in \PHh, \PHsort(\PHtarget(h)) = a \Rightarrow \prio(h) \geq 2$ \enspace.
\end{definition}

\begin{definition}[Components influence $(\compin: \PHs\to\powerset(\components))$]
\label{def:conn}
Given a sort $a$, $\compin(a)\DEF \conn(a)\cap\components$ where
$\conn(a)$ is the smallest set of sorts satisfying the following properties:
\begin{align*}
a\in\conn(a) &
\\
\forall h\in  \PHh^{(1)},
	\Sigma(\target{h})\in\conn(a) & \Longrightarrow \Sigma(\hitter{h})\in\conn(a)
\end{align*}
\end{definition}

\begin{definition}[Well-formed cooperative sorts ($\cs$)]
\label{def:cs}
A sort $a \in \PHs$ is a \emph{well-formed cooperative} sort if and only if:
\begin{enumerate}[(i)]
\item $\forall h\in\PHh, \Sigma(\PHtarget(h))=a \Longrightarrow \prio(h) = 1$;
\item\label{csai} $\forall s\in\PHl, \card{\pfp_s(a)} = 1$;
\item\label{css} $\forall a_i \in \PHl_a, \exists s \in \PHl, a_i\in\pfp_s(a)$;
\item $\forall \sigma\in\PHsubl[\PHl]_{\compin(a)},
			\forall s,s'\in\PHl,
				\sigma\subseteq s\wedge \sigma\subseteq s'\Rightarrow 
							\pfp_s(a) = \pfp_{s'}(a)$\enspace.
\end{enumerate}
\end{definition}

\begin{condition}[Components \& cooperative sorts partition]
\label{cr:compcs}
  $$\PHs = \components \cup \cs \wedge \components \cap \cs = \emptyset$$
\end{condition}

Because of \pref{def:cs}(\ref{csai}), we denote in the following: $\pfp_s(a) = a_i$.
Furthermore, because of \pref{def:cs}(\ref{css}), we denote $\csState(a_i)$ the set of sub-states represented by the process $a_i$ of any cooperative sort $a$ (\pref{def:csState}).
\begin{definition}[$\csState : \PHproc \rightarrow \powerset(\PHproc)$]
\label{def:csState}
  If $a \in \cs$ and $a_i \in \PHl_a$, 
  $$\csState(a_i) \DEF \{ \toset{ps} \mid ps\in\PHsubl[\PHl]_{\compin(a)} \wedge
  							\exists s\in\PHl, (ps\subset s\wedge \pfp_s(a)=a_i)
							\}$$
\end{definition}

In the following we simply write “component” (\resp “cooperative sort”) instead of “well-formed component” (\resp “well-formed cooperative sort”).

\begin{example}
  The PH in \pref{fig:ph-livelock} contains three components $a$, $b$ and $c$ and a cooperative sort $ab$ that models cooperation between sorts $a$ and $b$.
\end{example}


\subsection{Consequences of the restrictions}

In this subsection, we give several general theorems that can be derived from the restrictions of \pref{ssec:hypothesis}, %(\pref{cr:bounded}, \ref{cr:cyclefreeness} \& \ref{cr:compcs})
in the special case of a PH model with $2$ classes of priorities $\PH = (\PHs; \PHl; \PHa^{\langle 2 \rangle})$.
These results will help building the static analysis of \pref{sec:sa}.

We first denote by $\update(s)$ the state equivalent to $s$ but in which all cooperative sorts are updated (\pref{def:update}).
This state is unique due to the properties of $\pfp$ given in the previous subsection.
Then, \pref{th:update} states that from any state, there exists a scenario updating the cooperative sorts of this state.
%
\begin{definition}[$\update : \PHl \rightarrow \PHl$]
\label{def:update}
  For all $s \in \PHl$, we define:
  \begin{align*}
    \update(s) = s \Cap \{ \pfp_{s}(a) \mid a \in \cs \} \enspace.
  \end{align*}
\end{definition}
%
\begin{theorem}
\label{th:update}
  $\forall s \in \PHl, \exists \delta \in \restriction{\Sce}{1}(s), s \PHplay \delta = \update(s)$
\end{theorem}
%
\begin{proof}
  Let $a$ be a cooperative sort so that $\PHget{s}{a} \neq \pfp_s(a)$.
  Given the definition of $\pfp_s(a)$, there exists a scenario $\delta$ updating $a$ in $s$ so that
  $\forall \delta' \in \restriction{\Sce}{1}(s \PHplay \delta)$, $\PHget{(s \PHplay \delta \PHplay \delta')}{a} = \pfp_s(a)$.
\end{proof}

\pref{th:hcompcomp} states that for a given state $s$, and for any action $h = \PHhit{a_i}{b_j}{b_k}$ where $a$ and $b$ are components,
if $\PHget{s}{a} = a_i$ and $\PHget{s}{b} = b_j$, then
$h$ can always be played after a series of prioritised hits (and these hits do not prevent it to be fired).
\pref{th:hcscomp} states the same if $a$ is a cooperative sort, under the condition that $a$ is updated in $s$.
\begin{theorem}
\label{th:hcompcomp}
  $\forall s \in \PHl, \forall a,b \in \components, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh,$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s),
  (s \PHplay \delta) \PHPtrans (s \PHplay \delta \PHplay h))$
\end{theorem}
%
\begin{proof}
  From \pref{th:update}, there exists a scenario $\delta$ with: $(s \PHplay \delta) = \update(s)$.
  As $a,b \in \components$, $a_i \in (s \PHplay \delta)$ and $b_j \in (s \PHplay \delta)$.
  Finally, by definition of $\update(s)$, no prioritised action can be played in $(s \PHplay \delta)$, thus $h$ can be played in $(s \PHplay \delta)$.
\end{proof}
%
\begin{theorem}
\label{th:hcscomp}
  $\forall s \in \PHl, \forall h = \PHhit{a_i}{b_j}{b_k} \in \PHh, a \in \cs, b \in \components,$\\
  $(\PHget{s}{a} = a_i \wedge \PHget{s}{b} = b_j \wedge \pfp_s(a) = a_i) \Rightarrow (\exists \delta \in \restriction{\Sce}{1}(s),
  (s \PHplay \delta) \PHPtrans (s \PHplay \delta \PHplay h))$
\end{theorem}
\begin{proof}
  Similar to the proof of \pref{th:hcompcomp};
  as $a_i \in \pfp_s(a)$, $a_i \in (s \PHplay \delta)$.
\end{proof}
