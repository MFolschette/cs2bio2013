% vi:spell spelllang=en:
\section{Static Analysis}\label{sec:sa}

\todo{Replacer notre méthode par rapport aux méthodes d'interprétation abstraite en général}

\todo{Gluer : explication des définitions, etc.}

The aim of this section is to define the problem of reachability in a PH,
and propose an under-approximation allowing to efficiently solve it.
The static analysis presented here is inspired from~\cite{PMR12-MSCS}.

We consider in this section a PH model $\PH = (\PHs; \PHl; \PHa^{\langle 2 \rangle})$ with $2$ classes of priorities
that respects all Conditions (\ref{cr:bounded} \& \ref{cr:compcs}) of \pref{ssec:hypothesis}.

\medskip

\modMF{
The main idea behind the static analysis presented in this section
is to abstract the dynamics of a Process Hitting model
by a more general and easier to analyse dynamics.
For this, we focus on the notion of objective:
an objective is a couple of processes (\eg $\PHobj{a_i}{a_j}$) whose reachability
is required to ensure the global reachability property considered;
in other words, it is required that a set of actions hitting $a$ exists so that,
starting from a state containing $a_i$,
it is possible to play these actions (possibly intertwined with other actions)
and reach a state containing $a_j$.
Given the particular form of the actions in Process Hitting,
the solving of such an objective raises new objectives in the general case,
because each action can be triggered by (at most) one process from a different sort.
Indeed, each of these processes also have to be reached before the required actions are played.
However, the order of the considered actions is abstracted,
and so is the order of the related objectives,
thus resulting in an over-approximation of the requirements.
}



\subsection{Preliminary definitions}
\label{ssec:sa-def}

The reachability of a process $a_j$ of a given sort $a$ from another process $a_i$ is called an objective and is denoted $\PHobjp{a}{i}{j}$ (\pref{def:obj}).
\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  If $a \in \components$, the reachability of a process $a_j$ from a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a \times \PHl_a \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) \DEF
  a$, $\PHtarget(P)\DEF a_i$, $\PHbounce(P)\DEF a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same sort, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

A context (\pref{def:context}) extends the notion of state to a set of possible initial states:
\modMF{
to each sort in the model, a context maps a set of processes in this sort.
}
We also extend the override operator to contexts (\pref{def:ctxcap}).
\begin{definition}[Context ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}
%
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \rightarrow \Ctx$]
\label{def:ctxcap}
  For any $\ctx\in\Ctx$ and set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by:
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} \DEF
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}
\noindent
For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc)$ or $ps \in \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last process in the sequence $\delta$ (hitter or bounce) of every sort mentioned in $\delta$.

Finally, a bounce sequence on a sort $a$ (\pref{def:bs}) is a sequence of actions hitting $a$
in which the bounce process of each action is the hitter process of the following action.
Bounce sequences are used to find local solutions to a given objective:
\modMF{
indeed, the bounce sequences related to an objective $\PHobj{a_i}{a_j}$
only take depend on the bounces of the actions hitting the sort $a$.
}%
A bounce sequence on $a$ can be abstracted into the minimal sets of its hitters that are not in sort $a$ (\pref{def:aBS}).
This abstraction is later used to propagate an objective on a given sort
by creating new objectives on other sots.
In the following, we denote: $\Sol = \powerset(\PHproc)$.
\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) \DEF \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$
  and $\emptyseq \in \BS(\obj{a_i}{a_i})$
  \modMF{
  for a trivial objective $\PHobj{a_i}{a_i}$.
  }
\end{definition}
%
\begin{definition}[$\aBS:\Obj \rightarrow \powerset(\Sol)$]
\label{def:aBS}
  The \emph{abstractions of bounce sequences} of an objective $P$, denoted by the set $\aBS(P)$, are the sets of hitters of bounce sequences solving $P$:
  \[
    \aBS(P) \DEF \{ \abstr{\zeta} \in \Sol \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  \modMF{
  where $\forall P \in \Obj, \forall \zeta \in \BS(P)$:
  \[
    \abstr{\zeta} \DEF \{ \PHhitter(\zeta_n) \mid
    n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}
  \]
  }%
\end{definition}



\subsection{Under-approximation}
\label{ssec:ua}

We denote $\concr(\w)$ (\pref{def:concr}) the set of scenarios concretising an objective sequence $\w$ in the context $\ctx$.
In \pref{def:uconcr}, we define $\uconcr(\w)$ as equal to $\concr(\w)$ if and only if $\concr(\w)$ contains scenarios starting from all states $s \subseteq \ctx$.
\pref{lem:uconcr-ctx} is used to over-approximate the initial context $\ctx$.

\begin{definition}[$\concr: \OS \to \powerset(\Sce)$]\label{def:concr}
Given $\w\in\OS$, $\concr(\w)$ is the set of minimal scenarios concretising $\w$ in the
context $\ctx$. It is defined as the largest set satisfying the following conditions:
\begin{enumerate}[(i)]
\item $\forall\delta\in\concr(\w), \modMF{\delta\in\Sce(\ctx)}$
\item $\forall\delta\in\concr(\w),
  \exists \phi:\indexes{\w}\to\indexes{\delta},
    (\forall n,m\in\indexes{\w}, n<m \Leftrightarrow \phi(n)\leq\phi(m)),$
\\\hspace*{2cm}$\forall n\in\indexes{\w}, \PHbounce(\w_n) \in \ctx\play\delta_{1..\phi(n)}$
\item $\forall\delta,\delta'\in\concr(\w)
				\card{\delta}\leq\card{\delta'} \Rightarrow
					\delta\neq\delta'_{1..\card{\delta}}$.
\end{enumerate}
\end{definition}
\begin{definition}[$\uconcr: \OS \rightarrow \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \modMF{\forall \w \in \OS,}
  \uconcr(\w) \DEF
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \delta \in \Sce(s) \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{lemma}
\label{lem:uconcr-ctx}
  $\ctx \subseteq \ctx' \wedge \muconcr_{\ctx'}(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx}(\w) \neq \emptyset$.
\end{lemma}

For any objective $P$ and context $\ctx$, \pref{def:maxCont} gives the set of processes of sort $\PHsort(P)$ that are required to solve $P$ in $\ctx$, given by $\gCont_\ctx(\PHsort(P), P)$.
\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \rightarrow \powerset(\PHproc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) \DEF
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

The graph of local causality $\cwB = (\V, \E)$ defined in \pref{def:glc} is a graph where $\V \subseteq \Proc \cup \Obj \cup \Sol$ and $\E \subseteq \V \times \V$.
A node in $\PHproc$ is a required process,
a node in $\Obj$ is an objective to reach a given process
and a node in $\Sol$ is a set of processes required for the solving.
An objective $P \in \Obj$ is solvable if the abstractions of bounce sequences $\aBS(P) \in \Sol$ (\pref{def:aBS}) can be reached (\pref{eq:ESol1}), thus leading to several required processes (\pref{eq:ESol2}).
If $a \in \components$, the reachability of one of its process $a_i$ is approximated by the ability to solve all objectives $\PHobjp{a}{j}{i} \in \Obj$ for all $a_j$ in the initial context (\pref{eq:EReq});
if $a \in \cs$, the reachability of $a_i$ is simply solved by the set of processes $\csState(a_i)$ (\pref{def:csState}) that it represents (\pref{eq:EPrio}).
The solving of an objective $P$ may require a process of $\PHsort(P)$, \ie $\gCont(\PHsort(P), P) \neq \emptyset$ (\pref{def:maxCont}); in this case, $P$ is re-targeted (\pref{eq:ECont}).
\pref{eq:Vw}, \eqref{eq:Vproc} and~\eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Finally, as the active process of every sort may evolve, $\cwB$ is obtained by iteratively saturating with every process it contains,
\ie by overriding its initial context $\ctx$ by $\allprocs(\V, \E)$, defined by:
\[\allprocs(\V, \E) = (V \cap \Proc) \cup \{ \PHtarget(P), \PHbounce(P) \mid P \in \V \cap \Obj \} \enspace.\]

\begin{definition}
\label{def:glc}
  The graph of local causality $\cwB \DEF (\Bv, \Be)$ is defined as: $\cwB \DEF \lfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs(\myB)}}$,
  where $\myB \DEF (\cwV, \cwE)$ is the smallest graph with
  $\cwV \subseteq \Proc \cup \Obj \cup \Sol$ and $\cwE \subseteq \cwV \times \cwV$
  so that:
  \begin{align}
    \w &\subseteq \cwV \label{eq:Vw} \\
    P \in \cwVObj &\Rightarrow \PHbounce(P) \in \cwV \label{eq:Vproc} \\
    (x, y) \in \cwE &\Rightarrow y \in \cwV \label{eq:VE} \\
    P \in \cwVObj \wedge ps \in \modMF{\aBS}(P) &\Rightarrow (P, ps) \in \cwE \label{eq:ESol1} \\
    ps \in \cwVSol \wedge a_i \in ps &\Rightarrow (ps, a_i) \in \cwE \label{eq:ESol2} \\
    a \in \components \wedge a_i \in \cwVProc \wedge a_j \in \ctx &\Rightarrow (a_i, \PHobjp{a}{j}{i}) \in \cwE \label{eq:EReq} \\
    a \in \cs \wedge a_i \in \cwVProc \wedge ps \in \csState(a_i) &\Rightarrow (a_i, ps) \in \cwE \label{eq:EPrio} \\
    P \in \cwVObj \wedge q \in \gCont_\ctx(\PHsort(P), P) &\Rightarrow (P, \PHobj{q}{\PHbounce(P)}) \in \cwE \label{eq:ECont} \!
  \end{align}
\end{definition}

In the graph of local causality, an edge $(p, ps) \in \Proc \times \Sol$
is said to be coherent (\pref{def:coherent}) if none of the processes in $ps$ conflict with the children processes of $ps$.
Then, \pref{th:approxinf} gives a sufficient condition for the concretisation of a sequence of objectives in a given context,
which is derived immediately from the graph of local causality.
A proof of this theorem is given in \pref{suppl:demoapproxinf}.
\begin{definition}[Coherent edge]
\label{def:coherent}
  An edge $(x, y) \in \cwE$ is said to be coherent if and only if:
  $(x, y) \in \Be \cap (\Proc \times \Sol) \Rightarrow y$ has no children process $a_j \in \Bv \cap \Proc$ so that $\exists a_i \in y$, $a_i \neq a_j$.
\end{definition}

\begin{theorem}[Under-Approximation]
\label{th:approxinf}
Given a Process Hitting $(\PHs; \PHl; \PHa^{\langle 2 \rangle})$
that satisfies \pref{cr:bounded} and \pref{cr:compcs},
a context $\ctx$ and a sequence of objectives $\w$,
  if the graph $\cwB$ contains no cycle,
  all objectives have at least one solution
  and all edges are coherent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

Computing the graph of local causality is polynomial in the number of sorts in $\PH$ and exponential in the number of processes in one sort.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
Furthermore, it is possible to compute only a subset of $\V \cap \Sol$;
in this case, the overall method turns out to be exponential in the number of solutions to each objective.
Our method can thus be considered as efficient compared to regular model-checking which is usually PSPACE-complete~\cite{Harel02}.



\begin{example}
  Let $\PH' = (\PHs, \PHl, \PHh'^{\langle 1 \rangle})$ be the “merged” version of the PH in \pref{fig:ph-livelock}, that is: $\PHh'^{\langle 1 \rangle} = \PHh^{(1)} \cup \PHh^{(2)}$,
  which is how it would have been represented in the semantics without priorities.
  Due to spurious behaviours inherent to the cooperative sorts in this semantics, 
  the original under-approximation developed in~\cite{PMR12-MSCS} concludes that $c_1$ is reachable in $\PH'$ from $\ctx = \PHstate{a_1, b_0, c_0, ab_{10}}$.
  
  Such unwanted behaviours are palliated by the semantics of PH with priorities proposed in this paper.
  Indeed, the under-approximation given in \pref{th:approxinf} does not conclude regarding the reachability of $c_1$,
  as one of the edges of the resulting graph of local causality is not coherent (\pref{def:coherent}),
  as shown in in \pref{fig:sa-livelock}.
  (However, from the inconclusiveness of \pref{th:approxinf}, one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  
  However, if $\PHhit{a_0}{b_0}{b_1}$ and $\PHhit{b_0}{a_0}{a_1}$ are replaced by the auto-actions
  $\PHhit{a_0}{a_0}{a_1}$ and $\PHhit{b_0}{b_0}{b_1}$,
  then \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[AprocPrio,below of=c01s] (ab11) {$ab_{11}$};
    \node[AsolPrio,below of=ab11] (ab11s) {};

    \node[Aproc,below left of=ab11s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below right of=ab11s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge[aSPrio] (ab11s)
    (ab11s) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a00) edge (a00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (a0)
    (b11) edge (b11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The graph of local causality of the PH model in \pref{fig:ph-livelock}
    for the objective $\w = \PHobj{c_0}{c_1}$ and the initial context $\ctx = \PHstate{a_1, b_0, c_0, ab_{10}}$.
    Rectangular nodes containing a single process are elements in $\Proc$,
    borderless nodes containing a couple of processes are elements in $\Obj$
    and circle nodes are elements in $\Sol$.
    \pref{th:approxinf} is inconclusive on this example as edge $(ab_{11}, \{ a_1, b_1 \}) \in \Proc \times \Sol$ (here represented with a double line) is not coherent (\pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a child of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$ (and the same also stands for $b_0$).
  }
\end{figure}
\end{example}


\subsection{Reachability of a state}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The reachability property studied so far concerns a single process at a time.
However, we remark that the reachability of a partial or global state can be
addressed with the very same analysis by introducing a dedicated cooperative
sort in the scope of the PH semantics with $2$ classes of priorities.

Indeed, let $\PH = (\PHs, \PHl, (\PHh^{(1)}, \PHh^{(2)}))$ be a PH and suppose that we want to study the reachability of a state $s \in \PHl$.
Let $\PH' = (\PHs', \PHl', (\PHh'^{(1)}, \PHh'^{(2)}))$
with: $\PHs' = \PHs \cup \{ \total, \reach \}$ and $\PHl' = \PHl \times \PHl_\total \times \PHl_\reach$,
where $\total$ is a cooperative sort on all components $\components$ of $\PH$ (thus $\PHl_\total = \underset{a \in \components}{\times} \PHl_a$)
and $\reach$ is a component with $\PHl_\reach = \{ \reach_0, \reach_1 \}$;
furthermore, $\PHh'^{(1)}$ is the set $\PHh^{(1)}$ completed with all actions updating the cooperative sort $\total$,
and $\PHh'^{(2)} = \PHh^{(2)} \cup \{ \PHhit{\pfp_s(\total)}{\reach_0}{\reach_1} \}$.

Given an initial context $\ctx$, the reachability of $s$ in $\PH$ is equivalent to the concretisation of $\PHobjp{\reach}{0}{1}$ in $\PH'$ from the initial context $\ctx \cup \{ \reach_0 \}$ (the initial state of $\total$ does not matter), which can be efficiently under-approximated using \pref{th:approxinf}.
Indeed, the additional action $\PHhit{\pfp_s(\total)}{\reach_0}{\reach_1}$ in $\PHh'^{(2)}$ allows to conclude on the reachability of process $\pfp_s(\total)$, that is, on the reachability of the state $s$ (considering only the components).

It is also possible to compute the reachability of a set of states $S \subseteq \PHl$ by creating several actions $\PHhit{\total_s}{\reach_0}{\reach_1}$ in $\PHh^{(2)}$ for each state $s \in S$,
or on a sub-state $s \in \PHsubl[\PHl]_S$ of a set of components $S \subset \PHs$ by adapting the sort $\total$ with: $\PHl_\total = \PHsubl[\PHl]_S$


\subsection{Sequential under-approximation}
\label{ssec:ordered-ua}

In this section, we briefly explain an alternative sufficient condition that
progressively takes into account the successive objectives, instead of
considering all of them at a time, as it is done in the previous sections.
Because objectives are taken into account individually, such an approach
considers only a subset of scenarios.
However, because each iteration focuses on a smaller part of the network, this
sequential under-approximation may be more conclusive.

Let us define a sequence of objectives $\w=\obj{a_i}{a_j}\concat\w'$ with
$a_i\neq a_j$ and a state $s\in \PHl$ with $\get{s}{a}=a_i$.
One can remark that any scenario reaching $a_j$ necessarily includes one of the
bounce sequences in $\BS(\obj{a_i}{a_j})$, and, in particular,
any minimal scenario reaching $a_j$ ends in a state where $a_j$ is present but
also the hitter of the last bounce of one bounce sequence in $\BS(\obj{a_i}{a_j})$.
If such hitter $b_k$ is in a cooperative sort $b\in\cs$, it also means that one of the sub-states
in $\csState(b_k)$ is included in the ending state.
\pref{def:lastprocs} defines $\lastprocs(\obj{a_i}{a_j})$ as the set of set of
processes that may be present just after reaching $a_j$.

From \pref{th:approxinf}, we can deduce that
for any scenario $\delta$ in $\uconcr(P)$,
there exists a set of processes $ps\in\lastprocs(P)$
such that $ps \subset (s\play\delta)$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
with $\ctx'=\ctx\Cap\procs(\mycwB{\ctx}{P})$,
there exists a scenario $\delta'$ concretising $\w'$ from the
state $(s\play\delta)$.
Therefore, the scenario $\delta\concat\delta'$ concretises
$\w$.

\begin{definition}[$\lastprocs$]
\label{def:lastprocs}
Given an objective $\obj{a_i}{a_j}$, $\lastprocs:
\Obj\to\powerset(\powerset(\Proc))$ is
defined as the largest set such that, $\forall lps\in\lastprocs(\obj{a_i}{a_j})$, 
$lps\in\powerset(\Proc)$,
\begin{enumerate}
\item $a_j\in lps$;
\item $\exists\zeta\in\BS(\obj{a_i}{a_j}),
    \PHsort(\hitter{\zeta_{\card\zeta}}) \neq 
		\PHsort(\bounce{\zeta_{\card\zeta}})
		 \Rightarrow
		  \hitter{\zeta_{\card\zeta}}\in lps$;
\item $\forall b_j\in lps, b\in\cs, \exists ps\in\csState(b_j), ps\subset lps$;
\item $\nexists lps'\in\lastprocs(\obj{a_i}{a_j}), lps'\subset lps \wedge
									lps'\neq lps$.
\end{enumerate}
\end{definition}

\begin{theorem}[Sequential under-approximation]
\label{thm:ordered-ua}
Given a Process Hitting $(\PHs; \PHl; \PHa^{\langle 2 \rangle})$
that satisfies \pref{cr:bounded} and \pref{cr:compcs},
a context $\ctx$ and an objective sequence $\w =
P\concat\w'\in\OS$,
$\uconcr(P)\neq\emptyset \wedge
	\forall ps \in\lastprocs(P),
	\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset
	\Longrightarrow \uconcr(\w)\neq\emptyset$,
where $\ctx' = \ctx\Cap\procs(\mycwB{\ctx}{P})$.
\end{theorem}
\begin{proof}
If $\uconcr(P)\neq\emptyset$,
for all $s\in \PHl, s\subset\ctx$,
there exists a scenario $\delta\in\uconcr(P)\cap\Sce(s)$;
from \pref{def:lastprocs} and proof of \pref{th:approxinf},
$\exists ps\in\lastprocs(P)$ such that
$(s\play\delta)\subset\ctx'\Cap ps$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
there exists a scenario $\delta'\in\muconcr_{\ctx'\Cap ps}(\w')$ such that
$\delta'\in\Sce(s\play\delta)$.
Hence, $\delta\concat\delta'$ is a scenario playable in $s$.
Therefore, for all $s\in \PHl, s\subset\ctx$, there exists a scenario
concretising $\w$.
Hence, $\uconcr(\w)\neq\emptyset$.
\end{proof}



\modMF{
\subsection{Extraction of the scenario}
}

\modMF{
This section gives a recursive method to find a scenario that concretizes
a given objective sequence $\w \in \OS$.
All the definitions above are well-defined provided that
$\uconcr(\w)\neq\emptyset$,
which can be demonstrated by \pref{thm:ordered-ua} or \pref{th:approxinf}.
The justification of these definitions can be found by analysing the demonstrations
of these theorems.
}

\newcommand{\res}{\mathbf{res}}
\newcommand{\osres}{\mathbf{OSres}}
\newcommand{\autoBS}{\mathbf{autoBS}}
\newcommand{\rec}{\mathbf{rec}}
\newcommand{\thisobj}[1]{P_{#1}}
\newcommand{\thisseq}[1]{\Theta_{#1}}

\modMF{
For all $\w \in \OS$:
\[
  \osres_s(\w) = \res_s(\w_1) \concat
    \osres_{s \play \res_s(\w_1)}(\w_2 \concat \dots \concat \w_{\card{\w}})
\]
with $\osres_s(\varepsilon) = \varepsilon$.
For all $P \in \Obj$:
\[\res_s(P) =
  \begin{cases}
    \varepsilon
      & \text{if } \target{P} = \bounce{P} \\
%     pickone(\autoBS(P))
%       & \text{if } \aBS(P) = \{ \emptyset \} \\
    \osres_s(P^Q \concat Q)
      & \text{if } \exists Q \in \Obj, (P, Q) \in \Bee{\Obj}{\Obj} \\
    \rec_s(\zeta)
      & \text{otherwise, with } \zeta \in \BS(P)
  \end{cases}
\]
where:
\[
  \autoBS(P) = \{ \zeta \in \BS(P) \mid \forall i \in \indexes{\zeta}, \PHsort(\hitter{\zeta_i}) = \PHsort(\target{\zeta_i}) = \PHsort(P) \}
\]
\[
  P^Q = \PHobj{\PHtarget(P)}{\PHtarget(Q)}
\]
\[
  \rec_s(\zeta) = \thisseq{\zeta_1} \play
    \rec_{s \play \thisseq{\zeta_1}}
    (\zeta_2 \concat \dots \concat \zeta_{\card{\zeta}})
\]
with:
\[
  \thisseq{h} = \res_s(\thisobj{h}) \play
    \delta^{upd}_{s \play \res_s(\thisobj{h})} \play h
\]
\[
  \thisobj{h} = \PHobj{\PHget{s}{\PHsort(\hitter{h})}}{\hitter{h}}
\]
and $\delta^{upd}_{s'}$ is a scenario of actions in $\PHh^{(1)}$ that updates
all cooperative sorts from state $s'$.
Such a scenario always exists given \pref{lem:update},
and it can be built, starting from $s'$
by iteratively putting arbitrary prioritized actions into a sequence
until no more prioritized action is playable.
Indeed, the order of the actions do not matter and the final state will
always be $\update(s')$.
}

\todo{À terminer et gluer}
