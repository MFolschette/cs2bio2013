\section{Static analysis}\label{sec:sa}

\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  The reachability of a process $a_j$ prof a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj = \{ \PHobj{a_i}{a_j} \mid a \in \PHs \wedge (a_i, a_j) \in \PHl_a^2 \}$.
  For an objective $P \in \Obj$, where $P = \PHobj{a_i}{a_j}$, $\PHsort(P) = a$, $\PHtarget(P)=a_i$, $\PHbounce(P)=a_j$.
  An objective $P$ is \emph{trivial} is $\PHtarget(P)=\PHbounce(P)$.
\end{definition}

\begin{definition}[Context $\ctx$ ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}

For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$, and
$ps \in \powerset(\Proc), ps \subseteq \ctx \Leftrightarrow \forall a_i \in ps, a_i \in \ctx$.
%The override of a context $\ctx$ by a set of processes $ps$ is noted $\ctx \Cap ps$ (\defref{ctxcap}).
%Par exemple, $\state{a_1,a_2,b_1,c_1}\Cap\{ a_3, b_2, b_3 \} = \state{a_3,b_2,b_3,c_1}$.
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \mapsto \Ctx$]
\label{def:ctxcap}
  For a given context $\ctx\in\Ctx$ and a set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} =
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}

A scenario $\delta \in \Sce$ is \emph{playable} in a context $\ctx$ if and only if $\supp(\delta) \subseteq \ctx$. 
The play of $\delta$ in $\ctx$ is denoted $\ctx \PHplay \delta$ where $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$.

\begin{definition}[Objective sequence ($\OS$)]
\label{def:OS}
  An \emph{objective sequence} is a sequence $\w = P_1 \concat \dots \concat P_{|\w|}$,
  where $\forall n \in \indexes{\w}, \w_n \in \Obj$ and $a_i = \PHtarget(\w_n) \Rightarrow \last_a(\w_{1..n-1}) \in \{ \varnothing, a_i \}$.
  The set of all objective sequences is denoted by $\OS$.
  The definitions of $\last_a$ \todo{À définir}, $\first_a$ \todo{À définir}, $\supp$ \todo{À définir} and $\ceil$ \todo{À définir}
  are simply derived by omitting the case of hitters.
\end{definition}

\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) = \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  Obviously, $\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$.
\end{definition}

\begin{definition}[$\aBS:\Obj \mapsto \powerset(\Proc)$]
\label{def:aBS}
  \[
    \aBS(P) = \{ \abstr{\zeta} \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  where $\abstr{\zeta} = \{ \PHhitter(\zeta_n) \mid  n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$.
\end{definition}



\subsection{Under-approximation}

\begin{definition}[$\concr: \OS \mapsto \powerset(\Sce)$]
\label{def:concr}
  For a given $\w \in \OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the context $\ctx$:
  \begin{align*}
    \concr(\w) = \{ \delta \in \Sce \mid & (\w^\vartriangle = \emptyseq \wedge \delta = \emptyseq) 
      \vee (\w^\vartriangle \neq \emptyseq \wedge \supp(\delta) \subseteq \ctx
    \\ &
      \wedge \exists \phi:\indexes{\w} \mapsto \indexes{\delta}, (\forall n, m \in \indexes{\w}, n < m \Leftrightarrow \phi(n) \leq \phi(m)) 
    \\ &
      \wedge \forall n \in \indexes{\w}, \PHbounce(\w_n) \in \ctx \PHplay \delta_{1..\phi(n)})
    \}
    \enspace,
  \end{align*}
  where $\omega^\vartriangle$ refers to the sequence of objectives $\omega$ where the trivial objectives have been removed.
\end{definition}
%
\begin{definition}[$\concr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:concr-set}
  $\concr(\W) = \{ \delta \in \concr(\w) \mid \w \in \W \} \enspace.$
\end{definition}

\begin{definition}[$\uconcr: \OS \mapsto \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \uconcr(\w) = 
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \supp(\delta) \subseteq s \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{theorem}
\label{th:uconcr-ctx}
  $\ctx' \subseteq \ctx \wedge \uconcr(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx'}(\w) \neq \emptyset \enspace.$
\end{theorem}
% 
\begin{definition}[$\uconcr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:uconcr-set}
  $\uconcr(\Omega) = \{ \delta \in \uconcr(\w) \mid \w \in \Omega\}$
\end{definition}




%%% N'est plus utile (?)
%Plus haute priorité :
%$$\forall a \in \PHs, \priomax(a) = \max_{h \in \PHh, \PHtarget(h) = a}(\prio(h))$$

%%% N'est plus utile (?)
%Processus possibles :
%\begin{align*}
%\procs((\cwSol,\cwReq,\cwCont)) = \{ p \in \PHproc &\mid \exists (P,ps) \in \cwSol, p \in ps
%\\ & \vee p = \PHtarget(P)
%\\ & \vee (P \neq \omega \Rightarrow p = \PHbounce(P)) \}
%%\\ & \vee \exists h \in \BS(P), (p = \PHhitter(h) \vee p = \PHbounce(h)) \}
%\end{align*}

Processus rencontrés :
\begin{align*}
&\allprocs((\cwSol,\cwReq,\cwCont,\cwSat)) = \{ p \in \PHproc \mid \exists (P,ps) \in \cwSol, p \in ps \\
  &\qquad\qquad \vee p = \PHtarget(P) \vee \exists h \in \BS(P), (p = \PHhitter(h) \vee p = \PHbounce(h)) \\
  &\qquad\qquad \vee \exists(Q, \PHobj{p}{\PHbounce(Q)} \in \cwPrioCont \}
\end{align*}

\subsection{Local fixed points / possible bounces}

%%% Pas utile
%Points fixes possibles : pour toute sorte $a$ et tout contexte partiel $\ctx$ sur $V^n(a)$:
%\begin{align*}
%  \pfp_\ctx: \PHs &\rightarrow \wp(\PHproc) \\
%  a &\mapsto \{ s \in \underset{b \in V^n(a)}{\times} \PHl_b \mid \text{$s$ est accessible depuis $\ctx$ et aucune action n'y est jouable} \}
%\end{align*}

\begin{comment}
Points fixes possibles : pour toute sorte $a$ et tout contexte $\ctx$:
\begin{align*}
  \pfp_\ctx: \PHs &\rightarrow \wp(\PHproc) \\
  a &\mapsto \{ s \PHplay \delta \in \restriction{\PHl}{\Vs(a)} \mid s \in \restriction{\ctx}{\Vs(a)} \wedge \delta \in \restriction{\Sce}{\Vs(a)} \\
  &\qquad\qquad\qquad\qquad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \Vh(a), \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
  %\text{$h$ n'est pas jouable dans $s \PHplay \delta$} \}
\end{align*}
%
Processus rencontrés comme résultats d'un point fixe :
\begin{align*}
\pfpprocs_\ctx(a) = \{ \PHget{s}{a} \mid s \in \pfp_\ctx(a) \}
\end{align*}
%
Le nouvel ensemble de processus à prendre en compte à chaque itération du pppf :
\begin{align*}
\newprocs_\ctx(\myB) = %\allprocs(\myB) \cup \bigcup_{a \in \PHs} \pfpprocs_{\allprocs(\myB)}(a)
  \{ a_k \in \PHproc &\mid a_k \in \allprocs(\myB) \vee \\
  & (a_i, \PHobjp{a}{j}{i}) \in \cwReq \wedge a_k \in \pfpprocs_{\ctx \Cap \allprocs(\myB)}(a) \wedge \\
  & \quad (\exists (P, ps) \in \cwSol, a_i \in ps \wedge \prio(\PHsort(P)) > \prio(a) \\
  & \quad \vee \exists (\PHobjp{a}{j}{i}, ps) \in \cwSol, \exists p \in ps, \exists (p, P) \in \cwReq,\\
  & \qquad \text{$P$ is not trivial} \wedge \prio(\PHsort(P)) > \prio(a) \}
\end{align*}
\end{comment}

\begin{comment}
=================
%
Nouvelle version des états stables possibles: pour tout contexte $\ctx$:
\begin{align*}
  \pfp_\ctx = \{ s \PHplay \delta \in \PHl &\mid s \in \ctx \wedge \delta \in \restriction{\Sce}{k-1} \\
  & \qquad \wedge \forall \PHhit{b_i}{c_j}{c_k} \in \restriction{\PHh}{k-1}, \PHget{(s \PHplay \delta)}{b} \neq b_i \vee \PHget{(s \PHplay \delta)}{c} \neq c_j \}
  %\text{$h$ n'est pas jouable dans $s \PHplay \delta$} \}
\end{align*}
%
Processus rencontrés comme résultats d'un état stable :
\begin{align*}
\pfpprocs_\ctx = \{ a_i \in \PHproc \mid \exists s \in \pfp_\ctx, a_i \in s \}
\end{align*}
%
Nouvel ensemble $\newprocs$ :
\begin{align*}
\newprocs_\ctx(\myB) = \allprocs(\myB) \cup \pfpprocs_\ctx
\end{align*}
\end{comment}

\begin{comment}
==========================

Bonds possibles :
\begin{align*}
\bounceprocs_\ctx = \{ a_i \in \PHproc \mid \exists s \in \ctx, \exists \delta \in \restriction{\Sce}{k-1}, a_i \in (s \PHplay \delta) \}
\end{align*}
\end{comment}

Mise à jour de l'état initial :
\begin{align*}
  \update(\ctx) = \ctx \Cap \bigcup_{a \in CS} \pfp_{\restriction{\ctx}{\Vs(a) \cup \{ a \}}}(a)
\end{align*}

%%% N'est plus adapté
%Points fixes possibles sur un ensemble de sortes :
%\begin{align*}
%  \pfp: \mathbb{A} &\rightarrow \wp(\PHproc) \\
%  \myB &\mapsto \bigcup_{a \in A} \pfp_{\allprocs(\myB)}(a)
%\end{align*}

\begin{comment}
Séquences de bonds abstraites :
$$\BS^\wedge(P) = \{ \zeta^\wedge \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \zeta'^\wedge \subsetneq \zeta^\wedge \}$$
where $\zeta^\wedge = (\zeta^\wedge_A, \zeta^\wedge_B, \zeta^\wedge_{max})$ with:
\begin{itemize}
  \item $\zeta^\wedge_A = \{ \PHhitter(\zeta_n) \mid n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$ : ens. des requis d'autres sortes (frappeurs)
  \item $\zeta^\wedge_B = \{ \PHhitter(\zeta_n) \mid n \in \indexes{\zeta} \} \cup \{ \PHtarget(\zeta_n) \mid n \in \indexes{\zeta} \}$ : ens. des processus nécessaires (à ne pas perturber)
  \item $\zeta^\wedge_{max} = \max_{n \in \indexes{\zeta}}(\prio(\zeta_n))$ : plus faible priorité
\end{itemize}
\end{comment}

\subsection{Abstract structure}
%Séquences de bonds abstraites :
%$$\BS^\wedge(P) = \{ \zeta^\wedge \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \zeta'^\wedge \subsetneq \zeta^\wedge \}$$
%where:
%$$\zeta^\wedge = \{ \PHhitter(\zeta_n) \mid n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$$

\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \mapsto \powerset(\Proc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) = 
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:aS}
  The abstract structure $\cwB=(\Breq,\Bsol,\Bcont,\Bsat)$ is defined as
  $\cwB = \sfp{\aB^\w_{\update(\ctx)}}{\myB}{\aB^\w_{\ctx \Cap \allprocs_\ctx(\myB)}}$,\\
  with $\myB=(\myreq,\mysol,\mycont,\mysat)$:
  \begin{align*}
    \myreq &= \{ (a_i,\PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid
      a_j \in \PHget{\ctx}{a} \\ % \vee a_j \in \pfpprocs_\ctx(a) \\
      & \qquad \wedge (\exists (P,ps) \in \mysol, a_i \in ps \vee \exists n \in \indexes{\w}, \PHbounce(\w_n)=a_i) \}
    \\
    \mysol &\subseteq \{ (P,ps) \in \Obj \times \powerset(\PHproc) \mid
            \exists (a_i, P) \in \myreq \wedge ps \in \aBS(P) \\
      & \qquad\qquad \vee \exists (Q, P) \in \mycont \wedge ps \in \aBS(P) \}
    \\
    \mycont & = \{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid
      \exists (P, ps) \in \mysol \\
      & \qquad\qquad \wedge q \in \gCont_\ctx(\PHsort(P),P) \}
    \\
    \mysat & = \{ (\PHobjp{a}{j}{i}, \PHobjp{a}{k}{i}) \in \Obj \times \Obj \mid
      a_j \neq a_k \wedge a_k \in \pfp_\ctx(a) \}
%%% Version états stables locaux
%    \mysat & = \{ (\PHobjp{a}{j}{i}, \PHobjp{a}{k}{i}) \in \Obj \times \Obj \mid
%      \exists (a_i, \PHobjp{a}{j}{i}) \in \myreq, \\
%      & \qquad\qquad a_j \neq a_k \wedge a_k \in \pfpprocs_\ctx(a) \\
%      & \qquad\qquad \wedge (\exists (P, ps) \in \mysol, a_i \in ps \wedge \prio(\PHsort(P)) > \prio(a) \\
%      & \qquad\qquad\qquad \vee \exists (\PHobjp{a}{j}{i}, ps) \in \mysol, \exists p \in ps, \exists (p, P) \in \myreq,\\
%      & \qquad\qquad\qquad \text{$P$ is not trivial} \wedge \prio(\PHsort(P)) > \prio(a) \}
  \end{align*}
\end{definition}

\begin{theorem}[Approximation inf.]\label{th:approxinf}
If the graph $\cwB$ contains no cycle and all objectives have at least one solution, then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

\begin{proof}
We note $max\ctx = \update(\ctx) \Cap \allprocs(\cwB)$ the context supported by $\cwB$.
As there is no cycle in $\cwB$, we show by induction that $\forall s\in L, s\subseteq max\ctx$, 
for all objective $P$ in $\cwB$ so that $\PHtarget(P) \in s$,
$\exists \delta \in \muconcr_s(P)$.% and $\ceil(\delta) \subseteq max\ctx$.

\begin{itemize}
  \item If $(P, \emptyset) \in \Bsol$, either $\PHtarget(P) = \PHbounce(P)$ and $\delta = \emptyseq$,
    or $\forall \zeta \in \BS(P), \zeta \in \Sce \wedge \PHsort(\zeta) = \{ \PHsort(P) \}$ and $\delta$ is given by \pref{th:autohits}.

  \item Suppose all children objectives of $P$ are concretizable.
  \begin{itemize}
    \item If $\exists (P, Q) \in \Bcont$, then by hypothesis,
      $\muconcr_{s}(\obj{\PHtarget(P)}{\PHtarget(Q)} \concat Q) \neq \emptyset$, thus
      $\muconcr_{s}(P) \neq \emptyset$.
    \item If $\exists (P, Q) \in \Bpriocont$, then by hypothesis,
      $\muconcr_{s}(\obj{\PHtarget(P)}{\PHtarget(Q)} \concat Q) \neq \emptyset$, thus
      $\muconcr_{s}(P) \neq \emptyset$.
    \item Else, by \pref{def:maxCont}, the concretizations of the children of $P$ require no process of sort $\PHsort(P)$.
      Furthermore, there exists $\zeta \in \BS(P)$ so that $(P, \aZ) \in \Bsol$.
      We build recursively a scenario $\delta$. Let $m = |\indexes{\zeta}|$.
%      \todo{Idée avec les nouvelles defs : au rang 0, on se replace sur un processus de $\pfp$. Au rang n, il existe par saturation un objectif adéquat qui “reprend” la progression.}
      \begin{itemize}
%        \item[*] Let $\zeta_1 = \PHhit{b_i}{a_j}{a_k}$. By hypothesis, $\exists \delta_1 \in \muconcr_s(\PHobj{\any}{b_i}), \PHget{s \PHplay \delta_1}{a} \in \pfp_s(a)$.
%          If $\PHget{s \PHplay \delta_1}{a} \neq a_j$, then by construction of $\cwB$, $(\PHobj{a_j}{a_k}, \PHobj{\PHget{s \PHplay \delta_1}{a}}{a_k}) \in \Bsat$.
%          By hypothesis, $\muconcr_s(\PHobj{\any}{a_k}) \neq \emptyset$.
%          If $\PHget{s \PHplay \delta_1}{a} = a_j$, then from \pref{th:vplay}, $\exists \delta'_1 \in \Sce$, $\zeta_1$ can be played in $s \PHplay \delta_1 \PHplay \delta'_1$.
        \item[*] For $n \in \indexes{\zeta}$, let $s_n = s \PHplay \delta_1 \PHplay \delta'_1 \PHplay \delta''_1 \PHplay \zeta_1 \PHplay \dots \PHplay \delta_{n-1} \PHplay \delta'_{n-1} \PHplay \delta''_{n-1} \PHplay \zeta_{n-1}$ (or $s_1 = s$),
          and $\zeta_n = \PHhit{b_i}{a_j}{a_k}$.
          By hypothesis, $\exists \delta_n \in \muconcr_{s_n}(\PHobj{\any}{b_i})$.
          If $a \in \cs$, then $\prio(\zeta_n) = 1$ and $\zeta_n$ can be played in $s_n \PHplay \delta_n$ (\ie $\delta'_n = \delta''_n = \varepsilon$).
          If $a \notin \cs$ and $b \in \cs$, then there exists a scenario $\delta'_n$ so that $b_i \in \pfp_{s_n \PHplay \delta_n \PHplay \delta'_n}(b)$ (because of the $\Bpriocont$ relation).
          Then, by \pref{th:hcscomp}, there is a scenario $\delta'' \in \restriction{\Sce}{1}$ so that $\zeta_n$ is playable in $s_n \PHplay \delta_n \PHplay \delta'_n \PHplay \delta''_n$.
          Finally, if $a,b \in \components$, then by \pref{th:hcompcomp}, there is a scenario $\delta'' \in \restriction{\Sce}{1}$ so that $\zeta_n$ is playable in $s_n \PHplay \delta_n \PHplay \delta''_n$ (\ie $\delta'_n = \varepsilon$).
      \end{itemize}
      Thus, $\delta = \delta_m \in \muconcr_s(P)$. % and $\ceil(\delta) \subseteq max\ctx$.
  \end{itemize}
\end{itemize}

Finally, as $\muconcr_{max\ctx}(\w) \neq \emptyset$, $\uconcr(\w) \neq \emptyset$ (\pref{th:uconcr-ctx}).
\end{proof}



\begin{comment}
Voisinage :
\begin{equation*}
\begin{split}
    V: \wp(\PHproc) \times \segm{1}{k} &\rightarrow \wp(\PHh) \\
    (ps; m) &\mapsto \sfp{\PHh^{(m)+}_{cibles}(ps)}{hs}{\PHh^{(m)+)}_{bonds}(\widehat{B}(hs)) \cup hs)}
  \end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}
    \widehat{B}: \wp(\PHh) &\rightarrow \wp(\PHproc) \\
    hs &\mapsto \{ \PHhitter(h) \mid h \in hs \} \cup \{ \PHtarget(h) \mid h \in hs \}
  \end{split}
\end{equation*}
\begin{equation*}
\begin{split}
    \PHh^{(m)+}_{\mathsf{ref}}: \wp(\PHproc) &\rightarrow \wp(\PHh) \quad,\quad m \in \segm{0}{k} \text{ and } \mathsf{ref} \in \{ \PHhitter, \PHtarget, \PHbounce \} \\
    ps &\mapsto \{ h \in \PHh \mid \mathsf{ref}(h) \in ps \wedge \prio(h) \leq m \}
  \end{split}
\end{equation*}
\end{comment}



\begin{figure}
  \centering
  \begin{tikzpicture}[aS,node distance=1.5cm]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};
    
    \node[Aproc,below of=c01s] (ab11) {$ab_{11}$};
    \node[Aobj,below right of=ab11] (ab0111) {$\PHobj{ab_{01}}{ab_{11}}$};
    \node[Asol,below of=ab0111] (ab0111s) {};
    \node[Aobj,below of=ab11,node distance=2.5cm] (ab0011) {$\PHobj{ab_{00}}{ab_{11}}$};
    \node[Asol,below of=ab0011] (ab0011s) {};
    \node[Aobj,below left of=ab11] (ab1011) {$\PHobj{ab_{10}}{ab_{11}}$};
    \node[Asol,below of=ab1011] (ab1011s) {};

    \node[Aproc,below of=ab0111s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below right of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below right of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below of=ab1011s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge (ab0011) edge (ab0111) edge (ab1011)
    (ab0011) edge (ab0011s)
    (ab1011) edge (ab1011s)
    (ab0111) edge (ab0111s)

    (ab0011s) edge (a1) edge (b1)
    (ab1011s) edge (b1)
    (ab0111s) edge (a1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10)
    (a10) edge (a10s)
    
    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01)
    (b01) edge (b01s)
    (b01s) edge (a0)
    ;
    \path
    (ab0011) edge[double] (ab0111)
    (ab0011) edge[double,bend right=10] (ab1011)
    (ab1011) edge[double,bend right=10] (ab0011)
    (ab0111) edge[double,bend right=10] (ab1011)
    (ab1011) edge[double,bend right=10] (ab0111)
    ;
    \end{tikzpicture}
  \label{fig:sa-livelock}
  \caption{The local causality graph of the PH in \pref{fig:ph-livelock}.}
\end{figure}



\begin{comment}
\begin{figure}
  \centering
  \begin{tikzpicture}[aS,node distance=1.5cm]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,right of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,right of=c01] (c01s) {};
    \node[Aproc,right of=c01s] (b1) {$b_1$};
    \node[Aobj,right of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,right of=b11] (b11s) {};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Anos,right of=b01] (b01nos) {$\bottom$};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (b1)
    (b1) edge (b11) edge (b01)
    (b11) edge (b11s)
    ;
  \end{tikzpicture}
  \label{fig:sa-conca}
  \caption{The local causality graph of the PH in \pref{fig:ph-conca}.}
\end{figure}



\begin{figure}
  \centering
  \begin{tikzpicture}[aS,node distance=1.5cm]
    \node[Aproc] (c2) {$c_2$};
    \node[Aobj,right of=c2] (c12) {$\PHobj{c_1}{c_2}$};
    \node[Asol,right of=c12] (c12s) {};
    \node[Aproc,right of=c12s] (b1) {$b_1$};
    \node[Aobj,right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,right of=b01] (b01s) {};
    \node[Aproc,right of=b01s] (a1) {$a_1$};
    \node[Aobj,right of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,right of=a11] (a11s) {};

    \node[Aobj,above right of=c2] (c22) {$\PHobj{c_2}{c_2}$};
    \node[Asol,right of=c22] (c22s) {};
    \node[Aobj,below right of=c2] (c02) {$\PHobj{c_0}{c_2}$};
    \node[Anos,right of=c02] (c02nos) {$\bottom$};

    \path
    (c2) edge (c12) edge (c22) edge (c02)
    (c22) edge (c22s)
    (c12) edge (c12s)
    (c12s) edge (b1)
    (b1) edge (b01)
    (b01) edge (b01s)
    (b01s) edge (a1)
    (a1) edge (a11)
    (a11) edge (a11s)
    ;
  \end{tikzpicture}
  \label{fig:sa-concb}
  \caption{The local causality graph of the PH in \pref{fig:ph-concb}.}
\end{figure}
\end{comment}





