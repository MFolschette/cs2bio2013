% vi:spell spelllang=en:
\section{Under-approximation of Reachability}\label{sec:sa}

\modLP{%
We present a static analysis that takes as input an AAN
$\PH = (\PHs; \PHl; \PHa)$,
an initial state, and a local state of an automata in $\PHs$, for identifying sufficient conditions
that ensure the existence of a scenario starting from the initial state and leading to a state
where the given local state is present.}

A classical approach for determining if a local state of an automaton can be reach from a
given initial state is to build sequences of transitions from the initial state until a state
containing the given local state is reached.
This is essentially what model-checkers do, and the complexity of such analysis (PSPACE-complete
\cite{Harel02}) makes it intractable on large systems, even with advanced symbolic approaches
\cite{PMR12-MSCS}.

Our approach relies on abstractions of scenarios that have been introduced in
\cite{PMR12-MSCS} for the static analysis of reachability in the Process Hitting framework,
a particular sub-class of AAN (see the Remark at the end of the previous section).
In this paper, we generalize the static analysis for the case of the under-approximation of
reachability in any AAN.

\todo{outline}

\subsection{Abstractions for Scenarios}
\label{ssec:abstr-sce}

The approach presented in this section is based on two complementary notions,
the \emph{objectives} and their \emph{local causality},
that are intertwined in so-called \emph{Local Causality Graphs}.

\subsubsection{Objectives}

An \emph{objective} (\pref{def:obj}) denotes the reachability of a local state (e.g., $a_j$) of a given automaton $a$
from the initial local state of that automaton (e.g., $a_i$).
Such an objective is written $\PHobjp{a}{i}{j}$.
Successive objectives are described with objective sequences (\pref{def:obj}).

\begin{definition}[Objective ($\Obj$) \& Objective Sequence ($\OS$)]
\label{def:obj}
  If $a \in \components$, the reachability of a local state $a_j$ from a local state $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a \times \PHl_a \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) \DEF
  a$, $\PHtarget(P)\DEF a_i$, $\PHbounce(P)\DEF a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same automaton, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

We define the partial ordering relation $\ltw$ between two objective sequences (\pref{def:ltw}) as
follows:
$w\ltw w'$ if and only if there exists a mapping between all the objective bounces of $w'$ in $w$
that preserve the sequentiality.

\todo{support compatibility}

\begin{definition}[$\ltw \subset \OS\times\OS$]\label{def:ltw}
$\w\ltw\w'$ if and only if
$|\w|\geq|\w'|$ and
there exists a mapping $\phi: \indexes{\w'}\mapsto \indexes{\w}$ such that
$\forall n,m \in\indexes{\w'}, n<m \Leftrightarrow \phi(n)<\phi(m)$,
and
$\forall n\in\indexes{\w'}, \bounce{\w'_n}=\bounce{\w_{\phi(n)}}$
\end{definition}

\begin{example}
\[\obj{b_0}{b_1}\concat\obj{a_0}{a_1}\concat\obj{b_1}{b_2}
\ltw
\obj{a_0}{a_1}\concat\obj{b_0}{b_2}
\ltw
\obj{b_0}{b_2}\]
\[\obj{b_0}{b_1}\not\ltw\obj{b_0}{b_2}\]
\end{example}

An objective sequence can be seen as an abstract representation of a set of scenarios that describe
(part of) the successive state changes of the automata.
We denote by $\concr(\w)$ (\pref{def:concr}) the set of scenarios concretising an objective sequence
$\w$ in the state $s\in\PHs$.
It is essentially all the scenarios for which there exists a mapping from the bounces of each
objective to the bounce of an action in the scenario which preserve the sequential ordering.

\todo{compatibility of $\w$ with $s$}

\begin{definition}[$\concr: \OS \to \powerset(\Sce)$]\label{def:concr}
Given $\w\in\OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the
state $s$:
\begin{align*}
\concr(\w) \DEF \{ \delta\in\Sce(s)\mid & (\w^\vartriangle=\emptyseq \wedge
\delta=\emptyseq)  \vee (
\w^\vartriangle\neq \emptyseq\wedge
\\ &
 \wedge \exists \phi:\indexes{\w}\mapsto\indexes{\delta},
    (\forall n,m\in\indexes{\w}, n<m \Leftrightarrow \phi(n)\leq\phi(m))
\\ & \qquad
	\wedge \forall n\in\indexes{\w},
	  \bounce{\w_n} \in s\play\delta_{1..\phi(n)})
\}
\enspace,
\end{align*}
where $\omega^\vartriangle$ refers to the objective sequence $\omega$ where
trivial objectives have been removed.
The notation $\delta_{a..b}$ in the previous definition
denotes the subsequence of $\delta$ between indexes $a$ and $b$,
as defined on page \pageref{notations}.
\end{definition}

From \pref{def:ltw} and \pref{def:concr}, we derive that if 
$w\ltw w'$, then $\concr(w)\subseteq\concr(\w')$ (\pref{lem:ltw}).
\begin{lemma}\label{lem:ltw}
$\w\ltw\w' \Longrightarrow \concr(\w)\subseteq\concr(\w')$\enspace.
\end{lemma}


\subsubsection{Local Causality for Objectives}

The aim of searching for the existence of a scenario from a state $s$ leading to a state
where a given local state of an automaton $a_j$ is present
can be reformulated as the checking for the non-emptiness of $\concr(\obj{a_i}{a_j})$, where
$a_i=\get{s}{a}$.
A first hint for checking this emptiness is to look for actions that have to be played in order to
reach the state $i$ from $0$ within the automaton $a$.

Given an objective $P = \obj{a_i}{a_j} \in\Obj$, we define $\BS(P)$ the \emph{bounce sequences} of
$P$ as the set of minimal sequences of actions hitting $a$ in which the bounce of each action is
the target of the following action (\pref{def:bs}).

\begin{definition}[Bounce Sequence ($\BS$)]\label{def:bs}
A \emph{bounce sequence} $\zeta$  is a sequence of actions such that
$\forall n\in\indexes{\zeta}, n<|\zeta|,
\bounce{\zeta_{n}} = \target{\zeta_{n+1}}$.
$\BS$ denotes the set of bounce sequences.
We refer to the set of bounce sequences \emph{resolving} the objective $P$ as
$\BS(P)$:
\begin{align*}
\BS(\obj{a_i}{a_j}) \DEF \{ \zeta\in\BS\mid & \target{\zeta_1}=a_i\wedge
			    \bounce{\zeta_{|\zeta|}}=a_j \\
& \wedge \forall m,n\in\indexes{\zeta}, n>m, \bounce{\zeta_n}\neq\target{\zeta_m}
				\}\enspace.
\end{align*}
\end{definition}

Therefore,
$\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and
$\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no possibility to reach $a_j$ from
$a_i$.

\todo{example}

From \pref{def:bs}, we can derive that any scenario concretising an objective includes all the
actions of one of the bounce sequences of the objective (\pref{lem:bs-concr}).
\begin{lemma}
Given a state $s\in L$ and an objective $\obj{a_i}{a_j}$ with $\get{s}{a}=a_i$,
$\forall\delta\in\concr(\obj{a_i}{a_j})$,
$\exists\zeta\in\BS(\obj{a_i}{a_j})$ such that
$\exists \phi: \indexes{\zeta}\to\indexes{\delta}$
with
$\forall n,m\in\indexes{\zeta}, n<m \Leftrightarrow \phi(n)<\phi(m)$
and
$\forall n\in\indexes{\zeta}$, $\zeta_n = \delta_{\phi(n)}$.
\label{lem:bs-concr}
\end{lemma}

\todo{revise}
In the following, we denote: $\sSol = \powerset(\PHproc)$
\moda{%
and $\Sol = \powerset(\sSol)$.
}%
\modMF{%
The elements of $\sSol$ are sets of local states,
and will later represent sets of hitters of a given action
that are required to be active simultaneously in order to play this related action.
The elements in $\Sol$ are sets of sets of hitters,
and represent the requirements to play a whole bounce sequence.
}%

\begin{definition}[$\aBS:\Obj \rightarrow \powerset(\Sol)$]
\label{def:aBS}
  The \emph{abstractions of bounce sequences} of an objective $P$, denoted by the set $\aBS(P)$, are the minimal sets of hitters of the bounce sequences solving $P$:
  \[
    \aBS(P) \DEF \{ \abstr{\zeta} \in \Sol \mid
      \zeta \in \BS(P) \wedge
      \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  \modMF{
  where $\forall P \in \Obj, \forall \zeta \in \BS(P)$:
  $\abstr{\zeta} \DEF \{ \PHhitter(\zeta_n) \mid n \in \indexes{\zeta} \} \setminus \emptyset$.
  }%
  
  \noindent
  \modMF{
  As a consequence,
  $\aBS(\obj{a_i}{a_j}) = \emptyset$ if $\BS(\obj{a_i}{a_j}) = \emptyset$,
  and $\BS(\obj{a_i}{a_i}) = \{ \emptyset \}$.
  }%
\end{definition}


\subsubsection{Local Causality Graph}

Given one initial objective, one could then recursively refine the objective into objective
sequences following its bounce sequences \cite{PMR12-MSCS}:
the refinement of objective $P$ with $\zeta\in\BS(P)$ would consists in prepending to $P$ the
objectives leading to the hitters of the actions in $\zeta$, in the same sequential order;
the generalisation of the refinement to an objective sequence would require to consider all possible
interleaving between the refinements.

These refinements can be summarized compactly with a so-called Local Causality Graph (LCG).
A LCG $\myB = (\cwV, \cwE)$
is a digraph where $\cwV \subseteq \Proc \cup \Obj \cup \sSol \cup \Sol$ is the set of vertices
and $\cwE \subseteq \cwV \times \cwV$ is the set of oriented edges.
\todo{explain nodes}
Such a graph aims a describing the requirements of a given reachability
problem, that is, the reachability of $\w$ from the initial context $\ctx$.
Thus, a node in $\PHproc$ represents a local state required to play an action,
a node in $\Obj$ is an objective to reach a given local state,
a node in $\sSol$ is a set of hitters that have to be active simultaneously
to solve one step of a given objective,
and a node in $\Sol$ is a set of sets of hitters,
thus encompassing all requirement for the solving of a whole objective.

\todo{explain edges}
The edges of such a graph allow to draw links between these requirements.
Thus, an objective $P \in \Obj$ is solvable if
at least one related bounce sequence in $\BS(P)$ can be played;
therefore, we can consider all minimal sets of sets of hitters of these bounce sequences
(that is, the sets of $\aBS(P) \subseteq \Sol$, see \pref{def:aBS})
as requirements to solve this objective (\pref{eq:ESol1}).
Such a set can then naturally be split into as many sets of hitters (\pref{eq:ESol3})
which all have to be simultaneously active.
These sets of hitters can in turn be split into several local state nodes (\pref{eq:ESol2}).
This creates new requirements, as the reachability of a required local state $a_i$
is approximated by the ability to solve all objectives of the form
$\PHobjp{a}{j}{i} \in \Obj$ for all $a_j$ in the initial context (\pref{eq:EReq}).
Furthermore, we note that the solving of an objective $P$ may require
a local state of $\PHsort(P)$,
\ie $\gCont(\PHsort(P), P) \neq \emptyset$ (see \pref{def:maxCont});
in this case, $P$ is re-targeted (\pref{eq:ECont}).
Finally, \pref{eq:Vw} and \eqref{eq:Vproc}
force the graph to contain all the initial objectives
and the related local states,
and \pref{eq:VE} ensures the consistency of $\cwV$.

\todo{motivate context}
A context (\pref{def:context}) extends the notion of state to a set of possible initial states:
\modMF{
to each automaton in the model, a context maps a set of local states in this automaton.
}
\begin{definition}[Context ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each automaton in $\PHs$ a non-empty subset of its local states:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}

Given a context $\ctx$ and an objective sequence $\w$, the corresponding LCG can be built
recursively starting from the objectives in $\w$ and recursively adding their possible refinements
following $\BS$ (\pref{def:glc}).

\begin{definition}
\label{def:glc}
Given a context $\ctx$ and a local state $p\in \Proc$,
the Local Causality Graph (LCG) for reachability under-approximation
$\cwB \DEF (\Bv, \Be)$
with
$\cwBNodes \subseteq \Proc \cup \Obj \cup \NSol \cup \powerset(\Proc)$
and
$\cwBEdges \subseteq \cwBNodes \times \cwBNodes$,
is the smallest graph such that:
\begin{enumerate}
\item
$p \in \cwBNodes$
\item
$a_i\in\cwBNodes\cap\Proc \Leftrightarrow \{ (a_i,\obj{a_j}{a_i}) \mid
a_j\in\ctx$ \\
\hspace*{3cm}
$\vee (a_j\neq a_i\wedge a_j\neq\w\wedge a_j\in\cwBNodes\cap\Proc)
\}\subseteq\cwBEdges$
\item
$P\in\cwBNodes\cap\Obj \Leftrightarrow 
	\{ (P,\langle P,nls\rangle) \mid nls\in\nsol(P) \}\subseteq\cwBEdges$
\item
$\langle P, nls \rangle\in\cwBNodes\cap\NSol \Leftrightarrow
	\{ (\langle P,nls\rangle, ls) \mid ls\in nls \}\subseteq\cwBEdges$
\item
$ls \in\cwBNodes\cap\powerset(\Proc) \Leftrightarrow
	\{ (ls, a_i) \mid a_i\in ls \}\subseteq\cwBEdges$
\item
$\obj{a_i}{a_j}\in \cwBNodes\cap\Obj \Rightarrow 
	\{(\obj{a_i}{a_j},\obj{a_k}{a_j}) \mid a_k\neq a_j,$
\\
\hspace*{4cm}
$a_k\in \conn_{(\cwBNodes,\cwBEdges)}(\langle\obj{a_i}{a_j},nls\rangle),$
\\
\hspace*{4cm}
$nls\in\nsol(\obj{a_i}{a_j}) \}\subset\cwBEdges$
\end{enumerate}

\todo{def conn, nsol}
\end{definition}


%
\begin{comment}
\noindent
For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc)$ or $ps \in \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last local state in the sequence $\delta$ (hitter or bounce) of every automaton mentioned in $\delta$.

\end{comment}


\subsection{Sufficient condition for reachability of a local state}
\label{ssec:ua}

\todo{explain rational}
\begin{itemize}
\item we want to identify an objective sequence that for sure has a concrete scenario
\item LCG is abstract representation of a set of objective sequences
\item we prove that if LCG has no cycle, and all its local states synchronizations are independent,
then such a sequence exists.
\item Note: as we are under-approximating, we de not require that this set is complete.
\end{itemize}

\todo{motivate $\uconcr$}
\begin{definition}[$\uconcr: \OS \rightarrow \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \modMF{\forall \w \in \OS,}
  \uconcr(\w) \DEF
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, \concr(\w)\neq\emptyset\\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}

\todo{revise}
\modMF{
In the saturated graph of local causality, a set of hitters $A \in \sSol$
is said to be \emph{coherent} (\pref{def:coherent})
if none of the local states in $A$ conflict with
a successor of $A$ in $\Bv \cap \Proc$,
that is, if there exists no local state node $a_j$ in the successors of $A$
and no element $a_i \in A$ so that $a_i \neq a_j$.
}
\begin{definition}[Independant synchronisations]
\label{def:coherent}
  In a LCG $\cwB = (\Bv, \Be)$,
  a node $x \in \Bv\cap\sSol$ is an \emph{independent synchronisation} if and only if
  $x$ has no successor $a_j \in \Bv \cap \Proc$ such that $\exists a_i \in x$, $a_i \neq a_j$.
\end{definition}

\todo{intuition on sufficient condition}
Then, \pref{th:approxinf} gives a sufficient condition for the reachability of 
a local state in a given context
of an objective sequence in a given context
which is derived immediately from the saturated graph of local causality,
and the condition that all sets of hitters are coherent.
A proof of this theorem is given in \pref{suppl:demoapproxinf}.

\begin{theorem}[Under-approximation]
\label{th:approxinf}
  Given an AAN $(\PHs; \PHl; \PHa)$,
  a context $\ctx$ and an objective sequence $\w$,
  if the LCG $\cwB$ contains no cycle,
  all objective nodes have at least one child,
  and all the synchronisations are independent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

\modMF{
Regarding the complexity of the method,
computing the LCG is polynomial in the number of automata in $\PH$ and exponential in the number of local states in one automaton.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
Therefore, the building and checking process can be considered as polynomial in the size
of the AAN, provided that each automaton only contains a few local states.
We note that this is particularly true for biological models, where
each component usually contains a limited number of expression levels.
}

\modMF{
We note furthermore that in the case where
the method developed in this section is not conclusive,
it is possible to compute only a subset of $\Bv \cap \Sol$,
by removing some solutions from the initial graph of local causality $\myB$,
or by removing them from the saturated graph of local causality $\cwB$ and by trimming it.
In other words, this consists in ignoring some of the bounce sequences
for some of the objectives,
which intuitively cannot create false positives.
Indeed, \pref{th:approxinf} is then still valid on the partial graph obtained,
and this removal can lead to more conclusiveness by trimming parts of the graph
that were not necessary for the reachability
(especially cycles or unnecessary but inconclusive branches).
If one wants to try each possible subset of solutions,
then the overall method turns out to be exponential
in the number of solutions to each objective.
}


\begin{example}
  \moda{%
  If we confider the AAN of \pref{fig:ph-livelock},
  from the initial state $\PHstate{a_1, b_0, c_0}$ depicted,
  the under-approximation given in \pref{th:approxinf}
  does not conclude regarding the reachability of $c_1$.
  This is due to the fact that the node $\{ a_1, b_1 \} \in \Bv \cap \sSol$
  is not coherent because of its successor $a_0$ (and $b_0$).
  (However, from the inconclusiveness of \pref{th:approxinf},
  one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance
  with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  }%
  
  \modMF{%
  This result is new compared to the method proposed in~\cite{PMR12-MSCS}.
  Indeed, the representation based on the Process Hitting that was proposed
  in this paper only allowed to represent “over-approximated” Boolean gates
  with the use of cooperative sorts.
  This especially did not allow to model the fact that $a_1$ and $b_1$ could not
  be activated in the same state, but only in successive states.
  Thus, when using Process Hitting, $c_1$ was indeed reachable,
  contrary to the behaviour expected from an accurate Boolean gate.
  }%
  
  \moda{%
  Finally, we note however that,
  if $\PHhits{a_0}{b_0}{b_1}$ and $\PHhits{b_0}{a_0}{a_1}$ are replaced by the actions
  $\PHhitm{a_0}{a_1}$ and $\PHhitm{b_0}{b_1}$,
  then the resulting saturated graph of local causality changes, and
  \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.
  The reader can also refer to \pref{ssec:ex-metazoan}
  for a detailed conclusive example.
  }%

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
%    \node[Aobj] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[Assol,below of=c01s] (a1a1ss) {$\{ a_1, b_1 \}$};
    \node[Aproc,below left of=a1a1ss] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Assol,below of=a11s] (na11s) {$\emptyset$};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Assol,below of=a01s] (a01ss) {$\{b_0\}$};
    \node[Aproc,below of=a01ss] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Assol,below of=b00s] (nb00s) {$\emptyset$};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};
    \node[Assol,below of=b10s] (nb10s) {$\emptyset$};

    \node[Aproc,below right of=a1a1ss] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Assol,below of=b11s] (nb11s) {$\emptyset$};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Assol,below of=b01s] (b01ss) {$\{a_0\}$};
    \node[Aproc,below of=b01ss] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Assol,below of=a00s] (na00s) {$\emptyset$};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};
    \node[Assol,below of=a10s] (na10s) {$\emptyset$};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (a1a1ss)
    (a1a1ss) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (a01ss)
    (a01ss) edge (b0)
    (a11) edge (a11s)
    (a11s) edge (na11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a10s) edge (na10s)
    (a00) edge (a00s)
    (a00s) edge (na00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b10s) edge (nb10s)
    (b00) edge (b00s)
    (b00s) edge (nb00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (b01ss)
    (b01ss) edge (a0)
    (b11) edge (b11s)
    (b11s) edge (nb11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The saturated graph of local causality of the AAN in \pref{fig:ph-livelock}
    for the objective $\w = \PHobj{c_0}{c_1}$
    and the initial context $\ctx = \PHstate{a_1, b_0, c_0}$.
    Elements in $\Proc$ are represented by rectangular nodes,
    elements in $\Sol$ are represented by circle nodes,
    and elements in $\sSol$ and $\Obj$ are the remaining borderless nodes.
    \pref{th:approxinf} is inconclusive on this example as node $\{ a_1, b_1 \}$
    is not coherent (see \pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a successor of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$
    (and the same also stands for $b_0$).
  }
\end{figure}
\end{example}



\subsection{Reachability of a State}
\label{ssec:simult-ua}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The reachability property studied so far concerns a single local state at a time.
However, we remark that the reachability of a global state or a sub-state can be
addressed with the very same analysis by introducing a dedicated automata.
Such analysis was not possible with the Process Hitting framework,
because of the lack of the notion of simultaneity for more than two components.

In order to check the reachability of a global state $s \in \PHl$,
let $\PH = (\PHs, \PHl, \PHh)$ be an AAN.
We define a new AAN $\PH' = (\PHs', \PHl', \PHh')$ with:
$\PHs' = \PHs \cup \{ \reach \}$, $\PHl' = \PHl \times \PHl_\reach$,
where $\PHl_\reach = \{ \reach_0, \reach_1 \}$,
and $\PHh' = \PHh \cup \{ \PHhit{\toset{s}}{\reach_0}{\reach_1} \}$.
Given an initial context $\ctx$, the reachability of $s$ in $\PH$
is equivalent to the concretisation of $\PHobjp{\reach}{0}{1}$ in $\PH'$
from the initial context $\ctx \cup \{ \reach_0 \}$,
which can be efficiently under-approximated using \pref{th:approxinf}.

It is of course also possible to compute the reachability
of a sub-state $s \in \PHsubl[\PHl]_S$ of a set of components $S \subseteq \PHs$
with the same method.
One can also check the reachability of a set of states $\Lambda \subseteq \PHl$
by creating several actions
$\PHhit{\toset{s}}{\reach_0}{\reach_1}$ in $\PHh$ for each state $s \in \Lambda$.



\subsection{Sequential Under-approximation}
\label{ssec:ordered-ua}

In this section, we briefly explain an alternative sufficient condition that
progressively takes into account the successive objectives, instead of
considering all of them at a time, as it is done in \pref{ssec:ua}.
Because objectives are taken into account individually, such an approach
considers only a subset of scenarios.
However, because each iteration focuses on a smaller part of the network, this
sequential under-approximation may be more conclusive.

Let us define a sequence of objectives $\w=\obj{a_i}{a_j}\concat\w'$ with
$a_i\neq a_j$ and a state $s\in \PHl$ with $\get{s}{a}=a_i$.
One can remark that any scenario reaching $a_j$ necessarily includes one of the
bounce sequences in $\BS(\obj{a_i}{a_j})$, and, in particular,
any minimal scenario reaching $a_j$ ends in a state where $a_j$ is present but
also the hitters of the last bounce of one bounce sequence in $\BS(\obj{a_i}{a_j})$.
\pref{def:lastprocs} defines $\lastprocs(\obj{a_i}{a_j})$ as the set of set of
local states that may be present just after reaching $a_j$.

\begin{definition}[$\lastprocs : \Obj\to\Sol$]
\label{def:lastprocs}
  Given an objective $\obj{a_i}{a_j} \in \Obj$, $\lastprocs(\obj{a_i}{a_j})$ is
  defined as the largest set such that, $\forall ps\in\lastprocs(\obj{a_i}{a_j})$, 
  $ps\in\sSol$,
  \begin{enumerate}
    \item $a_j \in ps$;
    \item $\exists \zeta \in \BS(\obj{a_i}{a_j}),
      \hitter{\zeta_{\card{\zeta}}} \subseteq ps$;
    \item $\nexists ps' \in \lastprocs(\obj{a_i}{a_j}),
      ps' \subset ps \wedge ps' \neq ps$.
  \end{enumerate}
\end{definition}

\todo{integrate}
We also extend the override operator to contexts (\pref{def:ctxcap}).
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \rightarrow \Ctx$]
\label{def:ctxcap}
  For any $\ctx\in\Ctx$ and set of local states $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by:
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} \DEF
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}

From \pref{th:approxinf}, we can deduce that
for any scenario $\delta$ in $\uconcr(P)$,
there exists a set of local states $ps\in\lastprocs(P)$
such that $ps \subseteq (s\play\delta)$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
with $\ctx'=\ctx\Cap\procs(\mycwB{\ctx}{P})$,
there exists a scenario $\delta'$ concretising $\w'$ from the
state $(s\play\delta)$.
Therefore, the scenario $\delta\concat\delta'$ concretises
$\w$.

\begin{theorem}[Sequential under-approximation]
\label{thm:ordered-ua}
Given an AAN $(\PHs; \PHl; \PHa)$,
a context $\ctx$ and an objective sequence $\w =
P\concat\w'\in\OS$,
$\uconcr(P)\neq\emptyset \wedge
	\forall ps \in\lastprocs(P),
	\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset
	\Longrightarrow \uconcr(\w)\neq\emptyset$,
where $\ctx' = \ctx\Cap\procs(\mycwB{\ctx}{P})$.
\end{theorem}
\begin{proof}
If $\uconcr(P)\neq\emptyset$,
for all $s\in \PHl, s\subseteq\ctx$,
there exists a scenario $\delta\in\uconcr(P)\cap\Sce(s)$;
from \pref{def:lastprocs} and proof of \pref{th:approxinf},
$\exists ps\in\lastprocs(P)$ such that
$(s\play\delta)\subseteq\ctx'\Cap ps$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
there exists a scenario $\delta'\in\muconcr_{\ctx'\Cap ps}(\w')$ such that
$\delta'\in\Sce(s\play\delta)$.
Hence, $\delta\concat\delta'$ is a scenario playable in $s$.
Therefore, for all $s\in \PHl, s\subseteq\ctx$, there exists a scenario
concretising $\w$.
Hence, $\uconcr(\w)\neq\emptyset$.
\end{proof}



\modMF{
\subsection{Extraction of a Scenario}
\label{ssec:concret}
}

\modMF{
This section gives a recursive method to find a scenario that concretizes
a given objective sequence $\w \in \OS$.
All the definitions above are well-defined provided that
$\uconcr(\w)\neq\emptyset$,
which can be demonstrated by \pref{th:approxinf} or \pref{thm:ordered-ua}.
The justification of these definitions can be found by analysing the demonstrations
of these theorems.
}

\newcommand{\res}{\mathbf{res}}
\newcommand{\osres}{\mathbf{OSres}}
\newcommand{\autoBS}{\mathbf{autoBS}}
\newcommand{\rec}{\mathbf{rec}}
% \newcommand{\thisobj}[1]{P_{#1}}
% \newcommand{\thisseq}[1]{\Theta_{#1}}
\newcommand{\thisobj}{P}
\newcommand{\thisseq}{\Theta}
\newcommand{\R}{R}

\modMF{%
First, $\osres$ is used to split the objective sequence $\w$ to solve,
by considering successive objectives, in the fashion of \pref{thm:ordered-ua}.
This function calls $\res$ which allows to solve an objective $P$
by either re-target it (if $\gCont(\PHsort(P), P) \neq \emptyset$)
of by searching for a solution to this objective in $\BS(P)$.
This search may require to try several objective sequences $\zeta \in \BS(P)$.
For each trial, the chosen objective sequence $\zeta$ is solved with $\rec$,
which recursively created a scenario to play the whole sequence.
This scenario is itself recursively created by combining
smaller scenarios allowing to reach each required hitter of each action
with the function $\thisseq$.
Finally, $\thisseq$ calls $\res$ anew to reach the hitters
that are necessarily contained in other automata.
In the end, a scenario can be obtained by analysing all values of
$\osres_s(\w)$ (\pref{def:concret})
for all possible initial state $s \subseteq \ctx$ in the considered context,
and all possible bounce sequences $\zeta \in \BS(P)$ that are chosen during the resolution.
}%

\begin{definition}[$\osres : \PHl \times \OS \to \Sce$]
\label{def:concret}
\modMF{%
For all $s \in \PHl$ and $\w \in \OS$, we define:
\[
  \osres_s(\w) \DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\w = \emptyseq$} \\
      \res_s(\w_1) \concat
      \osres_{s \play \res_s(\w_1)}(\w_2 \concat \dots \concat \w_{\card{\w}})
        & \text{ otherwise} \\
    \end{cases}
\]
and, for all $s \in \PHl$ and $P \in \Obj$:
\[\res_s(P) \DEF
  \begin{cases}
    \varepsilon
      & \text{if } \target{P} = \bounce{P} \\
    \osres_s(P^Q \concat Q)
      & \text{if } \exists Q \in \Obj, (P, Q) \in \Bee{\Obj}{\Obj} \\
    \rec_s(\zeta)
      & \text{otherwise, with } \zeta \in \BS(P)
  \end{cases}
\]
with $P^Q = \PHobj{\PHtarget(P)}{\PHtarget(Q)}$.
Furthermore:
\begin{align*}
  \forall \zeta \in \BS,
  \rec_s(\zeta) &\DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\zeta = \emptyseq$} \\
      \thisseq_s(\zeta_1) \concat \zeta_1 \concat
      \rec_{s \play \thisseq_s(\zeta_1) \concat \zeta_1}
      (\zeta_2 \concat \dots \concat \zeta_{\card{\zeta}})
        & \text{ otherwise}
    \end{cases} \\
  \forall h \in \PHh,
  \thisseq_s(h) &\DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\hitter{h} = \emptyset$} \\
      \R_s(h_1) \concat \thisseq_{s \play \R_s(h_1)}(h_2 \concat \dots \concat h_{\card{h}})
        & \text{ otherwise}
    \end{cases} \\
  \forall a_i \in \Proc,
  \R_s(a_i) &\DEF \res_s(\PHobj{\PHget{s}{\PHsort(a_i)}}{a_i})
\end{align*}
and for all action $h \in \PHh$, $(h_i)_{i \in \segm{1}{\card{\hitter{h}}}}$
is a sequence containing all hitters of $h$ in an arbitrary order.
}
\end{definition}
