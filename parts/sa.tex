\section{Static Analysis}\label{sec:sa}

The aim of this section is to define the problem of reachability in a PH,
and propose an under-approximation allowing to efficiently solve it.
The static analysis presented here is inspired from~\cite{PMR12-MSCS}.

\subsection{Preliminary definitions}
\label{ssec:sa-def}

The reachability of a process $a_j$ of a given sort $a$ from another process $a_i$ is called an objective and is denoted $\PHobjp{a}{i}{j}$ (\pref{def:obj}).
\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  If $a \in \components$, the reachability of a process $a_j$ from a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a^2 \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) = a$, $\PHtarget(P)=a_i$, $\PHbounce(P)=a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same sort, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

A context (\pref{def:context}) extends the notion of state to a set of possible initial states.
We also extend the override operator to contexts (\pref{def:ctxcap}).
\begin{definition}[Context ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}
%
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \rightarrow \Ctx$]
\label{def:ctxcap}
  For any $\ctx\in\Ctx$ and set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by:
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} =
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}
\noindent
For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc)$ or $ps \in \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last process in the sequence $\delta$ (hitter or bounce) of every sort mentioned in $\delta$.

Finally, a bounce sequence on a sort $a$ (\pref{def:bs}) is a sequence of actions hitting $a$
in which the bounce process of each action is the hitter process of the following action.
Bounce sequences are used to find local solutions to a given objective.
A bounce sequence on $a$ can be abstracted into sets of all its hitters that are not in sort $a$ (\pref{def:aBS}).
This abstraction allows to propagate an objective on the sort $a$ into objectives on other sots.
In the following, we denote: $\Sol = \powerset(\PHproc)$.
\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) = \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$ and $\emptyseq \in \BS(\obj{a_i}{a_i})$.
\end{definition}
%
\begin{definition}[$\aBS:\Obj \rightarrow \powerset(\Sol)$]
\label{def:aBS}
  The \emph{abstractions of bounce sequences} of an objective $P$, denoted by the set $\aBS(P)$, are the sets of hitters of bounce sequences solving $P$:
  \[
    \aBS(P) = \{ \abstr{\zeta} \in \Sol \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  where $\abstr{\zeta} = \{ \PHhitter(\zeta_n) \mid  n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$.
\end{definition}



\subsection{Under-approximation}

We denote $\concr(\w)$ the set of scenarios concretising an objective sequence $\w$ in the context $\ctx$.
In \pref{def:uconcr}, we define $\uconcr(\w)$ as equal to $\concr(\w)$ if and only if $\concr(\w)$ contains scenarios starting from all states $s \subseteq \ctx$.
\pref{th:uconcr-ctx} is used to over-approximate the initial context $\ctx$.
\begin{definition}[$\uconcr: \OS \rightarrow \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \uconcr(\w) = 
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \delta \in \Sce(s) \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{theorem}
\label{th:uconcr-ctx}
  $\ctx \subseteq \ctx' \wedge \muconcr_{\ctx'}(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx}(\w) \neq \emptyset$.
\end{theorem}

For any objective $P$ and context $\ctx$, \pref{def:maxCont} gives the set of processes of sort $\PHsort(P)$ that are required to solve $P$ in $\ctx$, given by $\gCont_\ctx(\PHsort(P), P)$.
\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \rightarrow \powerset(\PHproc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) = 
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

The graph of local causality $\cwB = (\V, \E)$ defined in \pref{def:glc} is a graph where $\V \subseteq \Proc \cup \Obj \cup \Sol$ and $\E \subseteq \V \times \V$.
A node in $\PHproc$ is a required process,
a node in $\Obj$ is an objective to reach a given process
and a node in $\Sol$ is a set of processes required for the solving.
An objective $P \in \Obj$ is solvable if the abstractions of bounce sequences $\aBS(P) \in \Sol$ (\pref{def:aBS}) can be reached (\pref{eq:ESol1}), thus leading to several required processes (\pref{eq:ESol2}).
If $a \in \components$, the reachability of one of its process $a_i$ is approximated by the ability to solve all objectives $\PHobjp{a}{j}{i} \in \Obj$ for all $a_j$ in the initial context (\pref{eq:EReq});
if $a \in \cs$, the reachability of $a_i$ is simply solved by the set of processes $\csState(a_i)$ (\pref{def:csState}) that it represents (\pref{eq:EPrio}).
The solving of an objective $P$ may require a process of $\PHsort(P)$, \ie $\gCont(\PHsort(P), P) \neq \emptyset$ (\pref{def:maxCont}); in this case, $P$ is re-targeted (\pref{eq:ECont}).
\pref{eq:Vw}, \eqref{eq:Vproc} and~\eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Finally, as the active process of every sort may evolve, $\cwB$ is obtained by iteratively saturating with every process it contains,
\ie by overriding its initial context $\ctx$ by $\allprocs(\V, \E)$, defined by:
$$\allprocs(\V, \E) = (V \cap \Proc) \cup \{ \PHtarget(P), \PHbounce(P) \mid P \in \V \cap \Obj \}$$

\begin{comment}
The reachability of a process $a_i$ is approximated by the ability to solve all objectives $\PHobjp{a}{j}{i}$ for all $a_j$ in the initial context.
To this end, the abstractions of bounce sequences (\pref{def:aBS}) solving these objectives are computed, leading to new required processes, and thus new objectives on other sorts.
Thus, the graph of local causality $\cwB = (\V, \E)$ defined in \pref{def:glc} is a graph where $\V \subset \Proc \cup \Obj \cup \Sol$ and $\E \subset \V \times \V$
in which edges link any required process $a_i$ in $\Proc$ to all corresponding objectives $P$ in $\Obj$,
and any objective $P$ to abstractions of bounce sequences $ps \in \Sol$ (\pref{def:aBS}) solving this objective;
such sets $ps$ then stand for new required processes.
In the case where a process $a_i$ belongs to a cooperative sort, it is directly linked to the set of the processes $\csState(a_i)$ (\pref{def:csState}) that it represents.
If the solving of an objective $P$ requires a process of $\PHsort(P)$, a continuity edge is added to re-target this objective (\pref{def:maxCont}).
Finally, as the active process of every sort may evolve, $\cwB$ is obtained iteratively by saturation with every process it contains,
\ie by overriding its initial context $\ctx$ by $\allprocs(\V, \E)$, defined by:
$$\allprocs(\V, \E) = (V \cap \Proc) \cup \{ \PHtarget(P), \PHbounce(P) \mid P \in \V \cap \Obj \}$$
\end{comment}

\begin{definition}
\label{def:glc}
  The graph of local causality $\cwB = (\Bv, \Be)$ is defined as: $\cwB = \lfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs(\myB)}}$,
  where $\myB = (\cwV, \cwE)$ is the smallest graph with
  $\cwV \subseteq \Proc \cup \Obj \cup \Sol$ and $\cwE \subseteq \cwV \times \cwV$
  so that:
  \begin{align}
    \w &\subseteq \cwV \label{eq:Vw} \\
    P \in \VProc &\Rightarrow \PHbounce(P) \in \cwV \label{eq:Vproc} \\
    (x, y) \in \E &\Rightarrow y \in \cwV \label{eq:VE} \\
    P \in \VObj \wedge ps \in \BS(P) &\Rightarrow (P, ps) \in \cwE \label{eq:ESol1} \\
    ps \in \VSol \wedge a_i \in ps &\Rightarrow (ps, a_i) \in \cwE \label{eq:ESol2} \\
    a \in \components \wedge a_i \in \VProc \wedge a_j \in \ctx &\Rightarrow (a_i, \PHobjp{a}{j}{i}) \in \cwE \label{eq:EReq} \\
    a \in \cs \wedge a_i \in \VProc \wedge ps \in \csState(a_i) &\Rightarrow (a_i, ps) \in \cwE \label{eq:EPrio} \\
    P \in \VObj \wedge q \in \gCont_\ctx(\PHsort(P), P) &\Rightarrow (P, \PHobj{q}{\PHbounce(P)}) \in \cwE \label{eq:ECont} \!
  \end{align}
\end{definition}

\begin{comment}
\pref{eq:Vw}, \eqref{eq:Vproc} and \eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Elements in $\PHproc$ are required processes,
elements in $\Obj$ are the objectives to reach these processes
and elements in $\Sol$ are the sets of processes that allow to solve these objectives.
\pref{eq:ESol1} links an objective $P$ to its solutions in $\BS(P)$
and \pref{eq:ESol2} links a solution $ps$ to the processes $a_i \in ps$ it contains.
Then, \pref{eq:EReq} links a required component process $a_i$ to all objectives $\PHobjp{a}{j}{i}$ with $a_j \in \ctx$
while \pref{eq:EPrio} links a required cooperative sort process $a_i$ to its solutions in $\csState(a_i)$.
Finally, if the resolution of an objective $P$ requires a process of $\PHsort(P)$, then \pref{eq:ECont} re-targets this objective ($\gCont$).
\end{comment}

In the graph of local causality, an edge $(p, ps) \in \Proc \times \Sol$ %linking a process of a cooperative sort to a solution set $ps$
is said coherent (\pref{def:coherent}) if none of the processes in $ps$ conflict with the children processes of $ps$.
Then, \pref{th:approxinf} gives a sufficient condition for the concretization of a sequence of objectives in a given context,
which is derived immediately from the graph of local causality.
A proof of this theorem is given in Annex~\ref{suppl:demoapproxinf}.
\begin{definition}[Coherent edge]
\label{def:coherent}
  An edge $(x, y) \in \cwE$ is said coherent if and only if:
  $(x, y) \in \Be \cap (\Proc \times \Sol) \Rightarrow y$ has no children process $a_j \in \Bv \cap \Proc$ so that $\exists a_i \in y$, $a_i \neq a_j$.
\end{definition}

\begin{theorem}[Under-Approximation]
\label{th:approxinf}
  If the graph $\cwB$ contains no cycle,
  all objectives have at least one solution
  and all edges are coherent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

Computing the graph of local causality is polynomial in the number of sorts in $\PH$ and exponential in the number of processes in one sort.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
%Therefore, if the number of processes in each sort is small, the overall method can be processed in polynomial time.
Furthermore, it is possible to compute only a subset of $\V \cap \Sol$;
in this case, the overall method turns out to be exponential in the number of solutions to each objective.
Our method can thus be considered as efficient compared to regular model-checking which is usually PSPACE-complete~\cite{Harel02}.



\begin{example}
  Let $\PH' = (\PHs, \PHl, \PHh'^{\langle 1 \rangle})$ be the “flattened” version of the PH in \pref{fig:ph-livelock}, that is: $\PHh'^{\langle 1 \rangle} = \PHh^{(1)} \cup \PHh^{(2)}$,
  which is equivalent to a PH in the semantics without priorities.
  Due to spurious behaviours inherent to the cooperative sorts in this semantics, 
  the original under-approximation developed in~\cite{PMR12-MSCS} concludes that $c_1$ is reachable in $\PH'$ from $\ctx = \PHstate{a_1, b_0, c_0, ab_{10}}$.
  %this is due to an over-approximation of the behaviours inherent to cooperative sorts in the semantics without priorities.
  
  Such unwanted behaviours are palliated by the semantics of PH with priorities proposed in this paper.
  Indeed, the under-approximation given in \pref{th:approxinf} does not conclude regarding the reachability of $c_1$,
  as one of the edges of the resulting graph of local causality is not coherent (\pref{def:coherent}),
  as shown in in \pref{fig:sa-livelock}.
  (However, from the inconclusiveness of \pref{th:approxinf}, one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  
  However, if $\PHhit{a_0}{b_0}{b_1}$ and $\PHhit{b_0}{a_0}{a_1}$ are replaced by
  $\PHhit{a_0}{a_0}{a_1}$ and $\PHhit{b_0}{b_0}{b_1}$,
  then \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.
\end{example}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[AprocPrio,below of=c01s] (ab11) {$ab_{11}$};
    \node[AsolPrio,below of=ab11] (ab11s) {};

    \node[Aproc,below left of=ab11s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below right of=ab11s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge[aSPrio] (ab11s)
    (ab11s) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a00) edge (a00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (a0)
    (b11) edge (b11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The graph of local causality of the PH model in \pref{fig:ph-livelock}.
    Rectangular nodes containing a single process are elements in $\Proc$,
    nodes containing a couple of processes are elements in $\Obj$
    and circle nodes are elements in $\Sol$.
    %The double arrow and the two surrounding nodes represent the only edge in $\Proc \times \Sol$.
    \pref{th:approxinf} is inconclusive on this example as edge $(ab_{11}, \{ a_1, b_1 \}) \in \Proc \times \Sol$ (here represented with a double line) is not coherent (\pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a child of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$ (and the same also stands for $b_0$).
  }
\end{figure}

\todo{Add sequential reachability if possible}

\todo{Add over-approximation if possible}



\subsection{Reachability of a state}

\todo{Develop a little bit more?}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The semantics of PH with $2$ classes of priorities studied in this paper allows to model cooperative sorts accurately representing a coherent configuration of a set of sorts.
Therefore, we can derive a new method to conclude about the reachability of a state (considering only components).
Indeed, let $\PH = (\PHs, \PHl, (\PHh^{(1)}, \PHh^{(2)}))$ be a PH and suppose that we want to study the reachability of a state $s \in \PHl$.
Let $\PH' = (\PHs', \PHl', (\PHh'^{(1)}, \PHh'^{(2)}))$
with: $\PHs' = \PHs \cup \{ \total, \reach \}$ and $\PHl' = \PHl \times \PHl_\total \times \PHl_\reach$,
where $\total$ is a cooperative sort on all components $\components$ of $\PH$ (thus $\PHl_\total = \underset{a \in \components}{\times} \PHl_a$)
and $\reach$ is a component with $\PHl_\reach = \{ \reach_0, \reach_1 \}$;
furthermore, $\PHh'^{(1)}$ is the set $\PHh^{(1)}$ completed with all actions updating the cooperative sort $\total$,
and $\PHh'^{(2)} = \PHh^{(2)} \cup \{ \PHhit{\pfp_s(\total)}{\reach_0}{\reach_1} \}$.

Given an initial context $\ctx$, the reachability of $s$ in $\PH$ is equivalent to the concretization of $\PHobjp{\reach}{0}{1}$ in $\PH'$ from the initial context $\ctx \cup \{ \reach_0 \}$ (the initial state of $\total$ does not matter), which can be efficiently under-approximated using \pref{th:approxinf}.
Indeed, the additional action $\PHhit{\pfp_s(\total)}{\reach_0}{\reach_1}$ in $\PHh'^{(2)}$ allows to conclude on the reachability of process $\pfp_s(\total)$, that is, on the reachability of the state $s$ (considering only the components).

It is also possible to compute the reachability of a set of states $S \subseteq \PHl$ by creating several actions $\PHhit{\total_s}{\reach_0}{\reach_1}$ in $\PHh^{(2)}$ for each state $s \in S$.
