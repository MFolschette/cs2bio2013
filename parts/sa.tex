% vi:spell spelllang=en:
\section{Under-approximation of Reachability}\label{sec:sa}

\modLP{%
We present a static analysis that takes as input an AAN
$\PH = (\PHs; \PHl; \PHa)$,
an initial state, and a local state of an automata in $\PHs$, for identifying sufficient conditions
that ensure the existence of a scenario starting from the initial state and leading to a state
where the given local state is present.}

A classical approach for determining if a local state of an automaton can be reach from a
given initial state is to build sequences of transitions from the initial state until a state
containing the given local state is reached.
This is essentially what model-checkers do, and the complexity of such analysis (PSPACE-complete
\cite{Harel02}) makes it intractable on large systems, even with advanced symbolic approaches
\cite{PMR12-MSCS}.

Our approach relies on abstractions of scenarios that have been introduced in
\cite{PMR12-MSCS} for the static analysis of reachability in the Process Hitting framework,
a particular sub-class of AAN (see the Remark at the end of the previous section).
In this paper, we generalize the static analysis for the case of the under-approximation of
reachability in any AAN.

\todo{outline}

\subsection{Abstractions for Scenarios}
\label{ssec:abstr-sce}

The approach presented in this section is based on two complementary notions,
the \emph{objectives} and their \emph{local causality},
that are intertwined in so-called \emph{Local Causality Graphs}.

\subsubsection{Objectives}

An \emph{objective} (\pref{def:obj}) denotes the reachability of a local state (e.g., $a_j$) of a given automaton $a$
from the initial local state of that automaton (e.g., $a_i$).
Such an objective is written $\PHobjp{a}{i}{j}$.
Successive objectives are described with objective sequences (\pref{def:obj}).

\begin{definition}[Objective ($\Obj$) \& Objective Sequence ($\OS$)]
\label{def:obj}
  If $a \in \components$, the reachability of a local state $a_j$ from a local state $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a \times \PHl_a \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) \DEF
  a$, $\PHtarget(P)\DEF a_i$, $\PHbounce(P)\DEF a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same automaton, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

We define the partial ordering relation $\ltw$ between two objective sequences (\pref{def:ltw}) as
follows:
$w\ltw w'$ if and only if there exists a mapping between all the objective bounces of $w'$ in $w$
that preserve the sequentiality.

\todo{support compatibility}

\begin{definition}[$\ltw \subset \OS\times\OS$]\label{def:ltw}
$\w\ltw\w'$ if and only if
$|\w|\geq|\w'|$ and
there exists a mapping $\phi: \indexes{\w'}\mapsto \indexes{\w}$ such that
$\forall n,m \in\indexes{\w'}, n<m \Leftrightarrow \phi(n)<\phi(m)$,
and
$\forall n\in\indexes{\w'}, \bounce{\w'_n}=\bounce{\w_{\phi(n)}}$
\end{definition}

\begin{example}
\[\obj{b_0}{b_1}\concat\obj{a_0}{a_1}\concat\obj{b_1}{b_2}
\ltw
\obj{a_0}{a_1}\concat\obj{b_0}{b_2}
\ltw
\obj{b_0}{b_2}\]
\[\obj{b_0}{b_1}\not\ltw\obj{b_0}{b_2}\]
\end{example}

An objective sequence can be seen as an abstract representation of a set of scenarios that describe
(part of) the successive state changes of the automata.
We denote by $\concr(\w)$ (\pref{def:concr}) the set of scenarios concretising an objective sequence
$\w$ in the state $s\in\PHs$.
It is essentially all the scenarios for which there exists a mapping from the bounces of each
objective to the bounce of an action in the scenario which preserve the sequential ordering.

\todo{compatibility of $\w$ with $s$}

\begin{definition}[$\concr: \OS \to \powerset(\Sce)$]\label{def:concr}
Given $\w\in\OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the
state $s$:
\begin{align*}
\concr(\w) \DEF \{ \delta\in\Sce(s)\mid & (\w^\vartriangle=\emptyseq \wedge
\delta=\emptyseq)  \vee (
\w^\vartriangle\neq \emptyseq\wedge
\\ &
 \wedge \exists \phi:\indexes{\w}\mapsto\indexes{\delta},
    (\forall n,m\in\indexes{\w}, n<m \Leftrightarrow \phi(n)\leq\phi(m))
\\ & \qquad
	\wedge \forall n\in\indexes{\w},
	  \bounce{\w_n} \in s\play\delta_{1..\phi(n)})
\}
\enspace,
\end{align*}
where $\omega^\vartriangle$ refers to the objective sequence $\omega$ where
trivial objectives have been removed.
The notation $\delta_{a..b}$ in the previous definition
denotes the subsequence of $\delta$ between indexes $a$ and $b$,
as defined on page \pageref{notations}.
\end{definition}

From \pref{def:ltw} and \pref{def:concr}, we derive that if 
$w\ltw w'$, then $\concr(w)\subseteq\concr(\w')$ (\pref{lem:ltw}).
\begin{lemma}\label{lem:ltw}
$\w\ltw\w' \Longrightarrow \concr(\w)\subseteq\concr(\w')$\enspace.
\end{lemma}


\subsubsection{Local Causality for Objectives}

The existence of a scenario from a state $s$ leading to a state
where a given local state of an automaton $a_j$ is present
can be reformulated as the checking for the non-emptiness of $\concr(\obj{a_i}{a_j})$, where
$a_i=\get{s}{a}$.
A first hint for checking this emptiness is to look for actions that have to be played in order to
reach the state $j$ from $i$ within the automaton $a$.

Given an objective $P = \obj{a_i}{a_j} \in\Obj$, we define $\BS(P)$ the \emph{bounce sequences} of
$P$ as the set of minimal sequences of actions hitting $a$ in which the bounce of each action is
the target of the following action (\pref{def:bs}).

\begin{definition}[Bounce Sequence ($\BS$)]\label{def:bs}
A \emph{bounce sequence} $\zeta$  is a sequence of actions such that
$\forall n\in\indexes{\zeta}, n<|\zeta|,
\bounce{\zeta_{n}} = \target{\zeta_{n+1}}$.
$\BS$ denotes the set of bounce sequences.
We refer to the set of bounce sequences \emph{resolving} the objective $P$ as
$\BS(P)$:
\begin{align*}
\BS(\obj{a_i}{a_j}) \DEF \{ \zeta\in\BS\mid & \target{\zeta_1}=a_i\wedge
			    \bounce{\zeta_{|\zeta|}}=a_j \\
& \wedge \forall m,n\in\indexes{\zeta}, n>m, \bounce{\zeta_n}\neq\target{\zeta_m}
				\}\enspace.
\end{align*}
\end{definition}

Therefore,
$\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and
$\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no possibility to reach $a_j$ from
$a_i$.

\todo{example}

From \pref{def:bs}, we can derive that any scenario concretising an objective includes all the
actions of one of the bounce sequences of the objective (\pref{lem:bs-concr}).
\begin{lemma}
Given a state $s\in L$ and an objective $\obj{a_i}{a_j}$ with $\get{s}{a}=a_i$,
$\forall\delta\in\concr(\obj{a_i}{a_j})$,
$\exists\zeta\in\BS(\obj{a_i}{a_j})$ such that
$\exists \phi: \indexes{\zeta}\to\indexes{\delta}$
with
$\forall n,m\in\indexes{\zeta}, n<m \Leftrightarrow \phi(n)<\phi(m)$
and
$\forall n\in\indexes{\zeta}$, $\zeta_n = \delta_{\phi(n)}$.
\label{lem:bs-concr}
\end{lemma}

\begin{comment}
\todo{revise}
In the following, we denote: $\sSol = \powerset(\PHproc)$
\moda{%
and $\Sol = \powerset(\sSol)$.
}%
\modMF{%
The elements of $\sSol$ are sets of local states,
and will later represent sets of hitters of a given action
that are required to be active simultaneously in order to play this related action.
The elements in $\Sol$ are sets of sets of hitters,
and represent the requirements to play a whole bounce sequence.
}%

\begin{definition}[$\aBS:\Obj \rightarrow \powerset(\Sol)$]
\label{def:aBS}
  The \emph{abstractions of bounce sequences} of an objective $P$, denoted by the set $\aBS(P)$, are the minimal sets of hitters of the bounce sequences solving $P$:
  \[
    \aBS(P) \DEF \{ \abstr{\zeta} \in \Sol \mid
      \zeta \in \BS(P) \wedge
      \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  \modMF{
  where $\forall P \in \Obj, \forall \zeta \in \BS(P)$:
  $\abstr{\zeta} \DEF \{ \PHhitter(\zeta_n) \mid n \in \indexes{\zeta} \} \setminus \emptyset$.
  }%
  
  \noindent
  \modMF{
  As a consequence,
  $\aBS(\obj{a_i}{a_j}) = \emptyset$ if $\BS(\obj{a_i}{a_j}) = \emptyset$,
  and $\BS(\obj{a_i}{a_i}) = \{ \emptyset \}$.
  }%
\end{definition}
\end{comment}

\subsubsection{Local Causality Graph}

Given one initial objective, one could then recursively refine the objective into objective
sequences following its bounce sequences \cite{PMR12-MSCS}:
the refinement of objective $P$ with $\zeta\in\BS(P)$ would consists in prepending to $P$ the
objectives leading to the hitters of the actions in $\zeta$, in the same sequential order;
the generalisation of the refinement to an objective sequence would require to consider all possible
interleaving between the refinements.

These refinements can be summarized compactly with a so-called Local Causality Graph (LCG).
Given an initial context $\ctx$ and a local state $p\in\Proc$,
A LCG $\cwB = (\cwV, \cwE)$
is a digraph where $\cwV \subseteq \Proc\cup \Obj \cup \Sol \cup \sSol$ is the set of vertices
where $\sSol=\powerset(\Proc)$ and $\Sol=\Obj\times\powerset(\sSol)$
and $\cwE \subseteq \cwV \times \cwV$ is the set of oriented edges
(\pref{def:lcg}).
A node in $\Obj$ represents an objective that have to be refined.
Such a node can then be related to nodes in $\Sol$ which represents a set of hitter set of a
bounce sequence of the objective:
given an objective $P$, if $\zeta\in\BS(P)$, $\abstr\zeta \DEF \{\PHhitter(\zeta_n) \mid
n\in\indexes\zeta \}$, then $P$ is related to $\langle P, \abstr\zeta\rangle\in\Sol$
(\pref{def:lcg}-3).
Given a node $\langle P,\abstr\zeta\rangle\in\cwV\cap\Sol$, for each $ps\in\abstr\zeta$,
it is related to a node $ps\in\sSol$
(\pref{def:lcg}-4).
A node $ps\in\sSol$ is then related to each $a\in\Proc$
(\pref{def:lcg}-5).
Given a node $a_i\in\cwV\cap\Proc$, for each $a_j\in\ctx$ or $a_j\in\cwV\cap\Proc$,
it is related to an objective $\obj{a_j}{a_i}$
(\pref{def:lcg}-2).
Finally, given a node $\obj{a_j}{a_i}\in\cwV\cap\Obj$,
if a local state $a_k\neq a_i$ is in its descendants (given by
$\conn_{(\cwBNodes,\cwBEdges)}(\obj{a_j}{a_i})$), then
$\obj{a_j}{a_i}$ is related to $\obj{a_k}{a_i}$ in the LCG
(\pref{def:lcg}-6).

\begin{definition}
\label{def:lcg}
Given a context $\ctx$ and a local state $p\in \Proc$,
the Local Causality Graph (LCG) for reachability under-approximation
$\cwB \DEF (\Bv, \Be)$
with
$\cwBNodes \subseteq \Proc \cup \Obj \cup \NSol \cup \sSol$
and
$\cwBEdges \subseteq \cwBNodes \times \cwBNodes$,
is the smallest graph such that:
\begin{enumerate}
\item
$p \in \cwBNodes$
\item
$a_i\in\cwBNodes\cap\Proc \Leftrightarrow \{ (a_i,\obj{a_j}{a_i}) \mid
a_j\in\ctx \vee a_j\in\cwBNodes\cap\Proc)
\}\subseteq\cwBEdges$
\item
$P\in\cwBNodes\cap\Obj \Leftrightarrow 
	\{ (P,\langle P,\abstr \zeta\rangle) \mid \zeta\in\BS(P) \}\subseteq\cwBEdges$
\item
$\langle P, nls \rangle\in\cwBNodes\cap\NSol \Leftrightarrow
	\{ (\langle P,nls\rangle, ls) \mid ls\in nls \}\subseteq\cwBEdges$
\item
$ls \in\cwBNodes\cap\sSol \Leftrightarrow
	\{ (ls, a_i) \mid a_i\in ls \}\subseteq\cwBEdges$
\item
$\obj{a_i}{a_j}\in \cwBNodes\cap\Obj \Rightarrow 
	\{(\obj{a_i}{a_j},\obj{a_k}{a_j}) \mid a_k\neq a_j,$
\\
\hspace*{4cm}
$a_k\in \conn_{(\cwBNodes,\cwBEdges)}(\langle\obj{a_i}{a_j},\abstr\zeta\rangle),$
\\
\hspace*{4cm}
$\zeta\in\BS(\obj{a_i}{a_j}) \}\subset\cwBEdges$
\end{enumerate}
with $\abstr\zeta \DEF \{\PHhitter(\zeta_n) \mid n\in\indexes\zeta \}$.
\end{definition}



\subsection{Sufficient condition for reachability of a local state}
\label{ssec:ua}

Given a context $\ctx$ and a local state $p\in\Proc$, the LCG $\cwB$ contains a set of objectives
that can be used to build a concrete scenario reaching $p$.
Because we are focused on sufficient conditions for reachability, we do not require that all
possible scenarios can be derived from the LCG.

In this section, we prove that if the LCG has no cycle, if all its nodes in $\Obj$ have at least one
child, and if all its nodes in $\sSol$ satisfy a
particular criteria, so-called independence, then from any state
delimited by the context $\ctx$, there exists a scenario that reaches $p$
(\pref{th:approxinf}).

A node $x$ of the LCG in $\sSol$ is \emph{independent} (\pref{def:coherent}) if for each local state
$a_i\in x$, none of the other local state $b_j\in x$ have a local state of automaton $a$ different
than $a_i$ in their descendants.
This criteria ensures that once a local state in $x$ has been reached, reaching another local state
in $x$ should not require to change the first local state.

\begin{definition}[Independent synchronisations]
\label{def:coherent}
  In a LCG $\cwB = (\Bv, \Be)$,
  a node $x \in \Bv\cap\sSol$ is \emph{independent} if and only if
  for each $a_i\in x$,
  for each $b_j\in x, b_j\neq a_i$,
  $a_k \in\conn_{\cwB}(x) \cap \Proc \Rightarrow a_k = a_i$.
\end{definition}

The intuition is the following.
Given a state $s\subset\ctx$, we recursively refine the initial objective (reaching $p$ from the initial
state) according to its children.
As the LCG is acyclic, such a recursion always terminates, and as all the objective nodes have at
least one child, it never get stuck.
The refinement of an objective node $\obj{a_i}{a_j}$ acts as follows:
if the node has another objective node $\obj{a_k}{a_j}$ as child, we first refine the objective
$\obj{a_i}{a_k}$ (which, by construction, is necessarily in the LCG)
and then will refine the objective $\obj{a_k}{a_j}$.
If the objective nodes has only nodes in $\Sol$ (bounce sequences), one is picked arbitrarily.
If $\langle P, nls\rangle$ is the chosen node,
by construction there exists $\zeta\in\BS(P)$ such that $\abstr\zeta = nls \in \powerset(\sSol)$.
If $\zeta = \emptyseq$ (for instance in the case when $a_i = a_j$), the recursion stops and we
continue to the next stage.
Otherwise, for each $n\in\indexes\zeta$,
for each $b_i \in\PHhitter(\zeta_n)$,
we refine the objective $\obj{b_j}{b_i}$ where $b_j$ is the state of $b$ in the current state.
By induction, $\obj{b_j}{b_i}$ is a child of $b_i$ in the LCG of \pref{def:lcg}.
Then, we know (by induction) that the current state of $b$ is $b_i$.
After having repeated this procedure for each $b_i\in\PHhitter(\zeta_n)$,
because all the nodes in $\sSol$, and in particular $\PHhitter(\zeta_n)$, are independent,
we know that all the local states in $\PHhitter(\zeta_n)$ are in the current state.
In addition, we know that the state of automaton $a$ has remained unchanged, otherwise
$\obj{a_i}{a_j}$ would have an objective child.
Hence, the action $\zeta_n$ is playable in the current state.
We apply this action, modifying the state of $a$ to $a_j$ and continue to the next stage.
At the end, this recursive procedures builds a scenario from $s\subset\ctx$ to a state containing $p$.

\begin{theorem}[Under-approximation]
\label{th:approxinf}
  Given an AAN $(\PHs; \PHl; \PHa)$,
  a context $\ctx$ and an objective sequence $\w$,
  if the LCG $\cwB$ contains no cycle,
  all nodes in $\Obj$ have at least one child,
  and all nodes in $\sSol$ are independent,
  then for any state $s\in\PHl$ such that $s\subset\ctx$,
  there exists a scenario $\delta\in\Sce$ with $p\in s\play\delta$.
\end{theorem}

\modMF{
Regarding the complexity of the method,
computing the LCG is polynomial in the number of automata in $\PH$ and exponential in the number of local states in one automaton.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
Therefore, the building and checking process can be considered as polynomial in the size
of the AAN, provided that each automaton only contains a few local states.
We note that this is particularly true for biological models, where
each component usually contains a limited number of expression levels.
}

We note furthermore that the method does not require any completeness of the bounce sequences
$\BS$.
Therefore, in order to reduce the number of bounce sequences to consider, and potentially removing
cycles and non-satisfying nodes,
one can consider only a sub-set of, or single, bounce sequences for each objectives.
However, such an approach would imply to enumerate all possible combinations of bounce sequences
subsets, hence being exponential in the number of objectives having at least two bounce sequences.


\begin{example}
  \moda{%
  If we confider the AAN of \pref{fig:ph-livelock},
  from the initial state $\PHstate{a_1, b_0, c_0}$ depicted,
  the under-approximation given in \pref{th:approxinf}
  does not conclude regarding the reachability of $c_1$.
  This is due to the fact that the node $\{ a_1, b_1 \} \in \Bv \cap \sSol$
  is not coherent because of its successor $a_0$ (and $b_0$).
  (However, from the inconclusiveness of \pref{th:approxinf},
  one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance
  with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  }%
  
  \modMF{%
  This result is new compared to the method proposed in~\cite{PMR12-MSCS}.
  Indeed, the representation based on the Process Hitting that was proposed
  in this paper only allowed to represent “over-approximated” Boolean gates
  with the use of cooperative sorts.
  This especially did not allow to model the fact that $a_1$ and $b_1$ could not
  be activated in the same state, but only in successive states.
  Thus, when using Process Hitting, $c_1$ was indeed reachable,
  contrary to the behaviour expected from an accurate Boolean gate.
  }%
  
  \moda{%
  Finally, we note however that,
  if $\PHhits{a_0}{b_0}{b_1}$ and $\PHhits{b_0}{a_0}{a_1}$ are replaced by the actions
  $\PHhitm{a_0}{a_1}$ and $\PHhitm{b_0}{b_1}$,
  then the resulting saturated graph of local causality changes, and
  \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.
  The reader can also refer to \pref{ssec:ex-metazoan}
  for a detailed conclusive example.
  }%

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
%    \node[Aobj] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[Assol,below of=c01s] (a1a1ss) {$\{ a_1, b_1 \}$};
    \node[Aproc,below left of=a1a1ss] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Assol,below of=a11s] (na11s) {$\emptyset$};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Assol,below of=a01s] (a01ss) {$\{b_0\}$};
    \node[Aproc,below of=a01ss] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Assol,below of=b00s] (nb00s) {$\emptyset$};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};
    \node[Assol,below of=b10s] (nb10s) {$\emptyset$};

    \node[Aproc,below right of=a1a1ss] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Assol,below of=b11s] (nb11s) {$\emptyset$};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Assol,below of=b01s] (b01ss) {$\{a_0\}$};
    \node[Aproc,below of=b01ss] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Assol,below of=a00s] (na00s) {$\emptyset$};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};
    \node[Assol,below of=a10s] (na10s) {$\emptyset$};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (a1a1ss)
    (a1a1ss) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (a01ss)
    (a01ss) edge (b0)
    (a11) edge (a11s)
    (a11s) edge (na11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a10s) edge (na10s)
    (a00) edge (a00s)
    (a00s) edge (na00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b10s) edge (nb10s)
    (b00) edge (b00s)
    (b00s) edge (nb00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (b01ss)
    (b01ss) edge (a0)
    (b11) edge (b11s)
    (b11s) edge (nb11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The saturated graph of local causality of the AAN in \pref{fig:ph-livelock}
    for the objective $\w = \PHobj{c_0}{c_1}$
    and the initial context $\ctx = \PHstate{a_1, b_0, c_0}$.
    Elements in $\Proc$ are represented by rectangular nodes,
    elements in $\Sol$ are represented by circle nodes,
    and elements in $\sSol$ and $\Obj$ are the remaining borderless nodes.
    \pref{th:approxinf} is inconclusive on this example as node $\{ a_1, b_1 \}$
    is not coherent (see \pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a successor of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$
    (and the same also stands for $b_0$).
  }
\end{figure}
\end{example}



\subsection{Reachability of a State}
\label{ssec:simult-ua}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The reachability property studied so far concerns a single local state at a time.
However, we remark that the reachability of a global state or a sub-state can be
addressed with the very same analysis by introducing a dedicated automata.
Such analysis was not possible with the Process Hitting framework,
because of the lack of the notion of simultaneity for more than two components.

In order to check the reachability of a global state $s \in \PHl$,
let $\PH = (\PHs, \PHl, \PHh)$ be an AAN.
We define a new AAN $\PH' = (\PHs', \PHl', \PHh')$ with:
$\PHs' = \PHs \cup \{ \reach \}$, $\PHl' = \PHl \times \PHl_\reach$,
where $\PHl_\reach = \{ \reach_0, \reach_1 \}$,
and $\PHh' = \PHh \cup \{ \PHhit{\toset{s}}{\reach_0}{\reach_1} \}$.
Given an initial context $\ctx$, the reachability of $s$ in $\PH$
is equivalent to the concretisation of $\PHobjp{\reach}{0}{1}$ in $\PH'$
from the initial context $\ctx \cup \{ \reach_0 \}$,
which can be efficiently under-approximated using \pref{th:approxinf}.

It is of course also possible to compute the reachability
of a sub-state $s \in \PHsubl[\PHl]_S$ of a set of components $S \subseteq \PHs$
with the same method.
One can also check the reachability of a set of states $\Lambda \subseteq \PHl$
by creating several actions
$\PHhit{\toset{s}}{\reach_0}{\reach_1}$ in $\PHh$ for each state $s \in \Lambda$.


\subsection{Sequential Under-approximation}
\label{ssec:ordered-ua}

In this section, we briefly explain an alternative sufficient condition that
can be applied when looking for scenarios that successively reach a sequence of local states (e.g.,
first reach $a_j$, then later $b_k$, \ldots).

The approach proposed in this sub-section essentially applies the previous under-approximation for
the first local states, and then computes a set of contexts that may be considered as the starting
point for the next local states.
In that way, the local states to reach are taken into account separately, which implies that only a
subset of scenarios can be captured.
%However, because each iteration focuses on a smaller part of the network, this
%sequential under-approximation may be more conclusive.


\todo{computes possible outcomes from the LCG, gives it as context for the next stage}.


\modMF{
\subsection{Extraction of a Scenario}
\label{ssec:concret}
}

\modMF{
This section gives a recursive method to find a scenario that concretizes
a given objective sequence $\w \in \OS$.
All the definitions above are well-defined provided that
$\uconcr(\w)\neq\emptyset$,
which can be demonstrated by \pref{th:approxinf} or \pref{thm:ordered-ua}.
The justification of these definitions can be found by analysing the demonstrations
of these theorems.
}

\newcommand{\res}{\mathbf{res}}
\newcommand{\osres}{\mathbf{OSres}}
\newcommand{\autoBS}{\mathbf{autoBS}}
\newcommand{\rec}{\mathbf{rec}}
% \newcommand{\thisobj}[1]{P_{#1}}
% \newcommand{\thisseq}[1]{\Theta_{#1}}
\newcommand{\thisobj}{P}
\newcommand{\thisseq}{\Theta}
\newcommand{\R}{R}

\modMF{%
First, $\osres$ is used to split the objective sequence $\w$ to solve,
by considering successive objectives, in the fashion of \pref{thm:ordered-ua}.
This function calls $\res$ which allows to solve an objective $P$
by either re-target it (if $\gCont(\PHsort(P), P) \neq \emptyset$)
of by searching for a solution to this objective in $\BS(P)$.
This search may require to try several objective sequences $\zeta \in \BS(P)$.
For each trial, the chosen objective sequence $\zeta$ is solved with $\rec$,
which recursively created a scenario to play the whole sequence.
This scenario is itself recursively created by combining
smaller scenarios allowing to reach each required hitter of each action
with the function $\thisseq$.
Finally, $\thisseq$ calls $\res$ anew to reach the hitters
that are necessarily contained in other automata.
In the end, a scenario can be obtained by analysing all values of
$\osres_s(\w)$ (\pref{def:concret})
for all possible initial state $s \subseteq \ctx$ in the considered context,
and all possible bounce sequences $\zeta \in \BS(P)$ that are chosen during the resolution.
}%

\begin{definition}[$\osres : \PHl \times \OS \to \Sce$]
\label{def:concret}
\modMF{%
For all $s \in \PHl$ and $\w \in \OS$, we define:
\[
  \osres_s(\w) \DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\w = \emptyseq$} \\
      \res_s(\w_1) \concat
      \osres_{s \play \res_s(\w_1)}(\w_2 \concat \dots \concat \w_{\card{\w}})
        & \text{ otherwise} \\
    \end{cases}
\]
and, for all $s \in \PHl$ and $P \in \Obj$:
\[\res_s(P) \DEF
  \begin{cases}
    \varepsilon
      & \text{if } \target{P} = \bounce{P} \\
    \osres_s(P^Q \concat Q)
      & \text{if } \exists Q \in \Obj, (P, Q) \in \Bee{\Obj}{\Obj} \\
    \rec_s(\zeta)
      & \text{otherwise, with } \zeta \in \BS(P)
  \end{cases}
\]
with $P^Q = \PHobj{\PHtarget(P)}{\PHtarget(Q)}$.
Furthermore:
\begin{align*}
  \forall \zeta \in \BS,
  \rec_s(\zeta) &\DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\zeta = \emptyseq$} \\
      \thisseq_s(\zeta_1) \concat \zeta_1 \concat
      \rec_{s \play \thisseq_s(\zeta_1) \concat \zeta_1}
      (\zeta_2 \concat \dots \concat \zeta_{\card{\zeta}})
        & \text{ otherwise}
    \end{cases} \\
  \forall h \in \PHh,
  \thisseq_s(h) &\DEF
    \begin{cases}
      \emptyseq
        & \text{ if $\hitter{h} = \emptyset$} \\
      \R_s(h_1) \concat \thisseq_{s \play \R_s(h_1)}(h_2 \concat \dots \concat h_{\card{h}})
        & \text{ otherwise}
    \end{cases} \\
  \forall a_i \in \Proc,
  \R_s(a_i) &\DEF \res_s(\PHobj{\PHget{s}{\PHsort(a_i)}}{a_i})
\end{align*}
and for all action $h \in \PHh$, $(h_i)_{i \in \segm{1}{\card{\hitter{h}}}}$
is a sequence containing all hitters of $h$ in an arbitrary order.
}
\end{definition}
