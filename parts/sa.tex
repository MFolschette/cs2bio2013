\section{Static analysis}\label{sec:sa}

\towrite{Mettre de la colle}

\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  The reachability of a process $a_j$ prof a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj = \{ \PHobj{a_i}{a_j} \mid a \in \PHs \wedge (a_i, a_j) \in \PHl_a^2 \}$.
  For an objective $P \in \Obj$, where $P = \PHobj{a_i}{a_j}$, $\PHsort(P) = a$, $\PHtarget(P)=a_i$, $\PHbounce(P)=a_j$.
  An objective $P$ is \emph{trivial} is $\PHtarget(P)=\PHbounce(P)$.
\end{definition}

\begin{definition}[Context $\ctx$ ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}

For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$, and
$ps \in \powerset(\Proc), ps \subseteq \ctx \Leftrightarrow \forall a_i \in ps, a_i \in \ctx$.
%The override of a context $\ctx$ by a set of processes $ps$ is noted $\ctx \Cap ps$ (\defref{ctxcap}).
%Par exemple, $\state{a_1,a_2,b_1,c_1}\Cap\{ a_3, b_2, b_3 \} = \state{a_3,b_2,b_3,c_1}$.
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \mapsto \Ctx$]
\label{def:ctxcap}
  For a given context $\ctx\in\Ctx$ and a set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} =
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}

A scenario $\delta \in \Sce$ is \emph{playable} in a context $\ctx$ if and only if $\supp(\delta) \subseteq \ctx$. 
The play of $\delta$ in $\ctx$ is denoted $\ctx \PHplay \delta$ where $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$.

\begin{definition}[Objective sequence ($\OS$)]
\label{def:OS}
\towrite{Simplifier / réécrire en dehors d'une def}
  An \emph{objective sequence} is a sequence $\w = P_1 \concat \dots \concat P_{|\w|}$,
  where $\forall n \in \indexes{\w}, \w_n \in \Obj$ and $a_i = \PHtarget(\w_n) \Rightarrow \last_a(\w_{1..n-1}) \in \{ \varnothing, a_i \}$.
  The set of all objective sequences is denoted by $\OS$.
  The definitions of $\last_a$ \todo{À définir}, $\first_a$ \todo{À définir}, $\supp$ \todo{À définir} and $\ceil$ \todo{À définir}
  are simply derived by omitting the case of hitters.
\end{definition}

\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) = \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  Obviously, $\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$.
\end{definition}

\begin{definition}[$\aBS:\Obj \mapsto \powerset(\Proc)$]
\label{def:aBS}
  \[
    \aBS(P) = \{ \abstr{\zeta} \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  where $\abstr{\zeta} = \{ \PHhitter(\zeta_n) \mid  n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$.
\end{definition}



\subsection{Under-approximation}

\begin{definition}[$\concr: \OS \mapsto \powerset(\Sce)$]
\label{def:concr}
\towrite{Simplifier ? Supprimer la def formelle ?}
  For a given $\w \in \OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the context $\ctx$:
  \begin{align*}
    \concr(\w) = \{ \delta \in \Sce \mid & (\w^\vartriangle = \emptyseq \wedge \delta = \emptyseq) 
      \vee (\w^\vartriangle \neq \emptyseq \wedge \supp(\delta) \subseteq \ctx
    \\ &
      \wedge \exists \phi:\indexes{\w} \mapsto \indexes{\delta}, (\forall n, m \in \indexes{\w}, n < m \Leftrightarrow \phi(n) \leq \phi(m)) 
    \\ &
      \wedge \forall n \in \indexes{\w}, \PHbounce(\w_n) \in \ctx \PHplay \delta_{1..\phi(n)})
    \}
    \enspace,
  \end{align*}
  where $\omega^\vartriangle$ refers to the sequence of objectives $\omega$ where the trivial objectives have been removed.
\end{definition}
%
\begin{definition}[$\concr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:concr-set}
  $\concr(\W) = \{ \delta \in \concr(\w) \mid \w \in \W \} \enspace.$
\end{definition}

\begin{definition}[$\uconcr: \OS \mapsto \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \uconcr(\w) = 
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \supp(\delta) \subseteq s \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{theorem}
\label{th:uconcr-ctx}
  $\ctx' \subseteq \ctx \wedge \uconcr(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx'}(\w) \neq \emptyset \enspace.$
\end{theorem}
% 
\begin{definition}[$\uconcr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:uconcr-set}
  $\uconcr(\Omega) = \{ \delta \in \uconcr(\w) \mid \w \in \Omega\}$
\end{definition}

The set of all processes involved in an abstract structure $\cwB$ is given in \pref{def:allprocs}.
\begin{definition}
\label{def:allprocs}
  \begin{align*}
  &\allprocs((\cwSol,\cwReq,\cwRSP,\cwCont)) = \{ p \in \PHproc \mid \exists (P,ps) \in \cwSol, \\
    &\qquad\qquad p \in ps \vee p = \PHtarget(P) \vee p = \PHbounce(P) \} \\
  %  &\qquad\qquad \vee p = \PHtarget(P) \vee \exists h \in \BS(P), (p = \PHhitter(h) \vee p = \PHbounce(h)) \\
  %  &\qquad\qquad \vee \exists(Q, \PHobj{p}{\PHbounce(Q)} \in \cwPrioCont \}
  \end{align*}
\end{definition}



\subsection{Abstract structure}

\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \mapsto \powerset(\Proc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) = 
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

\begin{definition}
  \label{def:aS}
  The abstract structure $\cwB=(\Breq,\Bsol,\Brsp,\Bcont)$ is defined as
  $\cwB = \sfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs_\ctx(\myB)}}$,\\
  with $\myB=(\myreq,\mysol,\myrsp,\mycont)$:
  \begin{align*}
    \myreq &= \{ (a_i,\PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid
      a \in \components \wedge a_j \in \PHget{\ctx}{a} \\ % \vee a_j \in \pfpprocs_\ctx(a) \\
      & \qquad \wedge ((\exists (P,ps) \in \mysol \vee \exists (b_j, ps) \in \myrsp), a_i \in ps \\
      & \qquad\qquad \vee \exists n \in \indexes{\w}, \PHbounce(\w_n)=a_i) \}
    \\
    \mysol &\subseteq \{ (P,ps) \in \Obj \times \powerset(\PHproc) \mid
            \exists (a_i, P) \in \myreq \wedge ps \in \aBS(P) \\
      & \qquad\qquad \vee \exists (Q, P) \in \mycont \wedge ps \in \aBS(P) \}
    \\
    \myrsp &= \{ (a_i,ps) \in \PHproc \times \powerset(\PHproc) \mid a \in \cs \\
      & \qquad \wedge (\exists (P,ps') \in \mysol \vee \exists (b_j,ps') \in \myrsp), \\
      & \qquad\qquad a_i \in ps' \wedge \csState(a_i) \in ps \}
    \\
    \mycont & = \{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid
      \exists (P, ps) \in \mysol \\
      & \qquad\qquad \wedge q \in \gCont_\ctx(\PHsort(P),P) \}
  \end{align*}
\end{definition}

\begin{definition}[Coherent solution]
\label{def:coherent}
  A cooperative sort requisite $(a_i, ps)$ in $\myrsp$ is said coherent iff
  it has no successor $(b_k,\PHobjp{b}{j}{k})$ in $\myreq$ so that there exists $b_n \in ps$, $b_k \neq b_n$.
\end{definition}

\begin{theorem}[Approximation inf.]
\label{th:approxinf}
  If the graph $\cwB$ contains no cycle,
  all objectives have at least one solution
  and all cooperative sort requisites are coherent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

\begin{proof}
We note $max\ctx = \ctx \Cap \allprocs(\cwB)$ the context supported by $\cwB$.

Let $(a_i, ps) \in \Brsp$ be a cooperative sort requirement whom all children are concretizable.
We label all processes of $ps$ by an integer: $ps = \{ p_n \}_{n \in \indexes{ps}}$.
Let us prove that for all $n \in \indexes{ps}$, there exists a scenario $\delta_n$ so that:
$\forall i \in \segm{1}{n}, \PHget{(s \PHplay \delta_n)}{\PHsort(p_i)} = p_i$.
\begin{itemize}
  \item It is straightforward for $\delta_0 = \varepsilon$.
  \item Let us suppose such $\delta_n$ exists. \todo{Il faut être plus précis pour prendre en compte les coopérations en cascade}
    By hypothesis, there exists $\delta' \in \muconcr_{s \PHplay \delta_n}(\PHobj{\any}{p_n})$.
%    so that: $\PHget{(s \PHplay \delta_n \PHplay \delta')}{\PHsort(p_{n+1})} = p_{n+1}$.
    By hypothesis, $(a_i, ps)$ is coherent (\pref{def:coherent}), which means that solving $p_{n+1}$ does not disturb the processes of $ps$.
    Therefore, $\forall i \in \segm{1}{n+1}$, $\PHget{(s \PHplay \delta_n \PHplay \delta')}{\PHsort(p_{i})} = p_{i}$.
    Finally, by \pref{th:update}, there exists a scenario $\delta'' \in \restriction{\Sce}{1}$
    that can be played in $s \PHplay \delta_n \PHplay \delta'$
    and so that, if we denote $\delta_{n+1} = \delta_n \PHplay \delta' \PHplay \delta''$,
    we have: $\update(s \PHplay \delta_n \PHplay \delta') = s \PHplay \delta_{n+1}$ and the same property about processes (by \pref{th:hcscomp}).
\end{itemize}
Therefore, $\delta = \delta_{\indexes{ps}}$ exists, and given its properties, we have: $\PHget{(s \PHplay \delta)}{a} = a_i$
and $\update(s \PHplay \delta) = s \PHplay \delta$.

As there is no cycle in $\cwB$, we show by induction that $\forall s\in L, s\subseteq max\ctx$, 
for all objective $P$ in $\cwB$ so that $\PHtarget(P) \in s$,
$\exists \delta \in \muconcr_s(P)$.% and $\ceil(\delta) \subseteq max\ctx$.

\begin{itemize}
  \item If $(P, \emptyset) \in \Bsol$, either $\PHtarget(P) = \PHbounce(P)$ and $\delta = \emptyseq$,
    or $\forall \zeta \in \BS(P), \zeta \in \Sce \wedge \PHsort(\zeta) = \{ \PHsort(P) \}$ and $\delta$ is given by \pref{th:autohits}.

  \item Suppose all children objectives of $P$ are concretizable.
  \begin{itemize}
    \item If $\exists (P, Q) \in \Bcont$, then by hypothesis,
      $\muconcr_{s}(\obj{\PHtarget(P)}{\PHtarget(Q)} \concat Q) \neq \emptyset$, thus
      $\muconcr_{s}(P) \neq \emptyset$.
    \item Else, by \pref{def:maxCont}, the concretizations of the children of $P$ require no process of sort $\PHsort(P)$.
      Furthermore, there exists $\zeta \in \BS(P)$ so that $(P, \aZ) \in \Bsol$.
      We show by induction that for all $n \in \indexes{\zeta}$, there is a scenario $\delta_n$ so that $\PHget{(s \PHplay \delta_n)}{\PHsort(P)} = \PHbounce(\zeta_n)$.
%      We build recursively a scenario $\delta$. Let $m = |\indexes{\zeta}|$.
      \begin{itemize}
        \item[*] Suppose that $\delta_n$ exists and let $\zeta_n = \PHhit{b_i}{a_j}{a_k}$.
        By hypothesis there exists $\delta' \in \muconcr_{s \PHplay \delta_n}(\PHobj{\any}{b_i})$ with $\PHsort(P) \notin \PHsort(\delta')$ by \pref{def:maxCont}.
        By \pref{th:update} there exists $\delta'' \in \restriction{\Sce}{1}$ so that $\update(s \PHplay \delta') = s \PHplay \delta' \PHplay \delta''$.
        Furthermore, $\PHget{(s \PHplay \delta' \PHplay \delta'')}{b} = b_j$ (by \pref{th:hcompcomp} if $b \in \components$ or \pref{th:hcscomp} if $b \in \cs$).
        Therefore, $\delta_{n+1} = \delta_n \PHplay \delta' \PHplay \delta'' \PHplay \zeta_n$.
      \end{itemize}
      Thus, $\delta_{\indexes{\zeta}} \in \muconcr_s(P)$. % and $\ceil(\delta) \subseteq max\ctx$.
  \end{itemize}
\end{itemize}
Finally, as $\muconcr_{max\ctx}(\w) \neq \emptyset$, $\uconcr(\w) \neq \emptyset$ (\pref{th:uconcr-ctx}).
\end{proof}



\begin{figure}
  \centering
  \begin{tikzpicture}[aS,node distance=1.5cm]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};
    
    \node[Aproc,below of=c01s] (ab11) {$ab_{11}$};
    \node[Aobj,below right of=ab11] (ab0111) {$\PHobj{ab_{01}}{ab_{11}}$};
    \node[Asol,below of=ab0111] (ab0111s) {};
    \node[Aobj,below of=ab11,node distance=2.5cm] (ab0011) {$\PHobj{ab_{00}}{ab_{11}}$};
    \node[Asol,below of=ab0011] (ab0011s) {};
    \node[Aobj,below left of=ab11] (ab1011) {$\PHobj{ab_{10}}{ab_{11}}$};
    \node[Asol,below of=ab1011] (ab1011s) {};

    \node[Aproc,below of=ab0111s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below right of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below right of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below of=ab1011s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge (ab0011) edge (ab0111) edge (ab1011)
    (ab0011) edge (ab0011s)
    (ab1011) edge (ab1011s)
    (ab0111) edge (ab0111s)

    (ab0011s) edge (a1) edge (b1)
    (ab1011s) edge (b1)
    (ab0111s) edge (a1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10)
    (a10) edge (a10s)
    
    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01)
    (b01) edge (b01s)
    (b01s) edge (a0)
    ;
    \path
    (ab0011) edge[double] (ab0111)
    (ab0011) edge[double,bend right=10] (ab1011)
    (ab1011) edge[double,bend right=10] (ab0011)
    (ab0111) edge[double,bend right=10] (ab1011)
    (ab1011) edge[double,bend right=10] (ab0111)
    ;
    \end{tikzpicture}
  \label{fig:sa-livelock}
  \caption{The local causality graph of the PH in \pref{fig:ph-livelock}.}
\end{figure}

