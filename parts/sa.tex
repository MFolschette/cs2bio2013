% vi:spell spelllang=en:
\section{Static Analysis}\label{sec:sa}

The aim of this section is to define the problem of reachability in a PH,
and propose an under-approximation allowing to efficiently solve it.
The static analysis presented here is inspired from~\cite{PMR12-MSCS}.

We consider in this section a PH model $\PH = (\PHs; \PHl; \PHa^{\langle 2 \rangle})$ with $2$ classes of priorities
that respects all conditions (\ref{cr:bounded} \& \ref{cr:compcs}) of \pref{ssec:hypothesis}.



\subsection{Preliminary definitions}
\label{ssec:sa-def}

The reachability of a process $a_j$ of a given sort $a$ from another process $a_i$ is called an objective and is denoted $\PHobjp{a}{i}{j}$ (\pref{def:obj}).
\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  If $a \in \components$, the reachability of a process $a_j$ from a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a \times \PHl_a \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) = a$, $\PHtarget(P)=a_i$, $\PHbounce(P)=a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same sort, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

A context (\pref{def:context}) extends the notion of state to a set of possible initial states.
We also extend the override operator to contexts (\pref{def:ctxcap}).
\begin{definition}[Context ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}
%
\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \rightarrow \Ctx$]
\label{def:ctxcap}
  For any $\ctx\in\Ctx$ and set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by:
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} =
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}
\noindent
For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc)$ or $ps \in \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last process in the sequence $\delta$ (hitter or bounce) of every sort mentioned in $\delta$.

Finally, a bounce sequence on a sort $a$ (\pref{def:bs}) is a sequence of actions hitting $a$
in which the bounce process of each action is the hitter process of the following action.
Bounce sequences are used to find local solutions to a given objective.
A bounce sequence on $a$ can be abstracted into sets of all its hitters that are not in sort $a$ (\pref{def:aBS}).
This abstraction allows to propagate an objective on the sort $a$ into objectives on other sots.
In the following, we denote: $\Sol = \powerset(\PHproc)$.
\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) = \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$ and $\emptyseq \in \BS(\obj{a_i}{a_i})$.
\end{definition}
%
\begin{definition}[$\aBS:\Obj \rightarrow \powerset(\Sol)$]
\label{def:aBS}
  The \emph{abstractions of bounce sequences} of an objective $P$, denoted by the set $\aBS(P)$, are the sets of hitters of bounce sequences solving $P$:
  \[
    \aBS(P) = \{ \abstr{\zeta} \in \Sol \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  where $\abstr{\zeta} = \{ \PHhitter(\zeta_n) \mid  n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$.
\end{definition}



\subsection{Under-approximation}

We denote $\concr(\w)$ the set of scenarios concretising an objective sequence $\w$ in the context $\ctx$.
In \pref{def:uconcr}, we define $\uconcr(\w)$ as equal to $\concr(\w)$ if and only if $\concr(\w)$ contains scenarios starting from all states $s \subseteq \ctx$.
\pref{lem:uconcr-ctx} is used to over-approximate the initial context $\ctx$.
\begin{definition}[$\uconcr: \OS \rightarrow \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \uconcr(\w) = 
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \delta \in \Sce(s) \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{lemma}
\label{lem:uconcr-ctx}
  $\ctx \subseteq \ctx' \wedge \muconcr_{\ctx'}(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx}(\w) \neq \emptyset$.
\end{lemma}

For any objective $P$ and context $\ctx$, \pref{def:maxCont} gives the set of processes of sort $\PHsort(P)$ that are required to solve $P$ in $\ctx$, given by $\gCont_\ctx(\PHsort(P), P)$.
\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \rightarrow \powerset(\PHproc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) = 
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

The graph of local causality $\cwB = (\V, \E)$ defined in \pref{def:glc} is a graph where $\V \subseteq \Proc \cup \Obj \cup \Sol$ and $\E \subseteq \V \times \V$.
A node in $\PHproc$ is a required process,
a node in $\Obj$ is an objective to reach a given process
and a node in $\Sol$ is a set of processes required for the solving.
An objective $P \in \Obj$ is solvable if the abstractions of bounce sequences $\aBS(P) \in \Sol$ (\pref{def:aBS}) can be reached (\pref{eq:ESol1}), thus leading to several required processes (\pref{eq:ESol2}).
If $a \in \components$, the reachability of one of its process $a_i$ is approximated by the ability to solve all objectives $\PHobjp{a}{j}{i} \in \Obj$ for all $a_j$ in the initial context (\pref{eq:EReq});
if $a \in \cs$, the reachability of $a_i$ is simply solved by the set of processes $\csState(a_i)$ (\pref{def:csState}) that it represents (\pref{eq:EPrio}).
The solving of an objective $P$ may require a process of $\PHsort(P)$, \ie $\gCont(\PHsort(P), P) \neq \emptyset$ (\pref{def:maxCont}); in this case, $P$ is re-targeted (\pref{eq:ECont}).
\pref{eq:Vw}, \eqref{eq:Vproc} and~\eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Finally, as the active process of every sort may evolve, $\cwB$ is obtained by iteratively saturating with every process it contains,
\ie by overriding its initial context $\ctx$ by $\allprocs(\V, \E)$, defined by:
$$\allprocs(\V, \E) = (V \cap \Proc) \cup \{ \PHtarget(P), \PHbounce(P) \mid P \in \V \cap \Obj \}$$

\begin{comment}
The reachability of a process $a_i$ is approximated by the ability to solve all objectives $\PHobjp{a}{j}{i}$ for all $a_j$ in the initial context.
To this end, the abstractions of bounce sequences (\pref{def:aBS}) solving these objectives are computed, leading to new required processes, and thus new objectives on other sorts.
Thus, the graph of local causality $\cwB = (\V, \E)$ defined in \pref{def:glc} is a graph where $\V \subset \Proc \cup \Obj \cup \Sol$ and $\E \subset \V \times \V$
in which edges link any required process $a_i$ in $\Proc$ to all corresponding objectives $P$ in $\Obj$,
and any objective $P$ to abstractions of bounce sequences $ps \in \Sol$ (\pref{def:aBS}) solving this objective;
such sets $ps$ then stand for new required processes.
In the case where a process $a_i$ belongs to a cooperative sort, it is directly linked to the set of the processes $\csState(a_i)$ (\pref{def:csState}) that it represents.
If the solving of an objective $P$ requires a process of $\PHsort(P)$, a continuity edge is added to re-target this objective (\pref{def:maxCont}).
Finally, as the active process of every sort may evolve, $\cwB$ is obtained iteratively by saturation with every process it contains,
\ie by overriding its initial context $\ctx$ by $\allprocs(\V, \E)$, defined by:
$$\allprocs(\V, \E) = (V \cap \Proc) \cup \{ \PHtarget(P), \PHbounce(P) \mid P \in \V \cap \Obj \}$$
\end{comment}

\begin{definition}
\label{def:glc}
  The graph of local causality $\cwB = (\Bv, \Be)$ is defined as: $\cwB = \lfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs(\myB)}}$,
  where $\myB = (\cwV, \cwE)$ is the smallest graph with
  $\cwV \subseteq \Proc \cup \Obj \cup \Sol$ and $\cwE \subseteq \cwV \times \cwV$
  so that:
  \begin{align}
    \w &\subseteq \cwV \label{eq:Vw} \\
    P \in \VProc &\Rightarrow \PHbounce(P) \in \cwV \label{eq:Vproc} \\
    (x, y) \in \E &\Rightarrow y \in \cwV \label{eq:VE} \\
    P \in \VObj \wedge ps \in \BS(P) &\Rightarrow (P, ps) \in \cwE \label{eq:ESol1} \\
    ps \in \VSol \wedge a_i \in ps &\Rightarrow (ps, a_i) \in \cwE \label{eq:ESol2} \\
    a \in \components \wedge a_i \in \VProc \wedge a_j \in \ctx &\Rightarrow (a_i, \PHobjp{a}{j}{i}) \in \cwE \label{eq:EReq} \\
    a \in \cs \wedge a_i \in \VProc \wedge ps \in \csState(a_i) &\Rightarrow (a_i, ps) \in \cwE \label{eq:EPrio} \\
    P \in \VObj \wedge q \in \gCont_\ctx(\PHsort(P), P) &\Rightarrow (P, \PHobj{q}{\PHbounce(P)}) \in \cwE \label{eq:ECont} \!
  \end{align}
\end{definition}

\begin{comment}
\pref{eq:Vw}, \eqref{eq:Vproc} and \eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Elements in $\PHproc$ are required processes,
elements in $\Obj$ are the objectives to reach these processes
and elements in $\Sol$ are the sets of processes that allow to solve these objectives.
\pref{eq:ESol1} links an objective $P$ to its solutions in $\BS(P)$
and \pref{eq:ESol2} links a solution $ps$ to the processes $a_i \in ps$ it contains.
Then, \pref{eq:EReq} links a required component process $a_i$ to all objectives $\PHobjp{a}{j}{i}$ with $a_j \in \ctx$
while \pref{eq:EPrio} links a required cooperative sort process $a_i$ to its solutions in $\csState(a_i)$.
Finally, if the resolution of an objective $P$ requires a process of $\PHsort(P)$, then \pref{eq:ECont} re-targets this objective ($\gCont$).
\end{comment}

In the graph of local causality, an edge $(p, ps) \in \Proc \times \Sol$ %linking a process of a cooperative sort to a solution set $ps$
is said coherent (\pref{def:coherent}) if none of the processes in $ps$ conflict with the children processes of $ps$.
Then, \pref{th:approxinf} gives a sufficient condition for the concretization of a sequence of objectives in a given context,
which is derived immediately from the graph of local causality.
A proof of this theorem is given in \pref{suppl:demoapproxinf}.
\begin{definition}[Coherent edge]
\label{def:coherent}
  An edge $(x, y) \in \cwE$ is said coherent if and only if:
  $(x, y) \in \Be \cap (\Proc \times \Sol) \Rightarrow y$ has no children process $a_j \in \Bv \cap \Proc$ so that $\exists a_i \in y$, $a_i \neq a_j$.
\end{definition}

\begin{theorem}[Under-Approximation]
\label{th:approxinf}
Given a Process Hitting $(\PHs; \PHl; \PHa^{\langle 2 \rangle})$
that satisfies \pref{cr:bounded} and \pref{cr:compcs},
a context $\ctx$ and a sequence of objectives $\w$,
  if the graph $\cwB$ contains no cycle,
  all objectives have at least one solution
  and all edges are coherent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}

Computing the graph of local causality is polynomial in the number of sorts in $\PH$ and exponential in the number of processes in one sort.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
%Therefore, if the number of processes in each sort is small, the overall method can be processed in polynomial time.
Furthermore, it is possible to compute only a subset of $\V \cap \Sol$;
in this case, the overall method turns out to be exponential in the number of solutions to each objective.
Our method can thus be considered as efficient compared to regular model-checking which is usually PSPACE-complete~\cite{Harel02}.



\begin{example}
  Let $\PH' = (\PHs, \PHl, \PHh'^{\langle 1 \rangle})$ be the “flattened” version of the PH in \pref{fig:ph-livelock}, that is: $\PHh'^{\langle 1 \rangle} = \PHh^{(1)} \cup \PHh^{(2)}$,
  which is equivalent to a PH in the semantics without priorities.
  Due to spurious behaviours inherent to the cooperative sorts in this semantics, 
  the original under-approximation developed in~\cite{PMR12-MSCS} concludes that $c_1$ is reachable in $\PH'$ from $\ctx = \PHstate{a_1, b_0, c_0, ab_{10}}$.
  %this is due to an over-approximation of the behaviours inherent to cooperative sorts in the semantics without priorities.
  
  Such unwanted behaviours are palliated by the semantics of PH with priorities proposed in this paper.
  Indeed, the under-approximation given in \pref{th:approxinf} does not conclude regarding the reachability of $c_1$,
  as one of the edges of the resulting graph of local causality is not coherent (\pref{def:coherent}),
  as shown in in \pref{fig:sa-livelock}.
  (However, from the inconclusiveness of \pref{th:approxinf}, one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  
  However, if $\PHhit{a_0}{b_0}{b_1}$ and $\PHhit{b_0}{a_0}{a_1}$ are replaced by
  $\PHhit{a_0}{a_0}{a_1}$ and $\PHhit{b_0}{b_0}{b_1}$,
  then \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[AprocPrio,below of=c01s] (ab11) {$ab_{11}$};
    \node[AsolPrio,below of=ab11] (ab11s) {};

    \node[Aproc,below left of=ab11s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below right of=ab11s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge[aSPrio] (ab11s)
    (ab11s) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a00) edge (a00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (a0)
    (b11) edge (b11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The graph of local causality of the PH model in \pref{fig:ph-livelock}.
    Rectangular nodes containing a single process are elements in $\Proc$,
    nodes containing a couple of processes are elements in $\Obj$
    and circle nodes are elements in $\Sol$.
    %The double arrow and the two surrounding nodes represent the only edge in $\Proc \times \Sol$.
    \pref{th:approxinf} is inconclusive on this example as edge $(ab_{11}, \{ a_1, b_1 \}) \in \Proc \times \Sol$ (here represented with a double line) is not coherent (\pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a child of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$ (and the same also stands for $b_0$).
  }
\end{figure}
\end{example}


\subsection{Reachability of a state}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The reachability property studied so far concern a single process at a time.
However, we remark that the reachability of a partial or global state can be
addressed with the very same analysis by introducing a dedicated cooperative
sort in the scope of the PH semantics with $2$ classes of priorities.

Indeed, let $\PH = (\PHs, \PHl, (\PHh^{(1)}, \PHh^{(2)}))$ be a PH and suppose that we want to study the reachability of a state $s \in \PHl$.
Let $\PH' = (\PHs', \PHl', (\PHh'^{(1)}, \PHh'^{(2)}))$
with: $\PHs' = \PHs \cup \{ \total, \reach \}$ and $\PHl' = \PHl \times \PHl_\total \times \PHl_\reach$,
where $\total$ is a cooperative sort on all components $\components$ of $\PH$ (thus $\PHl_\total = \underset{a \in \components}{\times} \PHl_a$)
and $\reach$ is a component with $\PHl_\reach = \{ \reach_0, \reach_1 \}$;
furthermore, $\PHh'^{(1)}$ is the set $\PHh^{(1)}$ completed with all actions updating the cooperative sort $\total$,
and $\PHh'^{(2)} = \PHh^{(2)} \cup \{ \PHhit{\pfp_s(\total)}{\reach_0}{\reach_1} \}$.

Given an initial context $\ctx$, the reachability of $s$ in $\PH$ is equivalent to the concretization of $\PHobjp{\reach}{0}{1}$ in $\PH'$ from the initial context $\ctx \cup \{ \reach_0 \}$ (the initial state of $\total$ does not matter), which can be efficiently under-approximated using \pref{th:approxinf}.
Indeed, the additional action $\PHhit{\pfp_s(\total)}{\reach_0}{\reach_1}$ in $\PHh'^{(2)}$ allows to conclude on the reachability of process $\pfp_s(\total)$, that is, on the reachability of the state $s$ (considering only the components).

It is also possible to compute the reachability of a set of states $S \subseteq \PHl$ by creating several actions $\PHhit{\total_s}{\reach_0}{\reach_1}$ in $\PHh^{(2)}$ for each state $s \in S$.


\subsection{Sequential under-approximation}

In this section, we briefly explain an alternative sufficient condition that
progressively takes into account the successive objectives, instead of
considering all of them at a time, as it is done in the previous sections.
Because objectives are taken into account individually, such an approach
considers only a subset of scenarios.
However, because each iteration focuses on a smaller part of the network, this
sequential under-approximation may be more conclusive.

Let us define a sequence of objective $\w=\obj{a_i}{a_j}\concat\w'$ with
$a_i\neq a_j$ and a state $s\in L$ with $\get{s}{a}=a_i$.
One can remark that any scenario reaching $a_j$ necessarily includes one of the
bounce sequence in $\BS(\obj{a_i}{a_j})$, and in particular,
any minimal scenario reaching $a_j$ ends in a state where $a_j$ is present but
also the hitter of the last of one bounce sequence in $\BS(\obj{a_i}{a_j})$.
If such hitter $b_k$ is in a cooperative sort $b\in\cs$, it also means that one of the sub-state
in $\csState(b_k)$.
\pref{def:lastprocs} defines $\lastprocs(\obj{a_i}{a_j})$ as the set of set of
processes that may be present just after reaching $a_j$.

From \pref{th:approxinf}, we can deduce that
for any scenario $\delta$ in $\uconcr(P)$,
there exists a set of processes $ps\in\lastprocs(P)$
such that $ps \subset (s\play\delta)$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
with $\ctx'=\ctx\Cap\procs(\mycwB{\ctx}{P})$,
there exists a scenario $\delta'$ concretizing $\w'$ from the
state $(s\play\delta)$.
Therefore, the scenario $\delta\concat\delta'$ concretizes
$\w$.

\begin{definition}[$\lastprocs$]
\label{def:lastprocs}
Given an objective $\obj{a_i}{a_j}$, $\lastprocs:
\Obj\to\powerset(\powerset(\Proc))$ is
defined such that, $\forall lps\in\lastprocs(\obj{a_i}{a_j})$, 
$lps\in\powerset(\Proc)$,
\begin{enumerate}
\item $\{\hitter{\zeta_{\card\zeta}}\} \subset lps$;
\item $\forall b_j\in lps, b\in\cs, \exists ps\in\csState(b_j): ps\subset lps$;
\item $\forall b_j\in lps, b\in\cs, 
		\forall ps\in\csState(b_j),
			\exists lps'\in\lastprocs(\obj{a_i}{a_j}),
				ps\subset lps'$;
\item $\nexists lps'\in\lastprocs(\obj{a_i}{a_j}): lps'\subset lps \wedge
									lps'\neq lps$.
\end{enumerate}
\end{definition}

\begin{theorem}[Sequential under-approximation]
\label{thm:ordered-ua}
Given a context $\ctx$ and an objective sequence $\w =
P\concat\w'\in\OS$,
$\uconcr(P)\neq\emptyset \wedge
	\forall ps \in\lastprocs(P),
	\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset
	\Longrightarrow \uconcr(\w)\neq\emptyset$,
where $\ctx' = \ctx\Cap\procs(\mycwB{\ctx}{P})$.
\end{theorem}
\begin{proof}
If $\uconcr(P)\neq\emptyset$,
for all $s\in L, s\subset\ctx$,
there exists a scenario $\delta\in\uconcr(P)\cap\Sce(s)$;
from \pref{def:lastprocs} and proof of \pref{th:approxinf},
$\exists ps\in\lastprocs(P)$ such that
$(s\play\delta)\subset\ctx'\Cap ps$.
Hence, if $\muconcr_{\ctx'\Cap ps}(\w')\neq\emptyset$,
there exists a scenario $\delta'\in\muconcr_{\ctx'\Cap ps}(\w')$ such that
$\delta'\in\Sce(s\play\delta)$.
Hence, $\delta\concat\delta'$ is a scenario playable in $s$.
Therefore, for all $s\in L, s\subset\ctx$, there exists a scenario
concretizing $\w$.
Hence, $\uconcr(\w)\neq\emptyset$.
\end{proof}


