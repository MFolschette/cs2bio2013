\section{Static analysis}\label{sec:sa}

\towrite{Mettre de la colle}

\begin{definition}[Objective ($\Obj$)]
\label{def:obj}
  The reachability of a process $a_j$ prof a process $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj = \{ \PHobj{a_i}{a_j} \mid a \in \PHs \wedge (a_i, a_j) \in \PHl_a^2 \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) = a$, $\PHtarget(P)=a_i$, $\PHbounce(P)=a_j$,
  and $P$ is \emph{trivial} if $a_i = a_j$.
\end{definition}
We define an \emph{objective sequence} as a sequence of objectives in which each target must be equal to the previous bounce of the same sort, if it exists.
The set of all objective sequences is denoted by $\OS$.

\begin{definition}[Context $\ctx$ ($\Ctx$)]
\label{def:context}
  A \emph{context} $\ctx$ associates to each sort in $\PHs$ a non-empty subset of its processes:
  $\forall a \in \PHs, \PHget{\ctx}{a} \subseteq \PHl_a \wedge \PHget{\ctx}{a} \neq \emptyset$.
  $\Ctx$ is the set of all contexts.
\end{definition}

For a given context $\ctx$, we note $a_i \in \ctx$ if and only if $a_i \in \PHget{\ctx}{a}$,
and for all $ps \in \powerset(\PHproc) \cup \PHl$, $ps \subseteq \ctx \EQDEF \forall a_i \in ps, a_i \in \ctx$.
%The override of a context $\ctx$ by a set of processes $ps$ is noted $\ctx \Cap ps$ (\defref{ctxcap}).
%Par exemple, $\state{a_1,a_2,b_1,c_1}\Cap\{ a_3, b_2, b_3 \} = \state{a_3,b_2,b_3,c_1}$.

\begin{definition}[$\Cap: \Ctx \times \powerset(\PHproc) \mapsto \Ctx$]
\label{def:ctxcap}
  For a given context $\ctx\in\Ctx$ and a set of processes $ps \in \powerset(\PHproc)$,
  the override of $\ctx$ by $ps$ is noted $\ctx \Cap ps$ and is defined by
  \[ \forall a \in \PHs, \PHget{(\ctx \Cap ps)}{a} =
  \begin{cases}
    \{ p \in ps \mid \PHsort(p)=a \} & \text{if } \exists p \in ps, \PHsort(p)=a,\\
    \PHget{\ctx}{a} & \text{else.}
  \end{cases}
  \]
\end{definition}

A sequence of actions $\delta$ is \emph{playable} in a context $\ctx$ if and only if 
$\exists s \subseteq \ctx, \delta \in \Sce(s)$.
We denote then: $\delta \in \Sce(\ctx)$,
%$\supp(\delta) \subseteq \ctx$. 
and the play of $\delta$ in $\ctx$ is $\ctx \PHplay \delta = \ctx \Cap \ceil(\delta)$,
where $\ceil(\delta)$ is the set containing the last process (hitter or bounce) of each sort present in $\delta$.

\begin{comment}
  \begin{definition}[Objective sequence ($\OS$)]
  \label{def:OS}
  \towrite{Simplifier / réécrire en dehors d'une def}
    An \emph{objective sequence} is a sequence $\w = P_1 \concat \dots \concat P_{|\w|}$,
    where $\forall n \in \indexes{\w}, \w_n \in \Obj$ and $a_i = \PHtarget(\w_n) \Rightarrow \last_a(\w_{1..n-1}) \in \{ \varnothing, a_i \}$.
    The set of all objective sequences is denoted by $\OS$.
    The definitions of $\last_a$ \todo{À définir}, $\first_a$ \todo{À définir}, $\supp$ \todo{À définir} and $\ceil$ \todo{À définir}
    are simply derived by omitting the case of hitters.
  \end{definition}
\end{comment}

\begin{definition}[Bounce sequence ($\BS$)]
\label{def:bs}
  A \emph{bounce sequence} $\zeta$ is a sequence of actions so that $\forall n \in \indexes{\zeta}, n < |\zeta|, \PHbounce(\zeta_{n}) = \PHtarget(\zeta_{n+1})$.
  $\BS$ denotes the set of all bounce sequences, and
  $\BS(P)$ denotes the set of bounce sequences \emph{solving} an objective $P$:
  \[
    \BS(\PHobj{a_i}{a_j}) = \{ \zeta \in \BS \mid \PHtarget(\zeta_1)= a_i \wedge \PHbounce(\zeta_{|\zeta|}) = a_j \} \enspace.
  \]
  Obviously, $\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and $\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no way to reach $a_j$ from $a_i$.
\end{definition}

In the following, we denote: $\Sol = \powerset(\PHproc)$.
\begin{definition}[$\aBS:\Obj \mapsto \powerset(\Sol)$]
\label{def:aBS}
  \[
    \aBS(P) = \{ \abstr{\zeta} \in \Sol \mid \zeta \in \BS(P), \nexists \zeta' \in \BS(P), \abstr{\zeta'} \subsetneq \abstr{\zeta} \} \enspace,
  \]
  where $\abstr{\zeta} = \{ \PHhitter(\zeta_n) \mid  n \in \indexes{\zeta} \wedge \PHsort(\PHhitter(\zeta_n)) \neq \PHsort(P) \}$.
\end{definition}



\subsection{Under-approximation}

We define $\concr(\w)$ as the set of scenarios concretising an objective sequence $\w$ in the context $\ctx$.
In \pref{def:uconcr}, we define $\uconcr(\w)$ as equal to $\concr(\w)$ if it contains scenarios starting from all states $s \subseteq \ctx$.
if such a scenario exists in all states $s \subseteq \ctx$.

\begin{comment}
\begin{definition}[$\concr: \OS \mapsto \powerset(\Sce)$]
\label{def:concr}
\towrite{Simplifier ? Supprimer la def formelle ?}
  For a given $\w \in \OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the context $\ctx$:
  \begin{align*}
    \concr(\w) = \{ \delta \in \Sce \mid & (\w^\vartriangle = \emptyseq \wedge \delta = \emptyseq) 
      \vee (\w^\vartriangle \neq \emptyseq \wedge \supp(\delta) \subseteq \ctx
    \\ &
      \wedge \exists \phi:\indexes{\w} \mapsto \indexes{\delta}, (\forall n, m \in \indexes{\w}, n < m \Leftrightarrow \phi(n) \leq \phi(m)) 
    \\ &
      \wedge \forall n \in \indexes{\w}, \PHbounce(\w_n) \in \ctx \PHplay \delta_{1..\phi(n)})
    \}
    \enspace,
  \end{align*}
  where $\omega^\vartriangle$ refers to the sequence of objectives $\omega$ where the trivial objectives have been removed.
\end{definition}
%
\begin{definition}[$\concr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:concr-set}
  $\concr(\W) = \{ \delta \in \concr(\w) \mid \w \in \W \} \enspace.$
\end{definition}
\end{comment}

\begin{definition}[$\uconcr: \OS \mapsto \powerset(\Sce)$]
\label{def:uconcr}
  \[
  \uconcr(\w) = 
  \begin{cases}
    \concr(\w) & \text{if } \forall s \in \PHl, s \subseteq \ctx, \exists \delta \in \concr(\w), \delta \in \Sce(s) \\
    \emptyset & \text{else.}
  \end{cases}
  \]
\end{definition}
% 
\begin{theorem}
\label{th:uconcr-ctx}
  $\ctx' \subseteq \ctx \wedge \uconcr(\w) \neq \emptyset \Longrightarrow \muconcr_{\ctx'}(\w) \neq \emptyset$.
\end{theorem}

\begin{comment}
\begin{definition}[$\uconcr: \powerset(\OS) \mapsto \powerset(\Sce)$]
\label{def:uconcr-set}
  $\uconcr(\Omega) = \{ \delta \in \uconcr(\w) \mid \w \in \Omega\}$
\end{definition}
\end{comment}

The set of all processes involved in an abstract structure $\cwB$ is given in \pref{def:allprocs}.
\begin{definition} \todo{À revoir avec la nouvelle sémantique}
\label{def:allprocs}
  \begin{align*}
  &\allprocs((\cwSol,\cwReq,\cwRSP,\cwCont)) = \{ p \in \PHproc \mid \exists (P,ps) \in \cwSol, \\
    &\qquad\qquad p \in ps \vee p = \PHtarget(P) \vee p = \PHbounce(P) \\
    &\qquad\qquad \vee \exists (a_i,ps) \in \cwRSP, p \in ps \}
  %  &\qquad\qquad \vee p = \PHtarget(P) \vee \exists h \in \BS(P), (p = \PHhitter(h) \vee p = \PHbounce(h)) \\
  %  &\qquad\qquad \vee \exists(Q, \PHobj{p}{\PHbounce(Q)} \in \cwPrioCont \}
  \end{align*}
\end{definition}



\subsection{Abstract structure}

\towrite{expliquer maxCont et le graphe de causalité}

\begin{definition}[$\gCont_\ctx : \Sigma \times \Obj \mapsto \powerset(\PHproc)$]
  \label{def:maxCont}
  \begin{align*}
    \gCont_\ctx(a,P) = 
    \{ p \in \PHproc &\mid \exists ps \in \aBS(P), \exists b_i \in ps, b = a \wedge p = b_i \\
      & \vee b \neq a \wedge p \in \gCont_\ctx(a, \PHobj{b_j}{b_i}) \wedge b_j \in \PHget{\ctx}{b} \}
    \enspace.
  \end{align*}
\end{definition}

\begin{comment}
\begin{definition}
  $\cwB = (\V, \E)$, $V \subset \PHproc \cup \Obj \cup \powerset(\PHproc)$ and $E \subset V \times V$
  so that:\\
  $\w \subset \V$\\
  $\{ \PHbounce(P) \mid P \in \V \} \subset \V$\\
  $\{ (P, ps) \in \Obj \times \powerset(\PHproc) \mid P \in \V \wedge ps \in \BS(P) \} \subset \E$\\ % Sol
  $\{ ps \in \powerset(\PHproc) \mid (P, ps) \in \E \} \subset \V$\\
  $\{ (ps, a_i) \in \powerset(\PHproc) \times \PHproc \mid a_i \in ps \} \subset \E$\\ % Sol
  $\{ a_i \in \PHproc \mid (ps, a_i) \in \E \} \subset \V$\\
  $\{ (a_i, \PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid a \in \components \wedge a_i \in \V \wedge a_j \in \ctx \} \subset \E$\\ % Req
  $\{ \PHobjp{a}{j}{i} \in \Obj \mid (a_i, \PHobjp{a}{j}{i}) \in \E \} \subset \V$\\
  $\{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid P \in \V \wedge q \in \gCont_\ctx(\PHsort(P), P) \} \subset \E$\\ % Cont
  $\{ (a_i, ps) \in \Proc \times \powerset(\PHproc) \mid a \in \cs \wedge a_i \in \V \wedge ps \in \csState(a_i) \} \subset \E$\\ % ReqSolPrio
\end{definition}

\begin{definition}
  $\cwB = (\V, \E)$, $V \subset \PHproc \cup \Obj \cup \powerset(\PHproc)$ and $E \subset V \times V$
  so that:
  \begin{align*}
    \w &\subset \V\\
    \{ \PHbounce(P) \mid P \in \V \} &\subset \V\\
    \{ (P, ps) \in \Obj \times \powerset(\PHproc) \mid P \in \V \wedge ps \in \BS(P) \} &\subset \E\\ % Sol
    \{ ps \in \powerset(\PHproc) \mid (P, ps) \in \E \} &\subset \V\\
    \{ (ps, a_i) \in \powerset(\PHproc) \times \PHproc \mid a_i \in ps \} &\subset \E\\ % Sol
    \{ a_i \in \PHproc \mid (ps, a_i) \in \E \} &\subset \V\\
    \{ (a_i, \PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid a \in \components \wedge a_i \in \V \wedge a_j \in \ctx \} &\subset \E\\ % Req
    \{ \PHobjp{a}{j}{i} \in \Obj \mid (a_i, \PHobjp{a}{j}{i}) \in \E \} &\subset \V\\
    \{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid P \in \V \wedge q \in \gCont_\ctx(\PHsort(P), P) \} &\subset \E\\ % Cont
    \{ (a_i, ps) \in \Proc \times \powerset(\PHproc) \mid a \in \cs \wedge a_i \in \V \wedge ps \in \csState(a_i) \} &\subset \E % ReqSolPrio
  \end{align*}
\end{definition}
\end{comment}

\newcommand{\V}{V}
\newcommand{\E}{E}
\newcommand{\cwV}{\V_\ctx^\w}
\newcommand{\cwE}{\E_\ctx^\w}
\newcommand{\VProc}{\V_\PHproc}
\newcommand{\VObj}{\V_\Obj}
%\newcommand{\VSol}{\V_{Sol}}
\newcommand{\VSol}{\V_{\Sol}}

\def\Bv{\sat{\cwV}}
\def\Be{\sat{\cwE}}
\def\BvProc{\textcolor{red}{\sat{\cwV}^\PHproc}}
\def\BvObj{\textcolor{red}{\sat{\cwV}^\Obj}}
%\def\BvSol{\sat{\cwV}^{Sol}}
\def\BvSol{\textcolor{red}{\sat{\cwV}^{\Sol}}}

\newcommand{\Bee}[2]{\Be^{#1}_{#2}}

\begin{definition}
  The graph of local causality $\cwB = (\Bv, \Be)$ is defined as: $\cwB = \sfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs_\ctx(\myB)}}$,
  where $\myB = (\cwV, \cwE)$ is the smallest graph where: $\cwV = \VProc \cup \VObj \cup \VSol$ with $\VProc \subset \PHproc$, $\VObj \subset \Obj$, $\VSol \subset \Sol$ and $\cwE \subset \cwV \times \cwV$ so that:
  \begin{align}
    \w &\subset \cwV \label{eq:Vw} \\
%      \{ \PHbounce(P) \mid P \in \VProc \} &\subset \V\\
    P \in \VProc &\Rightarrow \PHbounce(P) \in \cwV \label{eq:Vproc} \\
    (x, y) \in \E &\Rightarrow y \in \cwV \label{eq:VE} \\
%    P \in \VObj &\Rightarrow \PHbounce(P) \in \V\\
%      \{ (P, ps) \in \Obj \times \powerset(\PHproc) \mid P \in \V \wedge ps \in \BS(P) \} &\subset \E\\ % Sol
    P \in \VObj \wedge ps \in \BS(P) &\Rightarrow (P, ps) \in \cwE \label{eq:ESol1} \\
%    \{ ps \in \powerset(\PHproc) \mid (P, ps) \in \E \} &\subset \V\\
%      \{ (ps, a_i) \in \powerset(\PHproc) \times \PHproc \mid a_i \in ps \} &\subset \E\\ % Sol
    ps \in \VSol \wedge a_i \in ps &\Rightarrow (ps, a_i) \in \cwE \label{eq:ESol2} \\
%    \{ a_i \in \PHproc \mid (ps, a_i) \in \E \} &\subset \V\\
%      \{ (a_i, \PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid a \in \components \wedge a_i \in \V \wedge a_j \in \ctx \} &\subset \E\\ % Req
    a \in \components \wedge a_i \in \VProc \wedge a_j \in \ctx &\Rightarrow (a_i, \PHobjp{a}{j}{i}) \in \cwE \label{eq:EReq} \\
%    \{ \PHobjp{a}{j}{i} \in \Obj \mid (a_i, \PHobjp{a}{j}{i}) \in \E \} &\subset \V\\
%      \{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid P \in \V \wedge q \in \gCont_\ctx(\PHsort(P), P) \} &\subset \E\\ % Cont
    P \in \VObj \wedge q \in \gCont_\ctx(\PHsort(P), P) &\Rightarrow (P, \PHobj{q}{\PHbounce(P)}) \in \cwE \label{eq:ECont} \\
%      \{ (a_i, ps) \in \Proc \times \powerset(\PHproc) \mid a \in \cs \wedge a_i \in \V \wedge ps \in \csState(a_i) \} &\subset \E\\ % ReqSolPrio
    a \in \cs \wedge a_i \in \VProc \wedge ps \in \csState(a_i) &\Rightarrow (a_i, ps) \in \cwE \label{eq:EPrio}
  \end{align}
\end{definition}

\pref{eq:Vw}, \eqref{eq:Vproc} and \eqref{eq:VE} ensure that all required nodes are in $\cwV$.
Elements in $\PHproc$ are required processes,
elements in $\Obj$ are the objectives to reach these processes
and elements in $\Sol$ are the sets of processes that are the solutions to these objectives.
\pref{eq:ESol1} links an objective $P$ to its solutions in $\BS(P)$,
\pref{eq:ESol2} links a solution $ps$ to the processes $a_i \in ps$ it contains and
\pref{eq:EReq} links a required process $a_i$ of a component to all objectives $\PHobjp{a}{j}{i}$ with $a_j \in \ctx$.
If the resolution of an objective $P$ may require a process of $\PHsort(P)$, then \pref{eq:ECont} re-targets this objective ($\gCont$).
Finally, \pref{eq:EPrio} links a required process $a_i$ of a cooperative sorts to its solutions in $\csState(a_i)$.

In the following, we denote:
%$\BvProc = \Bv \cap \PHproc$, $\BvObj = \Bv \cap \Obj$ and $\BvSol = \Bv \cap \Sol$.
$\Bee{X}{Y} = \Be \cap (X \times Y)$, with $X, Y$ amongst $\PHproc$, $\Obj$ and $\Sol$.

\begin{comment}
\begin{definition}
  \label{def:aS}
  The abstract structure $\cwB=(\Breq,\Bsol,\Brsp,\Bcont)$ is defined as
  $\cwB = \sfp{\aB^\w_\ctx}{\myB}{\aB^\w_{\ctx \Cap \allprocs_\ctx(\myB)}}$,\\
  with $\myB=(\myreq,\mysol,\myrsp,\mycont)$:
  \begin{align*}
    \myreq &= \{ (a_i,\PHobjp{a}{j}{i}) \in \PHproc \times \Obj \mid
      a \in \components \wedge a_j \in \PHget{\ctx}{a} \\ % \vee a_j \in \pfpprocs_\ctx(a) \\
      & \qquad \wedge ((\exists (P,ps) \in \mysol \vee \exists (b_j, ps) \in \myrsp), a_i \in ps \\
      & \qquad\qquad \vee \exists n \in \indexes{\w}, \PHbounce(\w_n)=a_i) \}
    \\
    \mysol &\subseteq \{ (P,ps) \in \Obj \times \powerset(\PHproc) \mid
            \exists (a_i, P) \in \myreq \wedge ps \in \aBS(P) \\
      & \qquad\qquad \vee \exists (Q, P) \in \mycont \wedge ps \in \aBS(P) \}
    \\
    \myrsp &= \{ (a_i,ps) \in \PHproc \times \powerset(\PHproc) \mid a \in \cs \\
      & \qquad \wedge (\exists (P,ps') \in \mysol \vee \exists (b_j,ps') \in \myrsp), \\
      & \qquad\qquad a_i \in ps' \wedge \csState(a_i) \in ps \}
    \\
    \mycont & = \{ (P, \PHobj{q}{\PHbounce(P)}) \in \Obj \times \Obj \mid
      \exists (P, ps) \in \mysol \\
      & \qquad\qquad \wedge q \in \gCont_\ctx(\PHsort(P),P) \}
  \end{align*}
\end{definition}

\begin{definition}[Coherent solution]
\label{def:coherent}
  A cooperative sort requisite $(a_i, ps)$ in $\Brsp$ is said coherent iff
  it has no successor $(b_k,\PHobjp{b}{j}{k})$ in $\Breq$ so that there exists $b_n \in ps$, $b_k \neq b_n$.
\end{definition}
\end{comment}

\begin{definition}[Coherent solution]
\label{def:coherent}
  An edge $(x, y) \in \cwE$ is said coherent if and only if
  $(x, y) \in \Bee{\Proc}{\Sol} \Rightarrow y$ has no process successor $a_j \in \Bv \cap \Proc$ so that $\exists a_i \in y$, $a_i \neq a_k$.
%  A set of processes $ps \in \Bv \cap \powerset(\PHproc)$ is said coherent if and only if
%  it has no process successor $a_j \in \Bv \cap \PHproc$ so that there exists $a_i \in ps$, $a_i \neq a_k$.
\end{definition}

\begin{theorem}[Under-Approximation]
\label{th:approxinf}
  If the graph $\cwB$ contains no cycle,
  all objectives have at least one solution
  and all edges are coherent,
  %and $\forall (a_i, ps) \in \cwE \cap (\Proc \times \powerset(\PHproc))$, $ps$ is coherent,
  %and all cooperative sort requisites are coherent,
  then $\uconcr(\w) \neq \emptyset$.
\end{theorem}



\begin{figure}[p]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[Aproc,below of=c01s] (ab11) {$ab_{11}$};
    \node[AsolPrio,below of=ab11] (ab11s) {};

    \node[Aproc,below left of=ab11s] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Aproc,below of=a01s] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};

    \node[Aproc,below right of=ab11s] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Aproc,below of=b01s] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (ab11)
    (ab11) edge (ab11s)
    (ab11s) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (b0)
    (a11) edge (a11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a00) edge (a00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b00) edge (b00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (a0)
    (b11) edge (b11s)
    ;
    \end{tikzpicture}
  \label{fig:sa-livelock}
  \caption{
    The graph of local causality of the PH model in \pref{fig:ph-livelock}.
    \pref{th:approxinf} is inconclusive on this example as the only solution of process $ab_{11}$ is not coherent (\pref{def:coherent}).
  }
\end{figure}

\todo{La méthode permet aussi de conclure sur l'accessilibité d'un état (global ou partiel)}
