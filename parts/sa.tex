% vi:spell spelllang=en:
\section{Under-approximation of Reachability}\label{sec:sa}

We present a static analysis that takes as input an AAN
$\PH = (\PHs; \PHl; \PHa)$,
an initial state, and a local state of an automaton in $\PHs$, for identifying sufficient conditions
that ensure the existence of a scenario starting from the initial state and leading to a state
where the given local state is present.

A classical approach for determining if a local state of an automaton can be reach from a
given initial state is to build sequences of transitions from the initial state until a state
containing the given local state is reached.
This is essentially what model-checkers do, and the complexity of such analysis (PSPACE-complete
\cite{Harel02}) makes it intractable on large systems, even with advanced symbolic approaches
\cite{PMR12-MSCS}.

Our approach relies on abstractions of scenarios that have been introduced in
\cite{PMR12-MSCS} for the static analysis of reachability in the Process Hitting framework,
a particular sub-class of AAN (see the Remark at the end of the previous section).
In this paper, we generalize the static analysis for the case of the under-approximation of
reachability in any AAN.

\todo{outline}

\subsection{Abstractions for Scenarios}
\label{ssec:abstr-sce}

The approach presented in this section is based on two complementary notions,
the \emph{objectives} and their \emph{local causality},
that are intertwined in so-called \emph{Local Causality Graphs}.

\subsubsection{Objectives}

An \emph{objective} (\pref{def:obj}) denotes the reachability of a local state (e.g., $a_j$) of a given automaton $a$
from the initial local state of that automaton (e.g., $a_i$).
Such an objective is written $\PHobjp{a}{i}{j}$.
Successive objectives are described with objective sequences (\pref{def:obj}).

\begin{definition}[Objective ($\Obj$) \& Objective Sequence ($\OS$)]
\label{def:obj}
  If $a \in \components$, the reachability of a local state $a_j$ from a local state $a_i$ is called an \emph{objective}, noted $\PHobj{a_i}{a_j}$.
  The set of all objectives is called $\Obj \DEF \{ \PHobj{a_i}{a_j} \mid a \in \components \wedge (a_i, a_j) \in \PHl_a \times \PHl_a \}$.
  For an objective $P = \PHobj{a_i}{a_j} \in \Obj$, we define: $\PHsort(P) \DEF
  a$, $\PHtarget(P)\DEF a_i$, $\PHbounce(P)\DEF a_j$,
  and $P$ is said \emph{trivial} if $a_i = a_j$.

  We define an \emph{objective sequence} as a sequence of objectives in which each objective target must be equal to the previous objective bounce of the same automaton, if it exists.
  The set of all objective sequences is denoted by $\OS$.
\end{definition}

We define the partial ordering relation $\ltw$ between two objective sequences (\pref{def:ltw}) as
follows:
$w\ltw w'$ if and only if there exists a mapping between all the objective bounces of $w'$ in $w$
that preserve the sequentiality.

\todo{support compatibility}

\begin{definition}[$\ltw \subset \OS\times\OS$]\label{def:ltw}
$\w\ltw\w'$ if and only if
$|\w|\geq|\w'|$ and
there exists a mapping $\phi: \indexes{\w'}\mapsto \indexes{\w}$ such that
$\forall n,m \in\indexes{\w'}, n<m \Leftrightarrow \phi(n)<\phi(m)$,
and
$\forall n\in\indexes{\w'}, \bounce{\w'_n}=\bounce{\w_{\phi(n)}}$
\end{definition}

\begin{example}
\[\obj{b_0}{b_1}\concat\obj{a_0}{a_1}\concat\obj{b_1}{b_2}
\ltw
\obj{a_0}{a_1}\concat\obj{b_0}{b_2}
\ltw
\obj{b_0}{b_2}\]
\[\obj{b_0}{b_1}\not\ltw\obj{b_0}{b_2}\]
\end{example}

An objective sequence can be seen as an abstract representation of a set of scenarios that describe
(part of) the successive state changes of the automata.
We denote by $\concr(\w)$ (\pref{def:concr}) the set of scenarios concretising an objective sequence
$\w$ in the state $s\in\PHs$.
It is essentially all the scenarios for which there exists a mapping from the bounces of each
objective to the bounce of an action in the scenario which preserve the sequential ordering.

\todo{compatibility of $\w$ with $s$}

\begin{definition}[$\concr: \OS \to \powerset(\Sce)$]\label{def:concr}
Given $\w\in\OS$, $\concr(\w)$ is the set of scenarios concretising $\w$ in the
state $s$:
\begin{align*}
\concr(\w) \DEF \{ \delta\in\Sce(s)\mid & (\w^\vartriangle=\emptyseq \wedge
\delta=\emptyseq)  \vee (
\w^\vartriangle\neq \emptyseq\wedge
\\ &
 \wedge \exists \phi:\indexes{\w}\mapsto\indexes{\delta},
    (\forall n,m\in\indexes{\w}, n<m \Leftrightarrow \phi(n)\leq\phi(m))
\\ & \qquad
	\wedge \forall n\in\indexes{\w},
	  \bounce{\w_n} \in s\play\delta_{1..\phi(n)})
\}
\enspace,
\end{align*}
where $\omega^\vartriangle$ refers to the objective sequence $\omega$ where
trivial objectives have been removed.
The notation $\delta_{a..b}$ in the previous definition
denotes the subsequence of $\delta$ between indexes $a$ and $b$,
as defined on page \pageref{notations}.
\end{definition}

From \pref{def:ltw} and \pref{def:concr}, we derive that if 
$w\ltw w'$, then $\concr(w)\subseteq\concr(\w')$ (\pref{lem:ltw}).
\begin{lemma}\label{lem:ltw}
$\w\ltw\w' \Longrightarrow \concr(\w)\subseteq\concr(\w')$\enspace.
\end{lemma}


\subsubsection{Local Causality for Objectives}

The existence of a scenario from a state $s$ leading to a state
where a given local state of an automaton $a_j$ is present
can be reformulated as the checking for the non-emptiness of $\concr(\obj{a_i}{a_j})$, where
$a_i=\get{s}{a}$.
A first hint for checking this emptiness is to look for actions that have to be played in order to
reach the state $j$ from $i$ within the automaton $a$.

Given an objective $P = \obj{a_i}{a_j} \in\Obj$, we define $\BS(P)$ the \emph{bounce sequences} of
$P$ as the set of minimal sequences of actions hitting $a$ in which the bounce of each action is
the target of the following action (\pref{def:bs}).

\begin{definition}[Bounce Sequence ($\BS$)]\label{def:bs}
A \emph{bounce sequence} $\zeta$  is a sequence of actions such that
$\forall n\in\indexes{\zeta}, n<|\zeta|,
\bounce{\zeta_{n}} = \target{\zeta_{n+1}}$.
$\BS$ denotes the set of bounce sequences.
We refer to the set of bounce sequences \emph{resolving} the objective $P$ as
$\BS(P)$:
\begin{align*}
\BS(\obj{a_i}{a_j}) \DEF \{ \zeta\in\BS\mid & \target{\zeta_1}=a_i\wedge
			    \bounce{\zeta_{|\zeta|}}=a_j \\
& \wedge \forall m,n\in\indexes{\zeta}, n>m, \bounce{\zeta_n}\neq\target{\zeta_m}
				\}\enspace.
\end{align*}
\end{definition}

Therefore,
$\BS(\obj{a_i}{a_i}) = \{\emptyseq\}$; and
$\BS(\obj{a_i}{a_j}) = \emptyset$ if there is no possibility to reach $a_j$ from
$a_i$.

\todo{example}

From \pref{def:bs}, we can derive that any scenario concretising an objective includes all the
actions of one of the bounce sequences of the objective (\pref{lem:bs-concr}).
\begin{lemma}
Given a state $s\in \PHl$ and an objective $\obj{a_i}{a_j}$ with $\get{s}{a}=a_i$,
$\forall\delta\in\concr(\obj{a_i}{a_j})$,
$\exists\zeta\in\BS(\obj{a_i}{a_j})$ such that
$\exists \phi: \indexes{\zeta}\to\indexes{\delta}$
with
$\forall n,m\in\indexes{\zeta}, n<m \Leftrightarrow \phi(n)<\phi(m)$
and
$\forall n\in\indexes{\zeta}$, $\zeta_n = \delta_{\phi(n)}$.
\label{lem:bs-concr}
\end{lemma}



\subsubsection{Local Causality Graph}

Given one initial objective, one could then recursively refine the objective into objective
sequences following its bounce sequences \cite{PMR12-MSCS}:
the refinement of objective $P$ with $\zeta\in\BS(P)$ would consists in prepending to $P$ the
objectives leading to the hitters of the actions in $\zeta$, in the same sequential order;
the generalization of the refinement to an objective sequence would require to consider all possible
interleaving between the refinements.

These refinements can be summarized compactly with a so-called Local Causality Graph (LCG).
Given an initial context $\ctx$ and a local state $\myp\in\Proc$,
an LCG $\cwB = (\cwV, \cwE)$
is a digraph where $\cwV \subseteq \Proc\cup \Obj \cup \Sol \cup \sSol$ is the set of vertices
where $\sSol=\powerset(\Proc)$ and $\Sol=\Obj\times\powerset(\sSol)$
and $\cwE \subseteq \cwV \times \cwV$ is the set of oriented edges
(\pref{def:lcg}).
A node in $\Obj$ represents an objective that have to be refined.
Such a node can then be related to nodes in $\Sol$ which represents a set of hitter set of a
bounce sequence of the objective:
given an objective $P$, if $\zeta\in\BS(P)$, $\abstr\zeta \DEF \{\PHhitter(\zeta_n) \mid
n\in\indexes\zeta \}$, then $P$ is related to $\langle P, \abstr\zeta\rangle\in\Sol$
(\pref{def:lcg}-\ref{lcg-obj-sol}).
Given a node $\langle P,\abstr\zeta\rangle\in\cwV\cap\Sol$, for each $ps\in\abstr\zeta$,
it is related to a node $ps\in\sSol$
(\pref{def:lcg}-\ref{lcg-sol-sync}).
A node $ps\in\sSol$ is then related to each $a\in\Proc$
(\pref{def:lcg}-\ref{lcg-sync-ls}).
Given a node $a_i\in\cwV\cap\Proc$, for each $a_j\in\ctx$ or $a_j\in\cwV\cap\Proc$,
it is related to an objective $\obj{a_j}{a_i}$
(\pref{def:lcg}-\ref{lcg-ls-obj}).
Finally, given a node $\obj{a_j}{a_i}\in\cwV\cap\Obj$,
if a local state $a_k\neq a_i$ is in its successors (given by
$\conn_{(\cwBNodes,\cwBEdges)}(\obj{a_j}{a_i})$), then
$\obj{a_j}{a_i}$ is related to $\obj{a_k}{a_i}$ in the LCG
(\pref{def:lcg}-\ref{lcg-conn}).

\begin{definition}
\label{def:lcg}
Given a context $\ctx$ and a local state $\myp\in \Proc$,
the Local Causality Graph (LCG) for reachability under-approximation
$\cwB \DEF (\Bv, \Be)$
with
$\cwBNodes \subseteq \Proc \cup \Obj \cup \NSol \cup \sSol$
and
$\cwBEdges \subseteq \cwBNodes \times \cwBNodes$,
is the smallest graph such that:
\begin{enumerate}
\item
$\myp \in \cwBNodes$
\item
$a_i\in\cwBNodes\cap\Proc \Leftrightarrow \{ (a_i,\obj{a_j}{a_i}) \mid
a_j\in\ctx \vee a_j\in\cwBNodes\cap\Proc)
\}\subseteq\cwBEdges$
\label{lcg-ls-obj}
\item
$P\in\cwBNodes\cap\Obj \Leftrightarrow 
	\{ (P,\langle P,\abstr \zeta\rangle) \mid \zeta\in\BS(P) \}\subseteq\cwBEdges$
\label{lcg-obj-sol}
\item
$\langle P, nls \rangle\in\cwBNodes\cap\NSol \Leftrightarrow
	\{ (\langle P,nls\rangle, ls) \mid ls\in nls \}\subseteq\cwBEdges$
\label{lcg-sol-sync}
\item
$ls \in\cwBNodes\cap\sSol \Leftrightarrow
	\{ (ls, a_i) \mid a_i\in ls \}\subseteq\cwBEdges$
\label{lcg-sync-ls}
\item
$\obj{a_i}{a_j}\in \cwBNodes\cap\Obj \Rightarrow 
	\{(\obj{a_i}{a_j},\obj{a_k}{a_j}) \mid a_k\neq a_j,$
\label{lcg-conn}
\\
\hspace*{4cm}
$a_k\in \conn_{(\cwBNodes,\cwBEdges)}(\langle\obj{a_i}{a_j},\abstr\zeta\rangle),$
\\
\hspace*{4cm}
$\zeta\in\BS(\obj{a_i}{a_j}) \}\subset\cwBEdges$
\end{enumerate}
with $\abstr\zeta \DEF \{\PHhitter(\zeta_n) \mid n\in\indexes\zeta \}$.
\end{definition}



\subsection{Sufficient condition for reachability of a local state}
\label{ssec:ua}

Given a context $\ctx$ and a local state $\myp\in\Proc$, the LCG $\cwB$ contains a set of objectives
that can be used to build a concrete scenario reaching $\myp$.
Because we are focused on sufficient conditions for reachability, we do not require that all
possible scenarios can be derived from the LCG.

In this section, we prove that if the LCG has no cycle, if all its nodes in $\Obj$ have at least one
child, and if all its nodes in $\sSol$ satisfy a
particular criteria, so-called independence, then from any state
delimited by the context $\ctx$, there exists a scenario that reaches $\myp$
(\pref{th:approxinf}).

A node $x$ of the LCG in $\sSol$ is \emph{independent} (\pref{def:coherent}) if for each local state
$a_i\in x$, none of the other local state $b_j\in x$ have a local state of automaton $a$ different
than $a_i$ in their successors.
This criteria ensures that once a local state in $x$ has been reached, reaching another local state
in $x$ should not require to change the first local state.

\begin{definition}[Independent synchronizations]
\label{def:coherent}
  In a LCG $\cwB = (\Bv, \Be)$,
  a node $x \in \Bv\cap\sSol$ is \emph{independent} if and only if
  for each $a_i\in x$,
  for each $b_j\in x, b_j\neq a_i$,
  $a_k \in\conn_{\cwB}(b_j) \cap \Proc \Rightarrow a_k = a_i$.
\end{definition}

The intuition is the following.
Given a state $s\subset\ctx$, we recursively refine the initial objective
(which is: reaching $\myp$ from the initial state) according to its children.
As the LCG is acyclic, such a recursion always terminates, and as all the objective nodes have at
least one child, it never gets stuck.
The refinement of an objective node $\obj{a_i}{a_j}$ acts as follows:
if the node has another objective node $\obj{a_k}{a_j}$ as child, we first refine the objective
$\obj{a_i}{a_k}$ (which, by construction, is necessarily in the LCG)
and then we refine the objective $\obj{a_k}{a_j}$.
If the objective node has only successors in $\Sol$ (bounce sequences), one is picked arbitrarily.
If $\langle P, nls\rangle$ is the chosen node,
by construction there exists $\zeta\in\BS(P)$ such that $\abstr\zeta = nls \in \powerset(\sSol)$.
If $\zeta = \emptyseq$ (for instance in the case when $a_i = a_j$), the recursion stops and we
continue to the next stage.
Otherwise, for each $n\in\indexes\zeta$,
for each $b_i \in\PHhitter(\zeta_n)$,
we refine the objective $\obj{b_j}{b_i}$ where $b_j$ is the state of $b$ in the current state.
By induction, $\obj{b_j}{b_i}$ is a child of $b_i$ in the LCG of \pref{def:lcg}.
Then, we know (by induction) that the current state of $b$ is $b_i$.
After having repeated this procedure for each $b_i\in\PHhitter(\zeta_n)$,
because all the nodes in $\sSol$, and in particular $\PHhitter(\zeta_n)$, are independent,
we know that all the local states in $\PHhitter(\zeta_n)$ are in the current state.
In addition, we know that the state of automaton $a$ has remained unchanged, otherwise
$\obj{a_i}{a_j}$ would have an objective child.
Hence, the action $\zeta_n$ is playable in the current state.
We can thus apply this action, modifying the state of $a$ to $a_j$ and continue to the next stage.
In the end, this recursive procedures builds a scenario from $s\subset\ctx$ to a state containing $\myp$.

\begin{theorem}[Under-approximation]
\label{th:approxinf}
  Given an AAN $(\PHs; \PHl; \PHa)$,
  a context $\ctx$ and an objective sequence $\w$,
  if the LCG $\cwB$ contains no cycle,
  all nodes in $\Obj$ have at least one child,
  and all nodes in $\sSol$ are independent,
  then for any state $s\in\PHl$ such that $s\subset\ctx$,
  there exists a scenario $\delta\in\Sce$ with $\myp\in s\play\delta$.
\end{theorem}

Regarding the complexity of the method,
computing the LCG is polynomial in the number of automata in $\PH$ and exponential in the number of local states in one automaton.
Checking the properties allowing to apply \pref{th:approxinf} is polynomial in the size of the graph.
Therefore, the building and checking process can be considered as polynomial in the size
of the AAN, provided that each automaton only contains a few local states.
We note that this is particularly true for biological models, where
each component usually contains a limited number of expression levels.

We note furthermore that the method does not require any completeness of the bounce sequences
$\BS$.
Therefore, in order to reduce the number of bounce sequences to consider, and potentially removing
cycles and non-satisfying nodes,
one can consider only a sub-set of bounce sequences
(and in particular: a single bounce sequence) for each objective.
However, such an approach would imply to enumerate all possible combinations of bounce sequences
subsets, hence being exponential in the number of objectives having at least two bounce sequences.



\begin{example}
  If we confider the AAN of \pref{fig:ph-livelock},
  from the initial state $\PHstate{a_1, b_0, c_0}$ depicted,
  the under-approximation given in \pref{th:approxinf}
  does not conclude regarding the reachability of $c_1$.
  This is due to the fact that the node $\{ a_1, b_1 \} \in \Bv \cap \sSol$
  is not independent because of its successor $a_0$ (and $b_0$).
  (However, from the inconclusiveness of \pref{th:approxinf},
  one cannot conclude about the unreachability of $c_1$.
  Such analysis should be driven for instance
  with over-approximation methods developed in~\cite{PMR12-MSCS}.)
  
  This result is new compared to the method proposed in~\cite{PMR12-MSCS}.
  Indeed, the representation based on the Process Hitting that was proposed
  in this paper only allowed to represent “over-approximated” Boolean gates
  with the use of so-called cooperative sorts.
  This especially did not allow to model the fact that $a_1$ and $b_1$ could not
  be activated in the same state, but only in successive states.
  Thus, when using Process Hitting, $c_1$ was indeed reachable,
  contrary to the behaviour expected from an accurate Boolean gate.
  
  Finally, we note however that,
  if $\PHhits{a_0}{b_0}{b_1}$ and $\PHhits{b_0}{a_0}{a_1}$ are replaced by the actions
  $\PHhitm{a_0}{a_1}$ and $\PHhitm{b_0}{b_1}$,
  then the resulting saturated graph of local causality changes, and
  \pref{th:approxinf} concludes that $c_1$ is reachable from $\ctx$.
  The reader can also refer to \pref{ssec:ex-metazoan}
  for a detailed conclusive example.

\begin{figure}[tp]
  \centering
  \begin{tikzpicture}[aS]
    \node[Aproc] (c1) {$c_1$};
    \node[Aobj,below of=c1] (c01) {$\PHobj{c_0}{c_1}$};
%    \node[Aobj] (c01) {$\PHobj{c_0}{c_1}$};
    \node[Asol,below of=c01] (c01s) {};

    \node[Assol,below of=c01s] (a1a1ss) {$\{ a_1, b_1 \}$};
    \node[Aproc,below left of=a1a1ss] (a1) {$a_1$};
    \node[Aobj,below of=a1] (a11) {$\PHobj{a_1}{a_1}$};
    \node[Asol,below of=a11] (a11s) {};
    \node[Assol,below of=a11s] (na11s) {$\emptyset$};
    \node[Aobj,below left of=a1] (a01) {$\PHobj{a_0}{a_1}$};
    \node[Asol,below of=a01] (a01s) {};
    \node[Assol,below of=a01s] (a01ss) {$\{b_0\}$};
    \node[Aproc,below of=a01ss] (b0) {$b_0$};
    \node[Aobj,below of=b0] (b00) {$\PHobj{b_0}{b_0}$};
    \node[Asol,below of=b00] (b00s) {};
    \node[Assol,below of=b00s] (nb00s) {$\emptyset$};
    \node[Aobj,below left of=b0] (b10) {$\PHobj{b_1}{b_0}$};
    \node[Asol,below of=b10] (b10s) {};
    \node[Assol,below of=b10s] (nb10s) {$\emptyset$};

    \node[Aproc,below right of=a1a1ss] (b1) {$b_1$};
    \node[Aobj,below of=b1] (b11) {$\PHobj{b_1}{b_1}$};
    \node[Asol,below of=b11] (b11s) {};
    \node[Assol,below of=b11s] (nb11s) {$\emptyset$};
    \node[Aobj,below right of=b1] (b01) {$\PHobj{b_0}{b_1}$};
    \node[Asol,below of=b01] (b01s) {};
    \node[Assol,below of=b01s] (b01ss) {$\{a_0\}$};
    \node[Aproc,below of=b01ss] (a0) {$a_0$};
    \node[Aobj,below of=a0] (a00) {$\PHobj{a_0}{a_0}$};
    \node[Asol,below of=a00] (a00s) {};
    \node[Assol,below of=a00s] (na00s) {$\emptyset$};
    \node[Aobj,below right of=a0] (a10) {$\PHobj{a_1}{a_0}$};
    \node[Asol,below of=a10] (a10s) {};
    \node[Assol,below of=a10s] (na10s) {$\emptyset$};

    \path
    (c1) edge (c01)
    (c01) edge (c01s)
    (c01s) edge (a1a1ss)
    (a1a1ss) edge (a1) edge (b1)

    (a1) edge (a01) edge (a11)
    (a01) edge (a01s)
    (a01s) edge (a01ss)
    (a01ss) edge (b0)
    (a11) edge (a11s)
    (a11s) edge (na11s)
    (a0) edge (a10) edge (a00)
    (a10) edge (a10s)
    (a10s) edge (na10s)
    (a00) edge (a00s)
    (a00s) edge (na00s)

    (b0) edge (b10) edge (b00)
    (b10) edge (b10s)
    (b10s) edge (nb10s)
    (b00) edge (b00s)
    (b00s) edge (nb00s)
    (b1) edge (b01) edge (b11)
    (b01) edge (b01s)
    (b01s) edge (b01ss)
    (b01ss) edge (a0)
    (b11) edge (b11s)
    (b11s) edge (nb11s)
    ;
    \end{tikzpicture}
  \caption{
  \label{fig:sa-livelock}
    The saturated graph of local causality of the AAN in \pref{fig:ph-livelock}
    for the objective $\w = \PHobj{c_0}{c_1}$
    and the initial context $\ctx = \PHstate{a_1, b_0, c_0}$.
    Elements in $\Proc$ are represented by rectangular nodes,
    elements in $\Sol$ are represented by circle nodes,
    and elements in $\sSol$ and $\Obj$ are the remaining borderless nodes.
    \pref{th:approxinf} is inconclusive on this example as node $\{ a_1, b_1 \}$
    is not independent (see \pref{def:coherent}).
    Indeed, $a_0 \in \Proc$ is a successor of $\{ a_1, b_1 \}$, but $a_0 \neq a_1$
    (and the same also stands for $b_0$).
  }
\end{figure}
\end{example}



\subsection{Extraction of a Scenario}
\label{ssec:concret}

This section gives a recursive method to find a scenario that concretizes
the reachability of a given local state $\myp \in \Proc$,
from a given initial state $s_0 \in \PHl$,
provided that \pref{th:approxinf} answered positively
for a context $\ctx \in \Ctx$ so that $s_0 \subset \ctx$.
The algorithm proposed in the following relies on a traversal of the Local Causality Graph
$\cwB$ that has been used for this conclusion.
The correctness of this extraction can be demonstrated
in the same fashion as \pref{th:approxinf}.

This algorithm consists in visiting all required nodes in a given order,
to build a sequence of actions that concretizes the objective.
The actions to perform on a given node,
listed below,
depend on the current state, the type of node, the markers on this node
and the state of the traversal which can be either “descending” (D) or “ascending” (A).
Nodes in $\Sol$ can be marked with a sequence of actions
and nodes in $\sSol$ can be marked with a set of local states.
The traversal starts in node $\myp$ in descending mode,
the starting state is $s = s_0$
and the initial output is the empty sequence $\emptyseq$.

\begin{itemize}
  \item In a node $a_k \in \Proc$:
    \begin{itemize}
      \item[D)] Descend in the node $\PHobj{\PHget{s}{a}}{a_k} \in \Obj$.
      \item[A)] Ascend in the parent $\sSol$ node, if any,
        and remove the element $a_k$ from its marking set.
        If the node has no $\sSol$ parent, the traversal is complete
        and the output of the algorithm is the current output.
    \end{itemize}
  
  \item In a node $\PHobj{a_j}{a_k} \in \Obj$:
    \begin{itemize}
      \item[D)] Descend in an arbitrarily chosen $\sSol$ node,
        and mark it with a sequence $\zeta \in \BS$ so that $\abstr{\zeta} = pps$.
      \item[A)] Ascend in the parent $\Proc$ or $\Obj$ node.
    \end{itemize}
  
  \item In a node $pps \in \Sol$ with the current marking $\zeta$:
    \begin{itemize}
      \item If $\zeta \neq \emptyseq$,
        descend in the node $ps \in \sSol$
        so that $ps = \hitter{\zeta_1}$
        and mark it with the set $ps$.
      \item If $\zeta = \emptyseq$,
        ascend in the parent $\Obj$ node and carry on ascending.
    \end{itemize}
  
  \item In a $\sSol$ node with the current marking $m$:
    \begin{itemize}
      \item If $m \neq \emptyset$,
        descend in a child node $a_k \in \Proc$ arbitrarily chosen,
        so that $a_k \in m$ and carry on descending.
      \item If $m = \emptyset$,
        ascend in the parent $\sSol$ node.
        Let $\zeta$ be the current marking of this node.
        If $\zeta_1$ is playable in $s$:
          append $\zeta_1$ to the output,
          change the current state to $s \play \zeta_1$
          and mark this node with $\zeta_{2..|\zeta|}$.
        If $\zeta_1$ is not playable
        (which means that $\target{\zeta_1}$ has changed):
          go to the node $\PHobj{\PHget{s}{\PHsort(\bounce{\zeta_1})}}{\bounce{\zeta_1}} \in \Obj$
          and start descending.
    \end{itemize}
\end{itemize}



\subsection{Sequential Under-approximation}
\label{ssec:ordered-ua}

In this section, we briefly explain an alternative sufficient condition that
can be applied when looking for scenarios that successively reach a sequence of local states (e.g.,
first reach $a_j$, then later $b_k$, \ldots).

The approach proposed in this sub-section essentially applies the previous under-approximation for
the first local states, and then computes a set of contexts that may be considered as the starting
point for the next local states.
In that way, the local states to reach are taken into account separately, which implies that only a
subset of scenarios can be captured.
%However, because each iteration focuses on a smaller part of the network, this
%sequential under-approximation may be more conclusive.


\todo{computes possible outcomes from the LCG, gives it as context for the next stage}.



\subsection{Reachability of a State}
\label{ssec:simult-ua}

\newcommand{\total}{\tau}
\newcommand{\reach}{\sigma}

The reachability property studied so far concerns a single local state at a time.
However, we remark that the reachability of a global state or a sub-state can be
addressed with the very same analysis by introducing a dedicated automata.
Such analysis was not possible with the Process Hitting framework,
because of the lack of the notion of simultaneity for more than two components.

In order to check the reachability of a global state $s \in \PHl$,
let $\PH = (\PHs, \PHl, \PHh)$ be an AAN.
We define a new AAN $\PH' = (\PHs', \PHl', \PHh')$ with:
$\PHs' = \PHs \cup \{ \reach \}$, $\PHl' = \PHl \times \PHl_\reach$,
where $\PHl_\reach = \{ \reach_0, \reach_1 \}$,
and $\PHh' = \PHh \cup \{ \PHhit{\toset{s}}{\reach_0}{\reach_1} \}$.
Given an initial context $\ctx$, the reachability of $s$ in $\PH$
is equivalent to the concretization of $\PHobjp{\reach}{0}{1}$ in $\PH'$
from the initial context $\ctx \cup \{ \reach_0 \}$,
which can be efficiently under-approximated using \pref{th:approxinf}.

It is of course also possible to compute the reachability
of a sub-state $s \in \PHsubl[\PHl]_S$ of a set of components $S \subseteq \PHs$
with the same method.
One can also check the reachability of a set of states $\Lambda \subseteq \PHl$
by creating several actions
$\PHhit{\toset{s}}{\reach_0}{\reach_1}$ in $\PHh$ for each state $s \in \Lambda$.
